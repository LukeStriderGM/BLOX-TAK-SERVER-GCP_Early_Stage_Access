#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import subprocess
import yaml
import datetime
from fpdf import FPDF
from fpdf.enums import XPos, YPos

# --- CONFIGURATION & CONSTANTS ---
# --- KONFIGURACJA I STAÅE ---

CONFIG_FILE = 'config.yaml'

FONTS = {
    'R': "UbuntuMono-Regular.ttf",
    'B': "UbuntuMono-Bold.ttf",
    'I': "UbuntuMono-Italic.ttf"
}

SEP = "|||SECRET_DELIMITER|||"
REDACT_CHAR = "â–ˆ"

TEXTS = {
    'EN': {
        'file_prefix': "REPORT",
        'public_suffix': "_PUBLIC",
        'title': "OPERATIONAL REPORT",
        'footer': "Generated by Smart Auditor",
        'sec1': "1. OPERATION METRICS",
        'sec2': "2. SYSTEM HEALTH & RESOURCES",
        'sec3': "3. DOCKER SERVICES & CONTAINERS",
        'sec4': "4. LOGS & ARTIFACTS",
        'dock_name': "CONTAINER NAME", 'dock_status': "STATUS", 'dock_ports': "PORTS / INFO",
        'no_dock': "No running containers detected.", 'status_ok': "[ SYSTEM STATUS: ONLINE & SECURE ]",
        'logs_info': "Logs collected: PENDING (See Phase 2)",
        'labels': {
            'date': "Audit Date:", 'operator': "Operator:", 'target': "Target (VM):",
            'wan': "Host (WAN IP):", 'lan': "Host (LAN IP):", 'loc': "GCP Location:",
            'type': "Machine Type:", 'host': "Hostname:", 'os': "System:",
            'kernel': "Kernel:", 'up': "Uptime:", 'ram': "RAM Usage:", 'disk': "Disk Usage:"
        }
    },
    'PL': {
        'file_prefix': "RAPORT",
        'public_suffix': "_PUBLICZNY",
        'title': "RAPORT OPERACYJNY",
        'footer': "Wygenerowano przez Smart Auditor",
        'sec1': "1. METRYKA OPERACJI",
        'sec2': "2. STATUS ZASOBÃ“W SYSTEMOWYCH",
        'sec3': "3. USÅUGI DOCKER I KONTENERY",
        'sec4': "4. LOGI I ARTEFAKTY",
        'dock_name': "NAZWA KONTENERA", 'dock_status': "STATUS", 'dock_ports': "PORTY / INFO",
        'no_dock': "Nie wykryto uruchomionych kontenerÃ³w.", 'status_ok': "[ STATUS SYSTEMU: AKTYWNY I BEZPIECZNY ]",
        'logs_info': "Logi systemowe: OCZEKIWANIE (Patrz Faza 2)",
        'labels': {
            'date': "Data audytu:", 'operator': "Operator:", 'target': "Cel (VM):",
            'wan': "Adres (WAN IP):", 'lan': "Adres (LAN IP):", 'loc': "Lokalizacja GCP:",
            'type': "Typ Maszyny:", 'host': "Nazwa Hosta:", 'os': "System:",
            'kernel': "JÄ…dro:", 'up': "Czas pracy:", 'ram': "ZuÅ¼ycie RAM:", 'disk': "ZuÅ¼ycie Dysku:"
        }
    }
}

# --- HELPER FUNCTIONS ---
# --- FUNKCJE POMOCNICZE ---

def load_config():
    # Check if config file exists
    # SprawdÅº, czy plik konfiguracyjny istnieje
    if not os.path.exists(CONFIG_FILE): return None
    
    # Load and parse YAML file
    # Wczytaj i przetwÃ³rz plik YAML
    with open(CONFIG_FILE, 'r', encoding='utf-8') as f: return yaml.safe_load(f)

def run_ssh_command_capture(host_ip, user, command):
    # Prepare SSH command with options
    # Przygotuj komendÄ™ SSH z opcjami
    full_command = ['ssh', '-o', 'StrictHostKeyChecking=no', '-o', 'ConnectTimeout=10', f'{user}@{host_ip}', command]
    
    try:
        # Execute command and capture output
        # Wykonaj komendÄ™ i przechwyÄ‡ wyjÅ›cie
        res = subprocess.run(full_command, capture_output=True, text=True)
        if res.returncode != 0:
            print(f"âŒ SSH ERROR: {res.stderr.strip()}")
            print(f"âŒ BÅÄ„D SSH: {res.stderr.strip()}")
            return None
        return res.stdout.strip()
    except Exception as e:
        print(f"âŒ SSH EXCEPTION: {e}")
        print(f"âŒ WYJÄ„TEK SSH: {e}")
        return None

def parse_output(raw):
    # Initialize data dictionary
    # Inicjalizuj sÅ‚ownik danych
    data = {}
    if not raw: return data
    
    curr, buf = None, []
    # Iterate through lines to parse sections
    # Iteruj przez linie, aby przetworzyÄ‡ sekcje
    for line in raw.splitlines():
        if line.startswith(SEP):
            if curr: data[curr] = "\n".join(buf).strip()
            curr = line.replace(SEP, "").strip(); buf = []
        else: buf.append(line)
    if curr: data[curr] = "\n".join(buf).strip()
    return data

def redact(text, is_public, mode='full'):
    # Return original text if not public
    # ZwrÃ³Ä‡ oryginalny tekst, jeÅ›li nie jest publiczny
    if not is_public: return text
    
    # Apply full redaction
    # Zastosuj peÅ‚nÄ… redakcjÄ™
    if mode == 'full': return REDACT_CHAR * 10
    
    # Apply IP address redaction
    # Zastosuj redakcjÄ™ adresu IP
    if mode == 'ip': return f"{REDACT_CHAR*3}.{REDACT_CHAR*3}.{REDACT_CHAR*3}.{REDACT_CHAR*3}"
    return text

# --- PDF GENERATION CLASS ---
# --- KLASA GENEROWANIA PDF ---

class PDFReport(FPDF):
    def __init__(self, vm_name, lang='EN'):
        super().__init__()
        self.vm_name = vm_name
        self.lang = lang
        self.t = TEXTS[lang]

    def header(self):
        # Set font and create title
        # Ustaw czcionkÄ™ i utwÃ³rz tytuÅ‚
        self.set_font('UbuntuMono', 'B', 14)
        self.cell(0, 10, f"{self.t['title']}: {self.vm_name}", new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='C')
        self.line(10, 25, 200, 25)
        self.ln(10)

    def footer(self):
        # Position footer at bottom
        # Ustaw stopkÄ™ na dole
        self.set_y(-15)
        self.set_font('UbuntuMono', 'I', 8)
        self.cell(0, 10, f"{self.t['footer']} | {datetime.datetime.now().strftime('%Y-%m-%d %H:%M')} | {self.lang}", align='C')

    def print_row(self, data, widths, fill=False):
        # Calculate row height dynamically
        # Oblicz wysokoÅ›Ä‡ wiersza dynamicznie
        font_size = self.font_size_pt / 72 * 25.4
        line_height = font_size * 1.5
        max_lines = 1
        
        for i, text in enumerate(data):
            lines = self.multi_cell(widths[i], line_height, str(text), dry_run=True, output="LINES")
            max_lines = max(max_lines, len(lines))
        
        row_height = max_lines * line_height

        # Add page break if needed
        # Dodaj podziaÅ‚ strony w razie potrzeby
        if self.get_y() + row_height > self.page_break_trigger:
            self.add_page()

        x_start, y_start = self.get_x(), self.get_y()

        # Draw background if fill is enabled
        # Rysuj tÅ‚o, jeÅ›li wypeÅ‚nienie jest wÅ‚Ä…czone
        if fill:
            self.set_fill_color(220, 220, 220)
            self.rect(x_start, y_start, sum(widths), row_height, 'F')
        
        curr_x = x_start
        for i, text in enumerate(data):
            w = widths[i]
            self.set_xy(curr_x, y_start)
            self.multi_cell(w, line_height, str(text), border=0, align='L')
            self.rect(curr_x, y_start, w, row_height)
            curr_x += w

        self.set_xy(x_start, y_start + row_height)

def generate_pdf(vm_name, evidence, ext_ip, int_ip, lang, is_public):
    t = TEXTS[lang]
    l = t['labels']
    pdf = PDFReport(vm_name, lang)
    
    try:
        # Add fonts support
        # Dodaj obsÅ‚ugÄ™ czcionek
        pdf.add_font('UbuntuMono', '', FONTS['R'])
        pdf.add_font('UbuntuMono', 'B', FONTS['B'])
        pdf.add_font('UbuntuMono', 'I', FONTS['I'])
        font = 'UbuntuMono'
    except:
        font = 'Courier'
    
    pdf.add_page()
    pdf.set_font(font, size=10)

    # 1. METRICS
    # 1. METRYKI
    pdf.set_font(font, 'B', 12)
    pdf.cell(0, 8, t['sec1'], new_x=XPos.LMARGIN, new_y=YPos.NEXT)
    
    m_data = [
        (l['date'], datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')),
        (l['operator'], redact("Night Ghost", is_public)),
        (l['target'], vm_name),
        (l['wan'], redact(ext_ip, is_public, 'ip')),
        (l['lan'], redact(int_ip, is_public, 'ip') + " (SECURE SSH)"),
        (l['loc'], evidence.get('GCP_ZONE', 'Unknown')),
        (l['type'], evidence.get('GCP_MACHINE', 'Unknown'))
    ]

    pdf.set_font(font, '', 10)
    w_metrics = [60, 130]
    for label, val in m_data:
        pdf.print_row([label, val], w_metrics)
    pdf.ln(5)

    # 2. SYSTEM
    # 2. SYSTEM
    pdf.set_font(font, 'B', 12)
    pdf.cell(0, 8, t['sec2'], new_x=XPos.LMARGIN, new_y=YPos.NEXT)
    
    ram = evidence.get('MEMORY', 'N/A').split()
    r_dsp = f"{ram[2]}/{ram[1]} used" if len(ram)>2 else "N/A"
    dsk = evidence.get('DISK', 'N/A').split()
    d_dsp = f"{dsk[4]} of {dsk[1]}" if len(dsk)>4 else "N/A"

    s_data = [
        (l['host'], evidence.get('HOSTNAME', 'N/A')),
        (l['os'], evidence.get('DISTRO', 'N/A').strip()),
        (l['kernel'], redact(evidence.get('KERNEL', 'N/A'), is_public)),
        (l['up'], evidence.get('UPTIME', 'N/A')),
        (l['ram'], r_dsp),
        (l['disk'], d_dsp)
    ]

    pdf.set_font(font, '', 10)
    for label, val in s_data:
        pdf.print_row([label, val], w_metrics)
    pdf.ln(5)

    # 3. DOCKER
    # 3. DOCKER
    pdf.set_font(font, 'B', 12)
    pdf.cell(0, 8, t['sec3'], new_x=XPos.LMARGIN, new_y=YPos.NEXT)
    
    w_dock = [60, 35, 95]
    pdf.set_font(font, 'B', 9)
    pdf.print_row([t['dock_name'], t['dock_status'], t['dock_ports']], w_dock, fill=True)
    
    pdf.set_font(font, '', 8)
    docker_raw = evidence.get('DOCKER', '')
    has_cont = False
    
    if docker_raw:
        for row in docker_raw.splitlines():
            if not row.strip(): continue
            parts = row.split('|')
            if len(parts) >= 3:
                has_cont = True
                name, stat, ports = parts[0], parts[1], parts[2]
                if is_public:
                    ports = ports.replace("0.0.0.0", "XXX.XXX.XXX.XXX")
                pdf.print_row([name, stat, ports], w_dock)
    
    if not has_cont:
         pdf.cell(190, 6, t['no_dock'], border=1, new_x=XPos.LMARGIN, new_y=YPos.NEXT)

    # 4. LOGS
    # 4. LOGI
    pdf.ln(5)
    pdf.set_font(font, 'B', 12)
    pdf.cell(0, 8, t['sec4'], new_x=XPos.LMARGIN, new_y=YPos.NEXT)
    pdf.set_font(font, '', 10)
    pdf.cell(0, 5, t['logs_info'], new_x=XPos.LMARGIN, new_y=YPos.NEXT)
    pdf.ln(5)
    pdf.set_font(font, 'B', 11)
    pdf.cell(0, 10, t['status_ok'], new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='R')

    # PREFIX / SUFFIX
    # PREFIKS / SUFIKS
    prefix = t['file_prefix']
    ts = datetime.datetime.now().strftime('%Y%m%d_%H%M')
    
    suffix = ""
    if is_public:
        if lang == 'PL': suffix = "_PUBLICZNY"
        else: suffix = "_PUBLIC"

    filename = f"{prefix}_{vm_name}_{ts}_{lang}{suffix}.pdf"
    
    # Save file and notify user
    # Zapisz plik i powiadom uÅ¼ytkownika
    pdf.output(filename)
    vis = "ğŸ™ˆ PUBLIC" if is_public else "ğŸ”’ PRIVATE"
    print(f"âœ… Generated [{lang}][{vis}]: {filename}")
    print(f"âœ… Wygenerowano [{lang}][{vis}]: {filename}")
    return filename

# --- MAIN EXECUTION ---
# --- GÅÃ“WNE WYKONANIE ---

def main():
    # Clear terminal screen
    # WyczyÅ›Ä‡ ekran terminala
    os.system("clear || cls")
    
    print("=" * 60)
    print("=== SMART AUDITOR v12.1 (USER FIX) ===")
    print("=== SMART AUDITOR v12.1 (POPRAWKA UÅ»YTKOWNIKA) ===")
    print("=" * 60)
    
    config = load_config()
    if not config: return

    vms = {k: v for k, v in config.items() if isinstance(v, dict) and 'name' in v and k != 'LOCAL_CONFIG'}
    
    print("\nAvailable VMs:")
    print("DostÄ™pne VM:")
    for k, v in vms.items(): print(f"  [{k}] {v['name']}")

    print("\nEnter VM Key:")
    print("WprowadÅº klucz VM:")
    key = input("> ").strip().upper()
    
    if key not in vms: return
    vm = vms[key]
    
    # Configure user connection details
    # Skonfiguruj szczegÃ³Å‚y poÅ‚Ä…czenia uÅ¼ytkownika
    user = vm.get('user', 'blox_tak_server_admin')
    int_ip = vm.get('internal_ip')
    ext_ip = vm.get('external_ip', 'Unknown')
    
    print(f"   (Connecting as: {user}@{int_ip})")
    print(f"   (ÅÄ…czenie jako: {user}@{int_ip})")

    # Define remote script with -a and --no-trunc flags for Docker
    # Zdefiniuj zdalny skrypt z flagami -a i --no-trunc dla Dockera
    script = (
        f"echo '{SEP}HOSTNAME'; hostname; "
        f"echo '{SEP}UPTIME'; uptime -p; "
        f"echo '{SEP}KERNEL'; uname -sr; "
        f"echo '{SEP}DISTRO'; lsb_release -d | cut -f2; "
        f"echo '{SEP}DISK'; df -h / | grep /$; "
        f"echo '{SEP}MEMORY'; free -h | grep Mem; "
        f"echo '{SEP}GCP_ZONE'; curl -s -H 'Metadata-Flavor: Google' http://metadata.google.internal/computeMetadata/v1/instance/zone | rev | cut -d/ -f1 | rev; "
        f"echo '{SEP}GCP_MACHINE'; curl -s -H 'Metadata-Flavor: Google' http://metadata.google.internal/computeMetadata/v1/instance/machine-type | rev | cut -d/ -f1 | rev; "
        f"echo '{SEP}DOCKER'; sudo docker ps -a --no-trunc --format '{{{{.Names}}}}|{{{{.Status}}}}|{{{{.Ports}}}}'"
    )

    print(f"\nğŸš€ Auditing {vm['name']}...")
    print(f"ğŸš€ Audytowanie {vm['name']}...")
    
    raw = run_ssh_command_capture(int_ip, user, script)
    if not raw:
        print("âŒ CRITICAL: SSH Failed. Check if key is loaded (ssh-add).")
        print("âŒ KRYTYCZNE: BÅ‚Ä…d SSH. SprawdÅº czy klucz jest zaÅ‚adowany (ssh-add).")
        return

    evidence = parse_output(raw)
    
    print("\nğŸ“„ Generating Reports (4 variants)...")
    print("\nğŸ“„ Generowanie RaportÃ³w (4 warianty)...")
    
    for is_public in [False, True]:
        generate_pdf(vm['name'], evidence, ext_ip, int_ip, 'EN', is_public)
        generate_pdf(vm['name'], evidence, ext_ip, int_ip, 'PL', is_public)

    print("\n" + "=" * 60)
    print("âœ… PROCESS COMPLETE")
    print("âœ… PROCES ZAKOÅƒCZONY")
    print("=" * 60)

if __name__ == "__main__":
    main()
