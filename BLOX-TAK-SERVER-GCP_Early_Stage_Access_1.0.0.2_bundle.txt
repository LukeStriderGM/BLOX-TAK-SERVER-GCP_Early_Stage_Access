Project Bundle: BLOX-TAK-SERVER-GCP_Early_Stage_Access
Version: 1.0.0.2
Generated on: 2026-01-25 04:43:59
========================================

--- START FILE: .gitignore ---
# === Configuration Files / Pliki Konfiguracyjne ===
# NEVER commit the main configuration file with your secrets.
# NIGDY nie dodawaj do repozytorium gÅ‚Ã³wnego pliku konfiguracyjnego z sekretami.
config.yaml

# Google Cloud credentials
# Dane uwierzytelniajÄ…ce Google Cloud
client_secret.json
token.json

# === Python ===
# Virtual environment folders
# Foldery Å›rodowiska wirtualnego
.venv/
venv/
env/

# Python cache
# PamiÄ™Ä‡ podrÄ™czna Pythona
__pycache__/
*.pyc

# === Terraform ===
# Local Terraform directories and state files
# Lokalne katalogi i pliki stanu Terraform
.terraform/
.terraform.lock.hcl
terraform.tfstate
terraform.tfstate.d/
terraform.tfstate.backup

# === Certificates & Keys ===
# Generated certificates, keys, and VPN configurations
# Wygenerowane certyfikaty, klucze i konfiguracje VPN
gcp_tak_certs/
*.p12
*.cer
*.key
*.pem

# === Generated Files & Logs ===
# Temporary files, logs, and build artifacts
# Pliki tymczasowe, logi i artefakty kompilacji
*.log
*.tmp
*.zip
*.png

# Bundled project file
# Spakowany plik projektu
codebase_bundle.txt

# === IDE & OS specific ===
# Pliki specyficzne dla IDE i systemu operacyjnego
.idea/
.vscode/
.DS_Store
--- END FILE: .gitignore ---

--- START FILE: BLOX-TAK-SERVER-GCP_Early_Stage_Access_1.0.0.1_bundle.txt ---
Project Bundle: BLOX-TAK-SERVER-GCP_Early_Stage_Access
Version: 1.0.0.1
Generated on: 2025-08-03 19:22:36
========================================

--- START FILE: .gitignore ---
# === Configuration Files / Pliki Konfiguracyjne ===
# NEVER commit the main configuration file with your secrets.
# NIGDY nie dodawaj do repozytorium gÅ‚Ã³wnego pliku konfiguracyjnego z sekretami.
config.yaml

# Google Cloud credentials
# Dane uwierzytelniajÄ…ce Google Cloud
client_secret.json
token.json

# === Python ===
# Virtual environment folders
# Foldery Å›rodowiska wirtualnego
.venv/
venv/
env/

# Python cache
# PamiÄ™Ä‡ podrÄ™czna Pythona
__pycache__/
*.pyc

# === Terraform ===
# Local Terraform directories and state files
# Lokalne katalogi i pliki stanu Terraform
.terraform/
.terraform.lock.hcl
terraform.tfstate
terraform.tfstate.d/
terraform.tfstate.backup

# === Certificates & Keys ===
# Generated certificates, keys, and VPN configurations
# Wygenerowane certyfikaty, klucze i konfiguracje VPN
gcp_tak_certs/
*.p12
*.cer
*.key
*.pem

# === Generated Files & Logs ===
# Temporary files, logs, and build artifacts
# Pliki tymczasowe, logi i artefakty kompilacji
*.log
*.tmp
*.zip
*.png

# Bundled project file
# Spakowany plik projektu
codebase_bundle.txt

# === IDE & OS specific ===
# Pliki specyficzne dla IDE i systemu operacyjnego
.idea/
.vscode/
.DS_Store
--- END FILE: .gitignore ---

--- START FILE: CODE_OF_CONDUCT.md ---
## Contributor Covenant Code of Conduct

### Our Pledge

We as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, religion, or sexual identity
and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.

### Our Standards

Examples of behavior that contributes to a positive environment for our
community include:

* Demonstrating empathy and kindness toward other people
* Being respectful of differing opinions, viewpoints, and experiences
* Giving and gracefully accepting constructive feedback
* Accepting responsibility and apologizing to those affected by our mistakes,
    and learning from the experience
* Focusing on what is best not just for us as individuals, but for the
    overall community

Examples of unacceptable behavior include:

* The use of sexualized language or imagery, and sexual attention or
    advances of any kind
* Trolling, insulting or derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or email
    address, without their explicit permission
* Other conduct which could reasonably be considered inappropriate in a
    professional setting

### Enforcement Responsibilities

Community leaders are responsible for clarifying and enforcing our standards and
will take appropriate and fair corrective action in response to any behavior
that they deem inappropriate, threatening, offensive, or harmful.

Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.

### Scope

This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.

### Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at
**luke.strider.gm@gmail.com**.
All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the
reporter of any incident.

### Enforcement Guidelines

Community leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:

### 1. Correction

**Community Impact**: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.

**Consequence**: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.

### 2. Warning

**Community Impact**: A violation through a single incident or series
of actions.

**Consequence**: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interaction in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or
permanent ban.

### 3. Temporary Ban

**Community Impact**: A serious violation of community standards, including
sustained inappropriate behavior.

**Consequence**: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.

### 4. Permanent Ban

**Community Impact**: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior, harassment of an
individual, or aggression toward or disparagement of classes of individuals.

**Consequence**: A permanent ban from any sort of public interaction within
the community.

---
Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage],
version 2.1, available at
[https://www.contributor-covenant.org/version/2/1/code_of_conduct.html][v2.1].

[homepage]: https://www.contributor-covenant.org
[v2.1]: https://www.contributor-covenant.org/version/2/1/code_of_conduct.html
--- END FILE: CODE_OF_CONDUCT.md ---

--- START FILE: LICENSE.txt ---
MIT License

Copyright (c) 2025 Åukasz "LukeStriderGM" Andruszkiewicz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
--- END FILE: LICENSE.txt ---

--- START FILE: README.md ---
# ğŸ‡ºğŸ‡¸ BLOX-TAK-SERVER-GCP (Early Stage Access)

Welcome to the early stage private repository for the **BLOX-TAK-SERVER-GCP** project. This suite of scripts is designed to provide a robust, secure, and highly automated foundation for deploying a TAK (Team Awareness Kit) ecosystem on the Google Cloud Platform.

This repository is currently shared with a select group of authorities, mentors, and leaders within the TAK community for feedback, discussion, and testing. The goal is to refine this core infrastructure before a potential public release.

<details>

<summary>ğŸ‡µğŸ‡± [Kliknij TrÃ³jkÄ…t Po Lewej Stronie Aby RozwinÄ…Ä‡ Opis w JÄ™zyku Polskim]</summary>

# ğŸ‡µğŸ‡± BLOX-TAK-SERVER-GCP (DostÄ™p Do Wczesnego Etapu)

Witaj we wczesnym, prywatnym repozytorium projektu **BLOX-TAK-SERVER-GCP**. Ten pakiet skryptÃ³w zostaÅ‚ zaprojektowany, aby zapewniÄ‡ solidnÄ…, bezpiecznÄ… i wysoce zautomatyzowanÄ… podstawÄ™ do wdraÅ¼ania ekosystemu TAK (Team Awareness Kit) na platformie Google Cloud Platform.

To repozytorium jest obecnie udostÄ™pniane wybranej grupie autorytetÃ³w, mentorÃ³w i liderÃ³w w spoÅ‚ecznoÅ›ci TAK w celu uzyskania opinii, dyskusji i testÃ³w. Celem jest udoskonalenie tej podstawowej infrastruktury przed potencjalnym publicznym wydaniem.

</details>

---

## ğŸ‡ºğŸ‡¸ Core Features

This package contains the foundational scripts to deploy and manage a complete server instance from scratch. The entire process, from a clean GCP project to a fully operational server with an admin and first client, can be completed in **under one hour**.

* **Automated VM Deployment**: Utilizes **Terraform** to create and configure a secure GCP virtual machine based on Ubuntu 22.04 LTS.
* **Mandatory Hardware-Key Security**: Enforces the use of a **YubiKey** (or similar FIDO/U2F key) for all SSH administrative access, eliminating password-based logins.
    I also use the YubiKey to secure my Google services, as well as all operations requiring sudo on my MDC2 laptop - including login + disk encryption.
* **Automated WireGuard VPN**: Deploys a WireGuard server for secure, encrypted communication tunnels. Includes scripts to configure both admin (split-tunnel by default) and end-user (split-tunnel by default) clients.
* **For mission-critical security**, at this stage you can manually switch to the full-tunnel function, which completely cuts off external network traffic and allows you to operate only in a pure TAK ecosystem.
* **Docker & TAK Server Installation**: Fully automates the installation of Docker and the TAK Server itself, including downloading necessary files from Google Drive.
* **Client & Certificate Management**: Includes Python scripts to add new SSH keys and configure clients for WireGuard.
* **Bilingual Interface**: All scripts provide interactive prompts and status messages in both English and Polish.

<details>

<summary>ğŸ‡µğŸ‡±</summary>

## ğŸ‡µğŸ‡± GÅ‚Ã³wne FunkcjonalnoÅ›ci

Ten pakiet zawiera podstawowe skrypty do wdroÅ¼enia i zarzÄ…dzania kompletnÄ… instancjÄ… serwera od zera. CaÅ‚y proces, od czystego projektu GCP do w peÅ‚ni dziaÅ‚ajÄ…cego serwera z administratorem i pierwszym klientem, moÅ¼na ukoÅ„czyÄ‡ w **mniej niÅ¼ godzinÄ™**.

* **Automatyczne WdroÅ¼enie Maszyny Wirtualnej**: Wykorzystuje **Terraform** do tworzenia i konfigurowania bezpiecznej maszyny wirtualnej GCP opartej na Ubuntu 22.04 LTS.
* **Wymuszone BezpieczeÅ„stwo Kluczem SprzÄ™towym**: Wymusza uÅ¼ycie **YubiKey** (lub podobnego klucza FIDO/U2F) do caÅ‚ego administracyjnego dostÄ™pu przez SSH, eliminujÄ…c logowanie oparte na haÅ›le.
    Klucza YubiKey uÅ¼ywam rÃ³wnieÅ¼ do zabezpiecznia moich usÅ‚ug w Google, a takÅ¼e wszystkich operacji wymagajÄ…cych sudo na laptopie MDC2 - rÃ³wnieÅ¼ przy logowaniu + szyfrowanie dyskÃ³w. 
* **Automatyczny VPN WireGuard**: WdraÅ¼a serwer WireGuard do bezpiecznych, szyfrowanych tuneli komunikacyjnych. Zawiera skrypty do konfiguracji zarÃ³wno klientÃ³w administracyjnych (domyÅ›lnie split-tunnel), jak i koÅ„cowych uÅ¼ytkownikÃ³w (domyÅ›lnie split-tunnel).
* **Dla bezpieczeÅ„stwa misji o znaczeniu krytycznym**, na tym etapie moÅ¼na przejÅ›Ä‡ rÄ™cznie na funkcjÄ™ full-tunnel ktÃ³ra caÅ‚kowicie odcina zewnÄ™trzny ruch z sieci i pozwala operowaÄ‡ tylko w czystym ekosystemie TAK.
* **Instalacja Dockera i Serwera TAK**: W peÅ‚ni automatyzuje instalacjÄ™ Dockera i samego Serwera TAK, w tym pobieranie niezbÄ™dnych plikÃ³w z Dysku Google.
* **ZarzÄ…dzanie Klientami i Certyfikatami**: Zawiera skrypty Pythona do dodawania nowych kluczy SSH i konfigurowania klientÃ³w dla WireGuard.
* **DwujÄ™zyczny Interfejs**: Wszystkie skrypty zapewniajÄ… interaktywne monity i komunikaty o stanie w jÄ™zyku angielskim i polskim.

</details>

---

## ğŸ‡ºğŸ‡¸ Prerequisites

To use these scripts, you will need the following on your **local admin machine** (which should be Ubuntu 22.04 for full compatibility):

1.  **Google Cloud Platform (GCP) Account**: A GCP account with an active project and billing enabled.
2.  **Google Cloud CLI**: The `gcloud` command-line tool installed and authenticated.
3.  **Terraform**: The Terraform CLI installed.
4.  **YubiKey (or other FIDO/U2F key)**: A hardware security key for generating your `ed25519-sk` SSH key. **This is not optional.**
5.  **Python 3 & Dependencies**.
6.  **Ubuntu 22.04 LTS**.


<details>

<summary>ğŸ‡µğŸ‡±</summary>

## ğŸ‡µğŸ‡± Wymagania WstÄ™pne

Do uÅ¼ycia tych skryptÃ³w potrzebne bÄ™dÄ… nastÄ™pujÄ…ce elementy na Twojej **lokalnej maszynie administracyjnej** (ktÃ³ra dla peÅ‚nej kompatybilnoÅ›ci powinna byÄ‡ oparta na Ubuntu 22.04):

1.  **Konto Google Cloud Platform (GCP)**: Konto GCP z aktywnym projektem i wÅ‚Ä…czonymi pÅ‚atnoÅ›ciami.
2.  **Google Cloud CLI**: Zainstalowane i uwierzytelnione narzÄ™dzie wiersza poleceÅ„ `gcloud`.
3.  **Terraform**: Zainstalowany interfejs CLI Terraform.
4.  **YubiKey (lub inny klucz FIDO/U2F)**: SprzÄ™towy klucz bezpieczeÅ„stwa do wygenerowania Twojego klucza SSH `ed25519-sk`. **To nie jest opcjonalne.**
5.  **Python 3 i ZaleÅ¼noÅ›ci**.
6.  **Ubuntu 22.04 LTS**.

</details>

---

## ğŸ‡ºğŸ‡¸ Deployment Guide / ğŸ‡µğŸ‡± Instrukcja WdroÅ¼enia

Follow these steps in order to set up your complete TAK Server ecosystem.

### ğŸ‡ºğŸ‡¸ Step 1: Prerequisites, Setup, and Firewall Configuration

This initial step covers everything you need to do on your **local admin machine** and in the **GCP Console** before deploying the virtual machine.

### Part A: Local Admin Machine Setup

1.  **Install Core Dependencies**:
    * First, update your system and install Python, pip, venv, and other required tools like `qrencode` and `wireguard`.
        ```bash
        sudo apt-get update && sudo apt-get install -y python3-pip python3-venv qrencode wireguard apt-transport-https ca-certificates curl
        ```

2.  **Install Google Cloud CLI**:
    * Add the gcloud CLI package source and install the command-line tool.
        ```bash
        curl -fsSL https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo gpg --dearmor -o /usr/share/keyrings/cloud.google.gpg
        echo "deb [signed-by=/usr/share/keyrings/cloud.google.gpg] https://packages.cloud.google.com/apt cloud-sdk main" | sudo tee /etc/apt/sources.list.d/google-cloud-sdk.list
        sudo apt-get update && sudo apt-get install -y google-cloud-cli
        ```

3.  **Install Terraform**:
    * Add the HashiCorp repository and install Terraform.
        ```bash
        sudo curl -fsSL https://apt.releases.hashicorp.com/gpg | sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg
        echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
        sudo apt-get update && sudo apt-get install -y terraform
        ```

4.  **Configure GCP Account & Generate SSH Key**:
    * Log in to your GCP account, set the project, and generate a new hardware-backed SSH key. **A YubiKey (or similar FIDO/U2F key) is mandatory.**
        ```bash
        # Log in to your Google Account (will open a browser)
        gcloud auth login
        ```
        
        ```bash 
        # Set your target GCP Project ID
        gcloud config set project <YOUR_PROJECT_ID>
        ````

        ```bash
        # Generate a new security key-backed SSH key
        ssh-keygen -t ed25519-sk -C "your_email@example.com"
        ```

5.  **Clone Repository & Install Python Dependencies**

    * If you don't have it configured - first:
        ```bash
        sudo apt install gh
        gh auth login
        ```

    * Finally, clone the project repository and install the required Python packages.
        ```bash
        git clone https://github.com/LukeStriderGM/BLOX-TAK-SERVER-GCP_Early_Stage_Access
        cd BLOX-TAK-SERVER-GCP_Early_Stage_Access
        pip install -r requirements.txt
        ```

### Part B: GCP Firewall Configuration

Before deploying the virtual machine, you must configure the firewall in your GCP project's VPC network to allow necessary traffic.

1.  Navigate to **VPC network -> Firewall** in your Google Cloud Console.
2.  Click **CREATE FIREWALL RULE** and create the following two rules:

#### Rule 1: Allow SSH Access from Admin IP
* **Name**: `ssh-22`
* **Direction of traffic**: `Ingress`
* **Action on match**: `Allow`
* **Targets**: `Specified target tags`
* **Target tags**: `tak-server`
* **Source filter**: `IPv4 ranges`
* **Source IPv4 ranges**: `0.0.0.0/32` (Enter your own admin IP here)
* **Protocols and ports**: `Specified protocols and ports` -> `tcp`: `22`

#### Rule 2: Allow WireGuard VPN Traffic
* **Name**: `wire-guard`
* **Direction of traffic**: `Ingress`
* **Action on match**: `Allow`
* **Targets**: `Specified target tags`
* **Target tags**: `tak-server`
* **Source filter**: `IPv4 ranges`
* **Source IPv4 ranges**: `0.0.0.0/0`
* **Protocols and ports**: `Specified protocols and ports` -> `udp`: `51820`

<details>
<summary>ğŸ‡µğŸ‡±</summary>

### ğŸ‡µğŸ‡± Krok 1: Wymagania, Konfiguracja i ReguÅ‚y Zapory Sieciowej

Ten poczÄ…tkowy krok obejmuje wszystko, co musisz zrobiÄ‡ na swojej **lokalnej maszynie administracyjnej** oraz w **Konsoli GCP** przed wdroÅ¼eniem maszyny wirtualnej.

### CzÄ™Å›Ä‡ A: Konfiguracja Lokalnej Maszyny Administracyjnej

1.  **Zainstaluj Podstawowe ZaleÅ¼noÅ›ci**:
    * Najpierw zaktualizuj system i zainstaluj Python, pip, venv oraz inne wymagane narzÄ™dzia, takie jak `qrencode` i `wireguard`.
        ```bash
        sudo apt-get update && sudo apt-get install -y python3-pip python3-venv qrencode wireguard apt-transport-https ca-certificates curl
        ```

2.  **Zainstaluj Google Cloud CLI**:
    * Dodaj ÅºrÃ³dÅ‚o pakietÃ³w gcloud CLI i zainstaluj narzÄ™dzie wiersza poleceÅ„.
        ```bash
        curl -fsSL https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo gpg --dearmor -o /usr/share/keyrings/cloud.google.gpg
        echo "deb [signed-by=/usr/share/keyrings/cloud.google.gpg] https://packages.cloud.google.com/apt cloud-sdk main" | sudo tee /etc/apt/sources.list.d/google-cloud-sdk.list
        sudo apt-get update && sudo apt-get install -y google-cloud-cli
        ```

3.  **Zainstaluj Terraform**:
    * Dodaj repozytorium HashiCorp i zainstaluj Terraform.
        ```bash
        sudo curl -fsSL https://apt.releases.hashicorp.com/gpg | sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg
        echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
        sudo apt-get update && sudo apt-get install -y terraform
        ```

4.  **Skonfiguruj Konto GCP i Wygeneruj Klucz SSH**:
    * Zaloguj siÄ™ na swoje konto GCP, ustaw projekt i wygeneruj nowy klucz SSH wspierany sprzÄ™towo. **Klucz YubiKey (lub podobny klucz FIDO/U2F) jest obowiÄ…zkowy.**
        ```bash
        # Zaloguj siÄ™ na swoje konto Google (otworzy siÄ™ przeglÄ…darka)
        gcloud auth login
        ```
        
        ```bash
        # Ustaw docelowy identyfikator projektu GCP
        gcloud config set project <TWÃ“J_PROJECT_ID>
        ```
   
        ```bash
        # Wygeneruj nowy klucz SSH oparty na kluczu bezpieczeÅ„stwa
        ssh-keygen -t ed25519-sk -C "twoj_email@example.com"
        ```

5.  **Sklonuj Repozytorium i Zainstaluj ZaleÅ¼noÅ›ci Python**
    
    * JeÅ›li nie masz skonfigurowane - najpierw:
        ```bash
        sudo apt install gh
        gh auth login
        ```
    
    * Na koniec sklonuj repozytorium projektu i zainstaluj wymagane pakiety Python.
        ```bash
        git clone https://github.com/LukeStriderGM/BLOX-TAK-SERVER-GCP_Early_Stage_Access
        cd BLOX-TAK-SERVER-GCP_Early_Stage_Access
        pip install -r requirements.txt
        ```

### CzÄ™Å›Ä‡ B: Konfiguracja ReguÅ‚ Zapory Sieciowej GCP

Przed wdroÅ¼eniem maszyny wirtualnej musisz skonfigurowaÄ‡ zaporÄ™ sieciowÄ… (firewall) w sieci VPC swojego projektu GCP, aby zezwoliÄ‡ na niezbÄ™dny ruch.

1.  W konsoli Google Cloud przejdÅº do **SieÄ‡ VPC -> Zapora sieciowa**.
2.  Kliknij **UTWÃ“RZ REGUÅÄ˜ ZAPORY SIECIOWEJ** i utwÃ³rz dwie poniÅ¼sze reguÅ‚y:

#### ReguÅ‚a 1: ZezwÃ³l na DostÄ™p SSH z Adresu IP Administratora
* **Nazwa**: `ssh-22`
* **Kierunek ruchu**: `PrzychodzÄ…cy`
* **DziaÅ‚anie w przypadku dopasowania**: `Zezwalaj`
* **Cele**: `OkreÅ›lone tagi docelowe`
* **Tagi docelowe**: `tak-server`
* **Filtr ÅºrÃ³dÅ‚owy**: `Zakresy IPv4`
* **Å¹rÃ³dÅ‚owe zakresy IPv4**: `0.0.0.0/32` (WprowadÅº tutaj wÅ‚asny adres IP administratora)
* **ProtokoÅ‚y i porty**: `OkreÅ›lone protokoÅ‚y i porty` -> `tcp`: `22`

#### ReguÅ‚a 2: ZezwÃ³l na Ruch VPN WireGuard
* **Nazwa**: `wire-guard`
* **Kierunek ruchu**: `PrzychodzÄ…cy`
* **DziaÅ‚anie w przypadku dopasowania**: `Zezwalaj`
* **Cele**: `OkreÅ›lone tagi docelowe`
* **Tagi docelowe**: `tak-server`
* **Filtr ÅºrÃ³dÅ‚owy**: `Zakresy IPv4`
* **Å¹rÃ³dÅ‚owe zakresy IPv4**: `0.0.0.0/0`
* **ProtokoÅ‚y i porty**: `OkreÅ›lone protokoÅ‚y i porty` -> `udp`: `51820`

</details>

---

### ğŸ‡ºğŸ‡¸ Step 2: Deploy the GCP Virtual Machine

This script uses Terraform to create the VM, sets up a dedicated user, and adds your YubiKey public key for access.

```bash
# Initialize Terraform
terraform init

# After this step, enter your variables into config.yaml
cp config-example.yaml config.yaml
```

```bash
# Run the deployment script
python3 deploy_vm.py
```

The script will automatically create a config.yaml file with the new VM's details.

### Step 3: Configure VPN & Core Services

Install WireGuard on the Server:

```bash
python3 install_wireguard.py
```

Configure Your Admin VPN Peer:
This creates a local WireGuard configuration to connect your admin machine to the server's private network.

```bash
python3 configure_peer.py
```

After it completes, activate the tunnel:

```bash
# The path will be shown at the end of the script's output
sudo wg-quick up /etc/wireguard/admin_VM1/admin.conf
```
VM1, VM2, VM3 ...

You should now be able to connect to the server using its internal VPN IP (e.g., 10.200.0.1). 2, 3 ... 

<br>
Install Docker:
This script will connect to the server over the VPN to perform the installation.

```bash
python3 install_docker.py
```

### Step 4: Install TAK Server

Download TAK Server Files to the VM:
This script uses gdown on the remote server to download the necessary TAK Server zip file.

```bash
python3 gdown.py
```

Run the TAK Server Setup:
This is an interactive script that will guide you through the TAK server installation on the remote machine.

```bash
python3 setup.py
```

After the installation is complete, it will automatically copy the generated client certificates to your local machine.

### Step 5: Configure Clients
Add an Android WireGuard Client:
This will generate a QR code to easily add a new VPN profile to the WireGuard app on an Android device. By default, this tunnel is configured for split-tunnel traffic to conserve battery and allow normal phone operation. It can be manually changed to full-tunnel if the mission requires it.

```bash
python3 configure_peer_android.py
```

Your basic TAK server ecosystem is now operational!

<details>

<summary>ğŸ‡µğŸ‡±</summary>

### ğŸ‡µğŸ‡± Krok 2: WdrÃ³Å¼ MaszynÄ™ WirtualnÄ… GCP
Ten skrypt uÅ¼ywa Terraform do stworzenia maszyny wirtualnej, konfiguruje dedykowanego uÅ¼ytkownika i dodaje TwÃ³j publiczny klucz YubiKey w celu uzyskania dostÄ™pu.

```bash
# Zainicjuj Terraform
terraform init

# Po tym kroku wprowadÅº swoje zmienne do config.yaml

cp config-example.yaml config.yaml
```

```bash
# Uruchom skrypt wdroÅ¼enia
python3 deploy_vm.py
```

Skrypt automatycznie utworzy plik config.yaml ze szczegÃ³Å‚ami nowej maszyny wirtualnej.

### Krok 3: Skonfiguruj VPN i Podstawowe UsÅ‚ugi

Zainstaluj WireGuard na Serwerze:

```bash
python3 install_wireguard.py
```

Skonfiguruj SwÃ³j Administracyjny Peer VPN:
Tworzy to lokalnÄ… konfiguracjÄ™ WireGuard do poÅ‚Ä…czenia Twojej maszyny administracyjnej z prywatnÄ… sieciÄ… serwera.


```bash
python3 configure_peer.py
```

Po zakoÅ„czeniu, aktywuj tunel:

```bash
# ÅšcieÅ¼ka zostanie pokazana na koÅ„cu wyniku skryptu
sudo wg-quick up /etc/wireguard/admin_VM1/admin.conf
```

VM1, VM2, VM3 ...

PowinieneÅ› teraz mÃ³c poÅ‚Ä…czyÄ‡ siÄ™ z serwerem, uÅ¼ywajÄ…c jego wewnÄ™trznego adresu IP VPN (np. 10.200.0.1). 2, 3 ...

<br>
Zainstaluj Docker:
Ten skrypt poÅ‚Ä…czy siÄ™ z serwerem przez VPN, aby przeprowadziÄ‡ instalacjÄ™.

```bash
python3 install_docker.py
```

### Krok 4: Zainstaluj Serwer TAK

Pobierz Pliki Serwera TAK na MaszynÄ™ WirtualnÄ…:
Ten skrypt uÅ¼ywa gdown na zdalnym serwerze do pobrania wymaganego pliku zip Serwera TAK.

```bash
python3 gdown.py
```

Uruchom Instalator Serwera TAK:
To interaktywny skrypt, ktÃ³ry przeprowadzi CiÄ™ przez proces instalacji serwera TAK na zdalnej maszynie.

```bash
python3 setup.py
```

Po zakoÅ„czeniu instalacji, automatycznie skopiuje wygenerowane certyfikaty klienta na TwojÄ… lokalnÄ… maszynÄ™.

### Krok 5: Skonfiguruj KlientÃ³w

Dodaj Klienta WireGuard na Androida:
Wygeneruje to kod QR, aby Å‚atwo dodaÄ‡ nowy profil VPN do aplikacji WireGuard na urzÄ…dzeniu z Androidem. DomyÅ›lnie ten tunel jest skonfigurowany jako split-tunnel, aby oszczÄ™dzaÄ‡ bateriÄ™ i umoÅ¼liwiaÄ‡ normalne dziaÅ‚anie telefonu. MoÅ¼na go rÄ™cznie zmieniÄ‡ na full-tunnel, jeÅ›li misja tego wymaga.

```bash
python3 configure_peer_android.py
```

TwÃ³j podstawowy ekosystem serwera TAK jest teraz gotowy do dziaÅ‚ania!

</details>

---

## ğŸ‡ºğŸ‡¸ This repository provides the core infrastructure for the TAK ecosystem.

### Extended options enable automatic configuration of the MUMBLE-MURMUR server for VoIP communication using the VOICE plugin in the ATAK application.

There is also the option to run a "drone simulation" for testing with the UAS-TOOL plugin. If needed, I am also ready to undertake the first-time integration of physical drones compatible with this plugin: in the BLOX-TAK-SERVER-GCP.

### But the true power of the BLOX-TAK-SERVER-GCP ecosystem is realized in cooperation with the BLOX-TAK-SERVER-IUCP-GCP software package (IUCP - Individual User Connection Profile).

The IUCP project integrates directly with this GCP foundation and provides:

* **Automated Onboarding from Google Forms:** Automatically processes new user submissions from a Google Form or a CSV file.
* **Bulk Certificate Generation:** Generates and signs TAK .p12 client certificates for dozens of users simultaneously.
* **Automated Configuration Packaging:** Creates user-specific .zip packages containing their certificate, ATAK preferences (.pref), and other necessary files.
* **Automated Email Distribution:** Securely delivers the user package directly to their inbox using the Gmail API.
* **Advanced Maintenance:** Scripts for bulk certificate revocation and user lifecycle management.

The IUCP extension transforms an hour-long server configuration into a system where adding a new, fully prepared user takes less than a minute of automated work.

<br>
The basic version of this software, which works with physical TAK servers (locally and remotely), is available in the public repository:

https://github.com/LukeStriderGM/BLOX-TAK-SERVER-IUCP

The GCP version is reserved for the BLOX-TAK-SaaS project and will be publicly available only once I'm out of debt.

<details>

<summary>ğŸ‡µğŸ‡±</summary>

## ğŸ‡µğŸ‡± To repozytorium dostarcza podstawowÄ… infrastrukturÄ™ ekosystemu TAK.

### Opcje rozszerzone zapweniajÄ… automatycznÄ… konfiguracjÄ™ serwera MUMBLE-MURMUR dla komunikacji VoIP dla wtyczki VOICE w aplikacji ATAK.

Jest rÃ³wnieÅ¼ moÅ¼liwoÅ›Ä‡ uruchomienia "symulacji drona" do testÃ³w z wtyczkÄ… UAS-TOOL. W razie potrzeby, jestem gotowy podjÄ…Ä‡ siÄ™ rÃ³wnieÅ¼ pierwszy raz integracji dronÃ³w fizycznych - kompatybilnych z tÄ… wtyczkÄ…: w BLOX-TAK-SERVER-GCP.

### Lecz prawdziwa moc ekosystemu BLOX-TAK-SERVER-GCP jest realizowana we wspÃ³Å‚pracy z pakietem oprogramowania BLOX-TAK-SERVER-IPPU-GCP (IPPU - Indywidualny Profil PoÅ‚Ä…czeniowy UÅ¼ytkownika).

Projekt IPPU integruje siÄ™ bezpoÅ›rednio z tÄ… podstawÄ… GCP i zapewnia:

* **Automatyczny Onboarding z Formularzy Google:** Automatycznie przetwarza nowe zgÅ‚oszenia uÅ¼ytkownikÃ³w z Formularza Google lub pliku CSV.
* **Grupowe Generowanie CertyfikatÃ³w:** Generuje i podpisuje certyfikaty klienta TAK .p12 dla dziesiÄ…tek uÅ¼ytkownikÃ³w jednoczeÅ›nie.
* **Automatyczne Pakowanie Konfiguracji:** Tworzy specyficzne dla uÅ¼ytkownika pakiety .zip zawierajÄ…ce ich certyfikat, preferencje ATAK (.pref) i inne niezbÄ™dne pliki.
* **Automatyczna Dystrybucja E-mail:** Bezpiecznie dostarcza pakiet uÅ¼ytkownika bezpoÅ›rednio na jego skrzynkÄ™ odbiorczÄ… za pomocÄ… API Gmaila.
* **Zaawansowana Konserwacja:** Skrypty do masowego uniewaÅ¼niania certyfikatÃ³w i zarzÄ…dzania cyklem Å¼ycia uÅ¼ytkownika.

Rozszerzenie IPPU przeksztaÅ‚ca godzinnÄ… konfiguracjÄ™ serwera w system, w ktÃ³rym dodanie nowego, w peÅ‚ni przygotowanego uÅ¼ytkownika zajmuje mniej niÅ¼ minutÄ™ zautomatyzowanej pracy.

<br>
Podstawowa wersja tego oprogramowania ktÃ³ra wspÃ³Å‚pracuje z fizycznymi serwerami TAK (lokalnie i zdalnie), znajduje siÄ™ w publicznym repozytorium:

https://github.com/LukeStriderGM/BLOX-TAK-SERVER-IUCP

Wersja dla GCP zarezerwowana jest dla projektu BLOX-TAK-SaaS i zostanie udostÄ™pniona publicznie dopiero - gdy wydostanÄ™ siÄ™ z dÅ‚ugÃ³w. 

</details>

---

## ğŸ‡ºğŸ‡¸ Maintenance & Teardown

```bash 
python3 cleanup_vm.py
```
Runs a script on the VM to remove all TAK-related components.

<br>

```bash 
python3 destroy_vm.py
```
IRREVERSIBLE. Uses Terraform to completely destroy the virtual machine and its associated workspace. Use with caution.

<details>

<summary>ğŸ‡µğŸ‡±</summary>

## Konserwacja i DemontaÅ¼

```bash 
python3 cleanup_vm.py
```
Uruchamia na maszynie wirtualnej skrypt usuwajÄ…cy wszystkie komponenty zwiÄ…zane z TAK.

<br>

```bash 
python3 destroy_vm.py
```

NIEODWRACALNE. UÅ¼ywa Terraform do caÅ‚kowitego zniszczenia maszyny wirtualnej i jej powiÄ…zanego obszaru roboczego. UÅ¼ywaj z ostroÅ¼noÅ›ciÄ….

</details>

---

## ğŸ‡ºğŸ‡¸ License
This project is licensed under the MIT License. See the LICENSE file for details.

<details>

<summary>ğŸ‡µğŸ‡±</summary>

## Licencja

Ten projekt jest objÄ™ty licencjÄ… MIT. Zobacz plik LICENSE, aby uzyskaÄ‡ szczegÃ³Å‚owe informacje.

TÅ‚umaczenie [PL]:

Licencja MIT

Prawa autorskie (c) 2025 Åukasz "LukeStriderGM" Andruszkiewicz

Niniejszym udziela siÄ™ bezpÅ‚atnej zgody kaÅ¼dej osobie wchodzÄ…cej w posiadanie kopii tego oprogramowania i powiÄ…zanych z nim plikÃ³w dokumentacji (dalej â€Oprogramowanieâ€), na obchodzenie siÄ™ z Oprogramowaniem bez ograniczeÅ„, wÅ‚Ä…czajÄ…c w to bez ograniczeÅ„ prawa do uÅ¼ywania, kopiowania, modyfikowania, Å‚Ä…czenia, publikowania, dystrybucji, sublicencjonowania i/lub sprzedaÅ¼y kopii Oprogramowania, oraz na zezwolenie osobom, ktÃ³rym Oprogramowanie jest dostarczane, aby to czyniÅ‚y, pod nastÄ™pujÄ…cymi warunkami:

PowyÅ¼sza nota o prawach autorskich i ta nota o pozwoleniu muszÄ… byÄ‡ doÅ‚Ä…czone do wszystkich kopii lub istotnych czÄ™Å›ci Oprogramowania.

OPROGRAMOWANIE JEST DOSTARCZANE "TAKIM, JAKIE JEST", BEZ JAKIEJKOLWIEK GWARANCJI, WYRAÅ¹NEJ LUB DOROZUMIANEJ, WÅÄ„CZAJÄ„C W TO, ALE NIE OGRANICZAJÄ„C SIÄ˜ DO, GWARANCJI PRZYDATNOÅšCI HANDLOWEJ, PRZYDATNOÅšCI DO OKREÅšLONEGO CELU ORAZ NIENARUSZALNOÅšCI PRAW. W Å»ADNYM WYPADKU AUTORZY LUB POSIADACZE PRAW AUTORSKICH NIE BÄ˜DÄ„ ODPOWIEDZIALNI ZA JAKIEKOLWIEK ROSZCZENIA, SZKODY LUB INNE ZOBOWIÄ„ZANIA, CZY TO W WYNIKU DZIAÅANIA UMOWY, DELIKTU CZY W INNY SPOSÃ“B, WYNIKAJÄ„CE Z, LUB W ZWIÄ„ZKU Z OPROGRAMOWANIEM LUB UÅ»YCIEM LUB INNYMI DZIAÅANIAMI W OPROGRAMOWANIU.

</details>

---

## ğŸ‡ºğŸ‡¸ Code of Conduct
This project and everyone participating in it is governed by the Contributor Covenant. See the CODE_OF_CONDUCT.md file for details.

<details>
<summary>ğŸ‡µğŸ‡±</summary>

Kodeks PostÄ™powania

Ten projekt i wszyscy w nim uczestniczÄ…cy podlegajÄ… Zasadom WspÃ³Å‚twÃ³rcy (Contributor Covenant). Zobacz plik CODE_OF_CONDUCT.md, aby uzyskaÄ‡ szczegÃ³Å‚owe informacje.

TÅ‚umaczenie [PL]:


## Kodeks PostÄ™powania - Contributor Covenant

### Nasza Obietnica

Jako czÅ‚onkinie i czÅ‚onkowie, wspÃ³Å‚twÃ³rczynie i wspÃ³Å‚twÃ³rcy oraz liderki i liderzy
zobowiÄ…zujemy siÄ™, Å¼e udziaÅ‚ w naszej spoÅ‚ecznoÅ›ci bÄ™dzie wolny od nÄ™kania dla
kaÅ¼dego, bez wzglÄ™du na wiek, budowÄ™ ciaÅ‚a, widocznÄ… lub niewidocznÄ…
niepeÅ‚nosprawnoÅ›Ä‡, pochodzenie etniczne, cechy pÅ‚ciowe, toÅ¼samoÅ›Ä‡ i ekspresjÄ™
pÅ‚ciowÄ…, poziom doÅ›wiadczenia, wyksztaÅ‚cenie, status spoÅ‚eczno-ekonomiczny,
narodowoÅ›Ä‡, wyglÄ…d, rasÄ™, religiÄ™ czy toÅ¼samoÅ›Ä‡ i orientacjÄ™ seksualnÄ….

ZobowiÄ…zujemy siÄ™ do dziaÅ‚ania i interakcji w sposÃ³b, ktÃ³ry przyczynia siÄ™ do
tworzenia otwartej, przyjaznej, zrÃ³Å¼nicowanej, inkluzywnej i zdrowej spoÅ‚ecznoÅ›ci.

### Nasze Standardy

PrzykÅ‚ady zachowaÅ„, ktÃ³re przyczyniajÄ… siÄ™ do tworzenia pozytywnego Å›rodowiska
dla naszej spoÅ‚ecznoÅ›ci, obejmujÄ…:

* Okazywanie empatii i Å¼yczliwoÅ›ci wobec innych osÃ³b
* Szacunek dla odmiennych opinii, punktÃ³w widzenia i doÅ›wiadczeÅ„
* Udzielanie i taktowne przyjmowanie konstruktywnej informacji zwrotnej
* Przyjmowanie odpowiedzialnoÅ›ci, przepraszanie osÃ³b dotkniÄ™tych naszymi
    bÅ‚Ä™dami i wyciÄ…ganie z nich wnioskÃ³w
* Skupianie siÄ™ nie tylko na tym, co najlepsze dla nas jako jednostek, ale dla
    caÅ‚ej spoÅ‚ecznoÅ›ci

PrzykÅ‚ady niedopuszczalnych zachowaÅ„ obejmujÄ…:

* UÅ¼ywanie jÄ™zyka lub obrazÃ³w o charakterze seksualnym oraz wszelkiego rodzaju
    zaloty lub umizgi o charakterze seksualnym
* Trolling, obraÅºliwe lub uwÅ‚aczajÄ…ce komentarze oraz ataki osobiste lub
    polityczne
* NÄ™kanie publiczne lub prywatne
* Publikowanie prywatnych informacji innych osÃ³b, takich jak adres fizyczny lub
    mailowy, bez ich wyraÅºnej zgody
* Inne zachowania, ktÃ³re moÅ¼na by uznaÄ‡ za niewÅ‚aÅ›ciwe w Å›rodowisku
    profesjonalnym

### ObowiÄ…zki Egzekwowania Zasad

Liderki i liderzy spoÅ‚ecznoÅ›ci sÄ… odpowiedzialni za wyjaÅ›nianie i egzekwowanie
naszych standardÃ³w oraz podejmÄ… odpowiednie i sprawiedliwe dziaÅ‚ania naprawcze w
odpowiedzi na kaÅ¼de zachowanie, ktÃ³re uznajÄ… za niestosowne, zagraÅ¼ajÄ…ce,
obraÅºliwe lub szkodliwe.

Liderki i liderzy spoÅ‚ecznoÅ›ci majÄ… prawo i obowiÄ…zek usuwaÄ‡, edytowaÄ‡ lub
odrzucaÄ‡ komentarze, commity, kod, edycje wiki, zgÅ‚oszenia i inne formy wkÅ‚adu,
ktÃ³re nie sÄ… zgodne z niniejszym Kodeksem PostÄ™powania, i w razie potrzeby
przedstawiÄ… powody swoich decyzji moderacyjnych.

### Zakres

Niniejszy Kodeks PostÄ™powania obowiÄ…zuje we wszystkich przestrzeniach
spoÅ‚ecznoÅ›ci, a takÅ¼e wtedy, gdy dana osoba oficjalnie reprezentuje spoÅ‚ecznoÅ›Ä‡ w
przestrzeni publicznej. PrzykÅ‚ady reprezentowania naszej spoÅ‚ecznoÅ›ci obejmujÄ…
uÅ¼ywanie oficjalnego adresu e-mail, publikowanie postÃ³w za poÅ›rednictwem
oficjalnego konta w mediach spoÅ‚ecznoÅ›ciowych lub wystÄ™powanie w charakterze
wyznaczonej przedstawicielki lub przedstawiciela na wydarzeniu online lub offline.

### Egzekwowanie Zasad

Przypadki obraÅºliwego, nÄ™kajÄ…cego lub w inny sposÃ³b niedopuszczalnego zachowania
mogÄ… byÄ‡ zgÅ‚aszane liderkom i liderom spoÅ‚ecznoÅ›ci odpowiedzialnym za egzekwowanie
zasad pod adresem **luke.strider.gm@gmail.com**.
Wszystkie skargi zostanÄ… rozpatrzone i zbadane niezwÅ‚ocznie i sprawiedliwie.

Wszystkie liderki i liderzy spoÅ‚ecznoÅ›ci sÄ… zobowiÄ…zani do poszanowania prywatnoÅ›ci i
bezpieczeÅ„stwa osoby zgÅ‚aszajÄ…cej incydent.

### Wytyczne DotyczÄ…ce Egzekwowania Zasad

Liderki i liderzy spoÅ‚ecznoÅ›ci bÄ™dÄ… postÄ™powaÄ‡ zgodnie z niniejszymi Wytycznymi
DotyczÄ…cymi WpÅ‚ywu na SpoÅ‚ecznoÅ›Ä‡ przy okreÅ›laniu konsekwencji za kaÅ¼de
dziaÅ‚anie, ktÃ³re uznajÄ… za naruszenie niniejszego Kodeksu PostÄ™powania:

### 1. Naprawienie

**WpÅ‚yw na SpoÅ‚ecznoÅ›Ä‡**: UÅ¼ywanie niestosownego jÄ™zyka lub inne zachowanie uznane
za nieprofesjonalne lub niemile widziane w spoÅ‚ecznoÅ›ci.

**Konsekwencja**: Prywatne, pisemne upomnienie od liderek lub liderÃ³w spoÅ‚ecznoÅ›ci,
wyjaÅ›niajÄ…ce naturÄ™ naruszenia i powÃ³d, dla ktÃ³rego zachowanie byÅ‚o
niestosowne. MoÅ¼e zostaÄ‡ zaÅ¼Ä…dane publiczne przeproszenie.

### 2. OstrzeÅ¼enie

**WpÅ‚yw na SpoÅ‚ecznoÅ›Ä‡**: Naruszenie w wyniku pojedynczego incydentu lub serii
dziaÅ‚aÅ„.

**Konsekwencja**: OstrzeÅ¼enie z konsekwencjami za dalsze zachowanie. Zakaz
interakcji z osobami zaangaÅ¼owanymi, w tym nieproszonych interakcji z osobami
egzekwujÄ…cymi Kodeks PostÄ™powania, przez okreÅ›lony czas. Obejmuje to unikanie
interakcji w przestrzeniach spoÅ‚ecznoÅ›ci, jak i na kanaÅ‚ach zewnÄ™trznych, takich
jak media spoÅ‚ecznoÅ›ciowe. Naruszenie tych warunkÃ³w moÅ¼e prowadziÄ‡ do
tymczasowego lub staÅ‚ego bana.

### 3. Tymczasowy Ban

**WpÅ‚yw na SpoÅ‚ecznoÅ›Ä‡**: PowaÅ¼ne naruszenie standardÃ³w spoÅ‚ecznoÅ›ci, w tym
utrzymujÄ…ce siÄ™ niestosowne zachowanie.

**Konsekwencja**: Tymczasowy zakaz jakichkolwiek interakcji lub publicznej
komunikacji ze spoÅ‚ecznoÅ›ciÄ… na okreÅ›lony czas. W tym okresie zabronione sÄ…
publiczne i prywatne interakcje z osobami zaangaÅ¼owanymi, w tym nieproszone
interakcje z osobami egzekwujÄ…cymi Kodeks PostÄ™powania. Naruszenie tych
warunkÃ³w moÅ¼e prowadziÄ‡ do staÅ‚ego bana.

### 4. StaÅ‚y Ban

**WpÅ‚yw na SpoÅ‚ecznoÅ›Ä‡**: Wykazywanie wzorca naruszania standardÃ³w spoÅ‚ecznoÅ›ci,
w tym utrzymujÄ…ce siÄ™ niestosowne zachowanie, nÄ™kanie danej osoby lub agresja
wobec lub oczernianie grup osÃ³b.

**Konsekwencja**: StaÅ‚y zakaz jakichkolwiek publicznych interakcji w ramach
spoÅ‚ecznoÅ›ci.

---
Atrybucja

Niniejszy Kodeks PostÄ™powania jest adaptacjÄ… [Contributor Covenant][homepage],
wersja 2.1, dostÄ™pnej pod adresem
[https://www.contributor-covenant.org/version/2/1/code_of_conduct.html][v2.1].

[homepage]: https://www.contributor-covenant.org
[v2.1]: https://www.contributor-covenant.org/version/2/1/code_of_conduct.html

---

</details>
--- END FILE: README.md ---

--- START FILE: bundle_project.py ---
import os
import datetime

# =====================================================================================
# === CONFIGURATION ===
# === KONFIGURACJA ===
# =====================================================================================

# English: Set your project version here. It will be used in the output filename.
# Polski:  Ustaw tutaj wersjÄ™ swojego projektu. Zostanie ona uÅ¼yta w nazwie pliku wyjÅ›ciowego.
VERSION = "1.0.0.1"

# List of directories to absolutely exclude from the bundling process.
# Lista katalogÃ³w do bezwzglÄ™dnego wykluczenia z procesu pakowania.
DIRECTORIES_TO_EXCLUDE = {
    '.git',
    '.idea',
    '.venv',
    'venv',
    'env',
    '__pycache__',
    '.terraform',
    'terraform.tfstate.d',
    'gcp_tak_certs'
}

# List of specific files to exclude (e.g., configuration files with passwords).
# Lista konkretnych plikÃ³w do wykluczenia (np. pliki konfiguracyjne z hasÅ‚ami).
FILES_TO_EXCLUDE = {
    'token.json',
    'client_secret.json',
    'config.yaml',
    '.terraform.lock.hcl'
}

# List of file extensions to be ignored.
# Lista rozszerzeÅ„ plikÃ³w, ktÃ³re majÄ… byÄ‡ ignorowane.
EXTENSIONS_TO_EXCLUDE = {
    '.p12',
    '.zip',
    '.png',
    '.log',
    '.tmp'
}


# =====================================================================================
# === MAIN SCRIPT LOGIC ===
# === GÅÃ“WNA LOGIKA SKRYPTU ===
# =====================================================================================

def bundle_project_files():
    """
    Walks through the project directory, collects the content of all allowed
    files, and saves them into a single, large text file.

    Przechodzi przez katalog projektu, zbiera zawartoÅ›Ä‡ wszystkich dozwolonych
    plikÃ³w i zapisuje je w jednym, duÅ¼ym pliku tekstowym.
    """
    project_root = os.path.abspath(os.path.dirname(__file__))
    project_name = os.path.basename(project_root)

    # --- ZMIANA: Dynamiczne tworzenie nazwy pliku wyjÅ›ciowego ---
    # --- CHANGE: Dynamically create the output filename ---
    output_filename = f"{project_name}_{VERSION}_bundle.txt"

    print("Starting project bundling...")
    print("Rozpoczynam pakowanie projektu...")
    print(f"Root directory: {project_root}")
    print(f"Katalog gÅ‚Ã³wny: {project_root}")
    print(f"Output file: {output_filename}\n")
    print(f"Plik wyjÅ›ciowy: {output_filename}\n")

    try:
        with open(output_filename, 'w', encoding='utf-8') as bundle_file:
            bundle_file.write(f"Project Bundle: {project_name}\n")
            bundle_file.write(f"Version: {VERSION}\n")
            bundle_file.write(f"Generated on: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            bundle_file.write("=" * 40 + "\n\n")

            for root, dirs, files in os.walk(project_root, topdown=True):
                dirs[:] = [d for d in dirs if d not in DIRECTORIES_TO_EXCLUDE]

                for filename in sorted(files):
                    # --- ZMIANA: Sprawdzanie dynamicznej nazwy pliku wyjÅ›ciowego ---
                    # --- CHANGE: Check against the dynamic output filename ---
                    if filename == output_filename or filename in FILES_TO_EXCLUDE or any(filename.endswith(ext) for ext in EXTENSIONS_TO_EXCLUDE):
                        print(f"--- Skipping file: {filename}")
                        print(f"--- Pomijam plik: {filename}")
                        continue

                    file_path = os.path.join(root, filename)
                    relative_path = os.path.relpath(file_path, project_root)

                    print(f"+++ Adding file: {relative_path}")
                    print(f"+++ DodajÄ™ plik: {relative_path}")

                    bundle_file.write(f"--- START FILE: {relative_path} ---\n")
                    try:
                        with open(file_path, 'r', encoding='utf-8', errors='ignore') as source_file:
                            bundle_file.write(source_file.read())
                    except Exception as e:
                        bundle_file.write(f"\n[ERROR READING FILE / BÅÄ„D ODCZYTU PLIKU: {e}]\n")
                    bundle_file.write(f"\n--- END FILE: {relative_path} ---\n\n")

        print("\nProject bundling completed successfully!")
        print("Pakowanie projektu zakoÅ„czone pomyÅ›lnie!")
        print(f"The result has been saved to the file: {output_filename}")
        print(f"Wynik zostaÅ‚ zapisany w pliku: {output_filename}")

    except IOError as e:
        print(f"\nERROR: Could not write to the output file: {e}")
        print(f"BÅÄ„D: Nie moÅ¼na zapisaÄ‡ pliku wyjÅ›ciowego: {e}")
    except Exception as e:
        print(f"\nERROR: An unexpected error occurred: {e}")
        print(f"BÅÄ„D: WystÄ…piÅ‚ nieoczekiwany problem: {e}")


if __name__ == "__main__":
    bundle_project_files()
--- END FILE: bundle_project.py ---

--- START FILE: cleanup_vm.py ---
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# =====================================================================================
# === REMOTE CLEANUP SCRIPT (v4.0 - Centralized Variables) ===
# === SKRYPT ZDALNEGO CZYSZCZENIA INSTALACJI (v4.0 - Zmienne Scentralizowane) ===
# =====================================================================================

import os
import subprocess
import yaml
import sys

# --- Configuration ---
# --- Konfiguracja ---
CONFIG_FILE = 'config.yaml'


# =====================================================================================
# === HELPER FUNCTIONS (bez zmian) ===
# === FUNKCJE POMOCNICZE (no changes) ===
# =====================================================================================

def run_ssh_command(host_ip, user, command, interactive=False):
    """
    English: Runs a command on a remote machine over VPN.
    Polski:  Uruchamia polecenie na zdalnej maszynie przez VPN.
    """
    tty_flag = ['-t'] if interactive else []
    full_command = ['ssh', *tty_flag, '-o', 'StrictHostKeyChecking=no', '-o', 'ConnectTimeout=10', f'{user}@{host_ip}',
                    command]

    if interactive:
        print(f"\nğŸ”„ Connecting to '{host_ip}' to run the cleanup script...")
        print(f"ğŸ”„ ÅÄ…czenie z '{host_ip}' w celu uruchomienia skryptu czyszczÄ…cego...")
        print(f"   COMMAND: {command}")
        print("-" * 60)
        print(">>> Starting SSH session. All output below is from the server. <<<")
        print(">>> Rozpoczynanie sesji SSH. Wszystkie poniÅ¼sze dane pochodzÄ… z serwera. <<<")
        print("-" * 60)
    else:
        print(f"\nğŸ”„ Executing command on '{host_ip}': {command}")
        print(f"ğŸ”„ Wykonywanie polecenia na '{host_ip}': {command}")

    try:
        process = subprocess.run(full_command, check=False)
        return process.returncode
    except Exception as e:
        print(f"\nâŒ An unexpected error occurred during SSH: {e}")
        print(f"âŒ WystÄ…piÅ‚ nieoczekiwany bÅ‚Ä…d podczas SSH: {e}")
        return 1


def load_config():
    """
    English: Loads the main configuration file.
    Polski:  Wczytuje gÅ‚Ã³wny plik konfiguracyjny.
    """
    if not os.path.exists(CONFIG_FILE):
        print(f"âŒ Configuration file '{CONFIG_FILE}' not found.")
        print(f"âŒ Plik konfiguracyjny '{CONFIG_FILE}' nie zostaÅ‚ znaleziony.")
        return None
    try:
        with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
            return yaml.safe_load(f)
    except (IOError, yaml.YAMLError) as e:
        print(f"âŒ Error loading configuration file '{CONFIG_FILE}': {e}")
        print(f"âŒ BÅ‚Ä…d Å‚adowania pliku konfiguracyjnego '{CONFIG_FILE}': {e}")
        return None


# =====================================================================================
# === MAIN SCRIPT LOGIC (ZMODYFIKOWANA / MODIFIED) ===
# =====================================================================================

def main():
    os.system("clear || cls")
    print("=" * 60)
    print("=== TAK SERVER VM CLEANUP SCRIPT (v4.0) ===")
    print("=== SKRYPT CZYSZCZENIA INSTALACJI TAK SERVER NA VM (v4.0) ===")
    print("=" * 60)

    config = load_config()
    if not config: return

    # --- Krok 1: Wczytaj ustawienia ---
    global_settings = config.get('GLOBAL_SETTINGS', {})
    vm_settings = global_settings.get('vm', {})
    if not vm_settings:
        print("\nâŒ ERROR: Section 'GLOBAL_SETTINGS.vm' not found in config.yaml.")
        print("âŒ BÅÄ„D: Sekcja 'GLOBAL_SETTINGS.vm' nie zostaÅ‚a znaleziona w pliku config.yaml.")
        return

    ADMIN_USER = vm_settings.get('admin_user', 'blox_tak_server_admin')

    # --- Krok 2: Wybierz serwer do wyczyszczenia ---
    servers = {k: v for k, v in config.items() if isinstance(v, dict) and 'name' in v}
    if not servers:
        print(f"\nâŒ No server configurations found in '{CONFIG_FILE}'.")
        print(f"âŒ Nie znaleziono konfiguracji serwerÃ³w w pliku '{CONFIG_FILE}'.")
        return

    print("\nAvailable servers to clean up:")
    print("DostÄ™pne serwery do wyczyszczenia:")
    for key, data in servers.items():
        print(f"  - {key}: {data['name']}")

    server_key = input("\nSelect the server to clean up:\nWybierz serwer, ktÃ³ry chcesz wyczyÅ›ciÄ‡:\n> ").strip().upper()
    if server_key not in servers:
        print(f"\nâŒ ERROR: Key '{server_key}' not found.")
        print(f"âŒ BÅÄ„D: Klucz '{server_key}' nie zostaÅ‚ znaleziony.")
        return

    server_data = servers[server_key]
    ssh_host_ip = server_data.get('internal_ip')

    if not ssh_host_ip:
        print(f"\nâŒ ERROR: Missing 'internal_ip' for VM '{server_key}'. A VPN connection is required.")
        print(f"âŒ BÅÄ„D: Brak 'internal_ip' dla maszyny '{server_key}'. Wymagane jest poÅ‚Ä…czenie VPN.")
        return

    # --- Krok 3: Uruchom polecenie czyszczÄ…ce ---
    cleanup_command = f"sudo bash -c 'cd /home/{ADMIN_USER}/tak-server && chmod +x scripts/cleanup.sh && ./scripts/cleanup.sh'"
    return_code = run_ssh_command(ssh_host_ip, ADMIN_USER, cleanup_command, interactive=True)

    print("\n" + "=" * 60)
    if return_code == 0:
        print("âœ¨ CLEANUP FINISHED SUCCESSFULLY!")
        print("âœ¨ CZYSZCZENIE ZAKOÅƒCZONE POMYÅšLNIE!")
    else:
        print("âŒ CLEANUP FINISHED WITH AN ERROR.")
        print("âŒ CZYSZCZENIE ZAKOÅƒCZONE BÅÄ˜DEM.")
        print("âŒ Check the messages above to diagnose the issue.")
        print("âŒ SprawdÅº powyÅ¼sze komunikaty, aby zdiagnozowaÄ‡ problem.")
    print("=" * 60)


if __name__ == '__main__':
    main()
--- END FILE: cleanup_vm.py ---

--- START FILE: config-example.yaml ---
# ======================================================
# === Main Configuration File for BLOX-TAK-SERVER-GCP ===
# === GÅ‚Ã³wny Plik Konfiguracyjny BLOX-TAK-SERVER-GCP ===
# ======================================================
#
# English: Fill in the variables below before running the scripts.
#          Copy this file to config.yaml and edit it.
#          The config.yaml file is ignored by Git.
#
# Polski:  UzupeÅ‚nij poniÅ¼sze zmienne przed uruchomieniem skryptÃ³w.
#          Skopiuj ten plik do config.yaml i edytuj go.
#          Plik config.yaml jest ignorowany przez Git.

# --- Local Settings ---
# --- Ustawienia Lokalne ---
LOCAL_CONFIG:
  # English: Sudo password for your local admin machine.
  # Polski:  HasÅ‚o do sudo na Twojej lokalnej maszynie administracyjnej.
  password: 'YOUR_SUDO_PASSWORD'

# --- Global Project Settings ---
# --- Ustawienia Globalne Projektu ---
# English: Used by all scripts to configure the environment in GCP and on the server.
# Polski:  UÅ¼ywane przez wszystkie skrypty do konfiguracji Å›rodowiska w GCP i na serwerze.
GLOBAL_SETTINGS:
  # English: Google Cloud project settings.
  # Polski:  Ustawienia projektu Google Cloud.
  gcp:
    project_id: 'your-gcp-project-id'
    region: 'europe-central2'
    zone: 'europe-central2-c'

  # English: Virtual machine specification.
  # Polski:  Specyfikacja maszyny wirtualnej.
  vm:
    machine_type: 'e2-standard-4'
    disk_image: 'projects/ubuntu-os-cloud/global/images/ubuntu-2204-jammy-v20250701'
    disk_size_gb: 40
    disk_type: 'pd-ssd'
    admin_user: 'blox_tak_server_admin'

  # English: WireGuard VPN network settings.
  # Polski:  Ustawienia sieci WireGuard VPN.
  vpn:
    server_subnet: '10.200.0.0/24'
    admin_ip: '10.100.0.1/32'
    # English: The last octet will be added automatically for new clients.
    # Polski:  Ostatni oktet bÄ™dzie dodawany automatycznie dla nowych klientÃ³w.
    eud_subnet_prefix: '10.0.0.'


  # English: TAK Server file IDs on Google Drive.
  # Polski:  Identyfikatory plikÃ³w TAK Server na Google Drive.

  # English: NOTE - these are the repository ID to the files on my Google Drive
  # Polski: UWAGA - to sÄ… ID repozytoriÃ³w do plikÃ³w na moim Dysku Google
  tak_server_files:
    # English: ID to the takserver-docker*.zip file.
    # Polski:  ID do pliku takserver-docker*.zip.
    zip_id: '1FSP2TzSmSHTpkw3yUPsct9xolY_pamjB'
    zip_filename: 'takserver-docker-5.4-RELEASE-19.zip'
    # English: ID to the great repo of CloudRF install scripts:
    # https://github.com/Cloud-RF/tak-server
    # - modified for the project's needs with the original MIT license:

    # Polski:  ID do wspaniaÅ‚ego repo skryptÃ³w instalacyjnych od CloudRF:
    # https://github.com/Cloud-RF/tak-server
    # - zmodyfikowanego na potrzby projektu z pierwotnÄ… licencjÄ… MIT:

    folder_id: '1MdlXYJ-H9PSMJ6o89IfhXsSJcbMaXMxc'

# --- Machine Configuration ---
# --- Konfiguracja Maszyn ---
# English: This section will be automatically populated by the deploy_vm.py script.
#          Do not edit it manually.
# Polski:  Ta sekcja bÄ™dzie automatycznie uzupeÅ‚niana przez skrypt deploy_vm.py.
#          Nie edytuj jej rÄ™cznie.
VM0:
  name: example-vm-name-to-be-replaced
  # line 122 deploy_vm.py: password = f'*P@ssw0rd_*_{timestamp_for_password}*'
  password: '*****'
  ssh_public_key: 'ssh-ed25519-sk AAAA...'
  external_ip: '34.x.x.x'
  internal_ip: '10.x.x.x'
  last_eud_octet: 1
--- END FILE: config-example.yaml ---

--- START FILE: configure_peer.py ---
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# =====================================================================================
# === ADMIN WIREGUARD PEER CONFIGURATION SCRIPT (v5.0 - Centralized Variables) ===
# === SKRYPT KONFIGURACJI PEERA WIREGUARD DLA ADMINA (v5.0 - Zmienne Scentralizowane) ===
# =====================================================================================

import os
import subprocess
import yaml
import sys
import shlex

# --- Configuration ---
# --- Konfiguracja ---
CONFIG_FILE = 'config.yaml'


# =====================================================================================
# === HELPER FUNCTIONS (bez zmian) ===
# === FUNKCJE POMOCNICZE (no changes) ===
# =====================================================================================

def run_command_local(command, password=None, capture_output=False, shell=False):
    """
    English: Executes a command on the local machine.
    Polski:  Wykonuje polecenie na lokalnej maszynie.
    """
    try:
        if shell and isinstance(command, list):
            command = shlex.join(command)
        process = subprocess.Popen(
            command,
            stdin=subprocess.PIPE if password else None,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            encoding='utf-8',
            shell=shell
        )
        stdout, stderr = process.communicate(input=password + '\n' if password else None)
        if stdout:
            if capture_output:
                return process.returncode, stdout.strip().split('\n')
            else:
                print(stdout.strip())
        if stderr and not capture_output:
            print(f"DEBUG/STDERR: {stderr.strip()}", file=sys.stderr)
        return process.returncode, [] if capture_output else None
    except Exception as e:
        print(f"âŒ An unexpected error occurred: {e}")
        print(f"âŒ WystÄ…piÅ‚ nieoczekiwany bÅ‚Ä…d: {e}")
        return 1, [] if capture_output else None


def run_command_remote(vm_name, remote_command_str, user, project_id, zone, capture_output=False):
    """
    English: Executes a command on a remote GCloud VM via SSH.
    Polski:  Wykonuje polecenie na zdalnej maszynie GCloud przez SSH.
    """
    gcloud_ssh_command = [
        'gcloud', 'compute', 'ssh',
        f'{user}@{vm_name}',
        f'--project={project_id}',
        f'--zone={zone}',
        '--quiet',
        '--',
        remote_command_str
    ]
    try:
        process = subprocess.Popen(
            gcloud_ssh_command,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            encoding='utf-8',
            shell=False
        )
        stdout, stderr = process.communicate()
        if stdout:
            if capture_output:
                return process.returncode, stdout.strip().split('\n')
            else:
                print(stdout.strip())
        if stderr and not capture_output:
            print(f"DEBUG/STDERR (Remote): {stderr.strip()}", file=sys.stderr)
        return process.returncode, [] if capture_output else None
    except Exception as e:
        print(f"âŒ An unexpected error occurred during remote command execution: {e}")
        print(f"âŒ WystÄ…piÅ‚ nieoczekiwany bÅ‚Ä…d podczas wykonywania zdalnego polecenia: {e}")
        return 1, [] if capture_output else None


def load_config():
    """
    English: Loads the YAML configuration file.
    Polski:  Wczytuje plik konfiguracyjny YAML.
    """
    if not os.path.exists(CONFIG_FILE):
        print(f"âŒ Config file '{CONFIG_FILE}' not found.")
        print(f"âŒ Plik konfiguracyjny '{CONFIG_FILE}' nie zostaÅ‚ znaleziony.")
        return None
    try:
        with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
            return yaml.safe_load(f)
    except (IOError, yaml.YAMLError) as e:
        print(f"âŒ Error loading config file '{CONFIG_FILE}': {e}")
        print(f"âŒ BÅ‚Ä…d Å‚adowania pliku konfiguracyjnego '{CONFIG_FILE}': {e}")
        return None


def save_config(config_data):
    """
    English: Saves the configuration data back to the YAML file.
    Polski:  Zapisuje dane konfiguracyjne z powrotem do pliku YAML.
    """
    try:
        with open(CONFIG_FILE, 'w', encoding='utf-8') as f:
            yaml.dump(config_data, f, default_flow_style=False, sort_keys=False)
        print(f"âœ… Configuration saved to '{CONFIG_FILE}'.")
        print(f"âœ… Konfiguracja zapisana w '{CONFIG_FILE}'.")
    except (IOError, yaml.YAMLError) as e:
        print(f"âŒ Error saving config file '{CONFIG_FILE}': {e}")
        print(f"âŒ BÅ‚Ä…d zapisu pliku konfiguracyjnego '{CONFIG_FILE}': {e}")


# =====================================================================================
# === MAIN SCRIPT LOGIC (ZMODYFIKOWANA / MODIFIED) ===
# =====================================================================================

def main():
    os.system("clear || cls")
    print("=" * 60)
    print("=== ADMIN WIREGUARD PEER WIZARD (v5.0) ===")
    print("=== KREATOR PEERA WIREGUARD DLA ADMINA (v5.0) ===")
    print("=" * 60)

    config = load_config()
    if not config: return

    # --- Krok 1: Wczytaj ustawienia ---
    local_config = config.get('LOCAL_CONFIG', {})
    global_settings = config.get('GLOBAL_SETTINGS', {})

    local_password = local_config.get('password')

    gcp_settings = global_settings.get('gcp', {})
    vm_settings = global_settings.get('vm', {})
    vpn_settings = global_settings.get('vpn', {})

    if not all([local_password, gcp_settings, vm_settings, vpn_settings]):
        print("\nâŒ ERROR: 'LOCAL_CONFIG' or 'GLOBAL_SETTINGS' sections in config.yaml are incomplete.")
        print("âŒ BÅÄ„D: Sekcje 'LOCAL_CONFIG' lub 'GLOBAL_SETTINGS' w config.yaml sÄ… niekompletne.")
        return

    ADMIN_USER = vm_settings.get('admin_user', 'blox_tak_server_admin')
    PROJECT_ID = gcp_settings.get('project_id')
    ZONE = gcp_settings.get('zone')
    ADMIN_VPN_IP = vpn_settings.get('admin_ip')

    # --- Krok 2: Wybierz maszynÄ™ docelowÄ… ---
    vms = {k: v for k, v in config.items() if isinstance(v, dict) and 'name' in v}
    if not vms:
        print(f"\nâŒ No server machine configurations found in '{CONFIG_FILE}'.")
        print(f"âŒ Nie znaleziono konfiguracji maszyn serwerowych w pliku '{CONFIG_FILE}'.")
        return

    print("\nAvailable server machines to configure peer:")
    print("DostÄ™pne maszyny serwerowe do konfiguracji peera:")
    for key, data in vms.items():
        print(f"  - {key}: {data['name']}")

    vm_key = input(
        "\nEnter the key of the machine to configure the admin peer on:\nPodaj klucz maszyny, na ktÃ³rej skonfigurowaÄ‡ peera admina:\n> ").strip().upper()
    if vm_key not in vms:
        print(f"\nâŒ ERROR: Key '{vm_key}' not found.")
        print(f"âŒ BÅÄ„D: Klucz '{vm_key}' nie zostaÅ‚ znaleziony.")
        return

    vm_name = vms[vm_key]['name']

    # --- Krok 3: Pobierz informacje o serwerze (IP, klucz publiczny) ---
    print(f"\nğŸ”„ Retrieving server information for '{vm_name}'...")
    print(f"ğŸ”„ Pobieranie informacji o serwerze dla '{vm_name}'...")

    code, server_public_key_lines = run_command_remote(vm_name, "sudo cat /etc/wireguard/server_public.key", ADMIN_USER,
                                                       PROJECT_ID, ZONE, capture_output=True)
    if code != 0 or not server_public_key_lines:
        print(f"âŒ ERROR: Failed to retrieve server public key from '{vm_name}'.")
        print(f"âŒ BÅÄ„D: Nie udaÅ‚o siÄ™ pobraÄ‡ klucza publicznego serwera z '{vm_name}'.")
        return
    server_public_key = server_public_key_lines[0]
    print(f"âœ… Server Public Key / Klucz publiczny serwera: {server_public_key}")

    get_ext_ip_cmd = ['gcloud', 'compute', 'instances', 'describe', vm_name, f'--project={PROJECT_ID}',
                      f'--zone={ZONE}', '--format=get(networkInterfaces[0].accessConfigs[0].natIP)']
    code, server_external_ip_lines = run_command_local(get_ext_ip_cmd, capture_output=True)
    if code != 0 or not server_external_ip_lines:
        print(f"âŒ ERROR: Could not fetch server's external IP for '{vm_name}'.")
        print(f"âŒ BÅÄ„D: Nie moÅ¼na byÅ‚o pobraÄ‡ zewnÄ™trznego adresu IP serwera dla '{vm_name}'.")
        return
    server_external_ip = server_external_ip_lines[0]
    print(f"âœ… Server External IP / ZewnÄ™trzny adres IP serwera: {server_external_ip}")

    get_int_ip_cmd = ['gcloud', 'compute', 'instances', 'describe', vm_name, f'--project={PROJECT_ID}',
                      f'--zone={ZONE}', '--format=get(networkInterfaces[0].networkIP)']
    code, server_internal_ip_lines = run_command_local(get_int_ip_cmd, capture_output=True)
    if code != 0 or not server_internal_ip_lines:
        print(f"âŒ ERROR: Could not fetch server's internal IP for '{vm_name}'.")
        print(f"âŒ BÅÄ„D: Nie moÅ¼na byÅ‚o pobraÄ‡ wewnÄ™trznego adresu IP serwera dla '{vm_name}'.")
        return
    server_internal_ip = server_internal_ip_lines[0]
    print(f"âœ… Server Internal IP / WewnÄ™trzny adres IP serwera: {server_internal_ip}")

    print(f"\nğŸ”„ Updating '{CONFIG_FILE}' with new IP addresses...")
    print(f"ğŸ”„ Aktualizacja '{CONFIG_FILE}' nowymi adresami IP...")
    config[vm_key]['external_ip'] = server_external_ip
    config[vm_key]['internal_ip'] = server_internal_ip
    save_config(config)

    # --- Krok 4: Generuj lokalne klucze admina ---
    base_client_path = '/etc/wireguard/'
    client_keys_path = os.path.join(base_client_path, f"admin_{vm_key}")
    client_conf_path = os.path.join(client_keys_path, "admin.conf")
    private_key_path = os.path.join(client_keys_path, 'admin_private.key')
    public_key_path = os.path.join(client_keys_path, 'admin_public.key')

    print(f"\nğŸ”„ Generating WireGuard admin keys in '{client_keys_path}'...")
    print(f"ğŸ”„ Generowanie kluczy admina WireGuard w '{client_keys_path}'...")
    run_command_local(f"sudo -S mkdir -p {client_keys_path}", password=local_password, shell=True)
    run_command_local(f"sudo -S wg genkey | sudo -S tee {private_key_path} > /dev/null", password=local_password,
                      shell=True)
    run_command_local(f"sudo -S cat {private_key_path} | sudo -S wg pubkey | sudo -S tee {public_key_path} > /dev/null",
                      password=local_password, shell=True)

    code, client_public_key_lines = run_command_local(f"sudo -S cat {public_key_path}", password=local_password,
                                                      capture_output=True, shell=True)
    if code != 0 or not client_public_key_lines: return
    client_public_key = client_public_key_lines[0]
    print(f"âœ… Admin Public Key / Klucz publiczny admina: {client_public_key}")

    code, client_private_key_lines = run_command_local(f"sudo -S cat {private_key_path}", password=local_password,
                                                       capture_output=True, shell=True)
    if code != 0 or not client_private_key_lines: return
    client_private_key = client_private_key_lines[0]

    # --- Krok 5: Dodaj peera admina do serwera WireGuard ---
    print(f"\nğŸ”„ Adding admin peer to WireGuard configuration on '{vm_name}'...")
    print(f"ğŸ”„ Dodawanie peera admina do konfiguracji WireGuard na '{vm_name}'...")

    admin_vpn_ip_no_mask = ADMIN_VPN_IP.split('/')[0]
    peer_config_content = f"\\n# Peer: Admin for {vm_key}\\n[Peer]\\nPublicKey = {client_public_key}\\nAllowedIPs = {admin_vpn_ip_no_mask}/32\\n"
    remote_command = f"sudo printf '{peer_config_content}' | sudo tee -a /etc/wireguard/wg0.conf"
    code, _ = run_command_remote(vm_name, remote_command, ADMIN_USER, PROJECT_ID, ZONE)
    if code != 0: return

    print(f"âœ… Admin peer ({admin_vpn_ip_no_mask}) added to server's WireGuard configuration.")
    print(f"âœ… Peer admina ({admin_vpn_ip_no_mask}) dodany do konfiguracji serwera.")

    # --- Krok 6: Zrestartuj WireGuard na serwerze i utwÃ³rz lokalnÄ… konfiguracjÄ™ ---
    print(f"\nğŸ”„ Restarting WireGuard service on '{vm_name}'...")
    print(f"ğŸ”„ Ponowne uruchamianie usÅ‚ugi WireGuard na '{vm_name}'...")
    code, _ = run_command_remote(vm_name, "sudo systemctl restart wg-quick@wg0", ADMIN_USER, PROJECT_ID, ZONE)
    if code != 0: return
    print(f"âœ… WireGuard service restarted on '{vm_name}'.")
    print(f"âœ… UsÅ‚uga WireGuard pomyÅ›lnie ponownie uruchomiona na '{vm_name}'.")

    print(f"\nğŸ”„ Creating WireGuard admin configuration file at '{client_conf_path}'...")
    print(f"ğŸ”„ Tworzenie pliku konfiguracyjnego admina WireGuard w '{client_conf_path}'...")

    allowed_ips_for_peer = "0.0.0.0/0, ::/0"  # PeÅ‚ny tunel dla admina
    client_conf_content = f"""
[Interface]
# Admin Client for {vm_key}
PrivateKey = {client_private_key}
Address = {ADMIN_VPN_IP}
ListenPort = 51820
DNS = 8.8.8.8

[Peer]
# Server: {vm_name}
PublicKey = {server_public_key}
Endpoint = {server_external_ip}:51820
AllowedIPs = {allowed_ips_for_peer}
PersistentKeepalive = 25
""".strip()

    write_client_conf_cmd = f"echo '{client_conf_content}' | sudo -S tee {client_conf_path} > /dev/null"
    code, _ = run_command_local(write_client_conf_cmd, password=local_password, shell=True)
    if code != 0: return

    print(f"âœ… WireGuard admin configuration saved to '{client_conf_path}'.")
    print(f"âœ… Konfiguracja admina WireGuard zapisana w '{client_conf_path}'.")
    print("\nâœ¨ Admin peer configuration completed successfully! âœ¨")
    print("âœ¨ Konfiguracja peera admina zakoÅ„czona pomyÅ›lnie! âœ¨")
    print(f"\nTo enable the client, run / Aby wÅ‚Ä…czyÄ‡ klienta, uruchom:")
    print(f"  sudo wg-quick up {client_conf_path}")
    print(f"\nTo disable, run / Aby wyÅ‚Ä…czyÄ‡, uruchom:")
    print(f"  sudo wg-quick down {client_conf_path}")


if __name__ == '__main__':
    main()
--- END FILE: configure_peer.py ---

--- START FILE: configure_peer_android.py ---
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# =====================================================================================
# === ANDROID WIREGUARD PEER CONFIGURATION SCRIPT (v2.0 - Centralized Variables) ===
# === SKRYPT KONFIGURACJI PEERA WIREGUARD DLA ANDROID (v2.0 - Zmienne Scentralizowane) ===
# =====================================================================================

import os
import subprocess
import yaml
import sys
import json
import re

# --- Configuration ---
# --- Konfiguracja ---
CONFIG_FILE = 'config.yaml'
QR_CODE_PATH = './'


# =====================================================================================
# === HELPER FUNCTIONS (bez zmian) ===
# === FUNKCJE POMOCNICZE (no changes) ===
# =====================================================================================

def run_ssh_command(host_ip, user, command):
    """
    English: Executes a command on a remote machine using standard ssh.
    Polski:  Uruchamia polecenie na zdalnej maszynie uÅ¼ywajÄ…c standardowego ssh.
    """
    full_command = ['ssh', '-o', 'StrictHostKeyChecking=no', '-o', 'ConnectTimeout=10', f'{user}@{host_ip}', command]
    try:
        process = subprocess.Popen(full_command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True,
                                   encoding='utf-8')
        stdout, stderr = process.communicate()
        if process.returncode != 0:
            print(f"âŒ Error executing SSH command on {host_ip}: {stderr.strip()}")
            print(f"âŒ BÅ‚Ä…d wykonania polecenia SSH na {host_ip}: {stderr.strip()}")
        return process.returncode, stdout.strip()
    except Exception as e:
        print(f"âŒ An unexpected error occurred during SSH: {e}")
        print(f"âŒ WystÄ…piÅ‚ nieoczekiwany bÅ‚Ä…d podczas SSH: {e}")
        return 1, ""


def run_local_command(command, command_input=None):
    """
    English: Executes a local command, optionally with input data.
    Polski:  Uruchamia lokalne polecenie, opcjonalnie z danymi wejÅ›ciowymi.
    """
    try:
        process = subprocess.run(command, input=command_input, capture_output=True, text=True, encoding='utf-8',
                                 check=True)
        return process.returncode, process.stdout.strip()
    except subprocess.CalledProcessError as e:
        print(f"âŒ Error executing local command '{' '.join(e.cmd)}': {e.stderr.strip()}")
        print(f"âŒ BÅ‚Ä…d wykonania lokalnego polecenia '{' '.join(e.cmd)}': {e.stderr.strip()}")
        return e.returncode, ""
    except Exception as e:
        print(f"âŒ An unexpected error occurred: {e}")
        print(f"âŒ WystÄ…piÅ‚ nieoczekiwany bÅ‚Ä…d: {e}")
        return 1, ""


def load_config():
    """
    English: Loads the main configuration file.
    Polski:  Wczytuje gÅ‚Ã³wny plik konfiguracyjny.
    """
    if not os.path.exists(CONFIG_FILE):
        print(f"âŒ Config file '{CONFIG_FILE}' not found.")
        print(f"âŒ Plik konfiguracyjny '{CONFIG_FILE}' nie zostaÅ‚ znaleziony.")
        return None
    try:
        with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
            return yaml.safe_load(f) or {}
    except (IOError, yaml.YAMLError) as e:
        print(f"âŒ Error loading config file '{CONFIG_FILE}': {e}")
        print(f"âŒ BÅ‚Ä…d Å‚adowania pliku konfiguracyjnego '{CONFIG_FILE}': {e}")
        return None


def save_config(config_data):
    """
    English: Saves configuration data back to the YAML file.
    Polski:  Zapisuje dane konfiguracyjne z powrotem do pliku YAML.
    """
    try:
        with open(CONFIG_FILE, 'w', encoding='utf-8') as f:
            yaml.dump(config_data, f, default_flow_style=False, sort_keys=False)
    except (IOError, yaml.YAMLError) as e:
        print(f"âŒ Error saving config file '{CONFIG_FILE}': {e}")
        print(f"âŒ BÅ‚Ä…d zapisu pliku konfiguracyjnego '{CONFIG_FILE}': {e}")


# =====================================================================================
# === MAIN SCRIPT LOGIC (ZMODYFIKOWANA / MODIFIED) ===
# =====================================================================================

def main():
    os.system("clear || cls")
    print("=" * 60)
    print("=== ANDROID WIREGUARD PEER WIZARD (v2.0) ===")
    print("=== KREATOR PEERA WIREGUARD DLA ANDROID (v2.0) ===")
    print("=" * 60)

    config = load_config()
    if not config: return

    # --- Krok 1: Wczytaj ustawienia ---
    global_settings = config.get('GLOBAL_SETTINGS', {})
    gcp_settings = global_settings.get('gcp', {})
    vm_settings = global_settings.get('vm', {})
    vpn_settings = global_settings.get('vpn', {})

    if not all([gcp_settings, vm_settings, vpn_settings]):
        print("\nâŒ ERROR: 'GLOBAL_SETTINGS' section in config.yaml is incomplete.")
        print("âŒ BÅÄ„D: Sekcja 'GLOBAL_SETTINGS' w config.yaml jest niekompletna.")
        return

    ADMIN_USER = vm_settings.get('admin_user', 'blox_tak_server_admin')
    PROJECT_ID = gcp_settings.get('project_id')
    ZONE = gcp_settings.get('zone')
    EUD_SUBNET_PREFIX = vpn_settings.get('eud_subnet_prefix')
    SERVER_SUBNET_CIDR = vpn_settings.get('server_subnet')

    # --- Krok 2: Wybierz serwer ---
    servers = {k: v for k, v in config.items() if isinstance(v, dict) and 'name' in v}
    if not servers:
        print(f"\nâŒ No server machine configurations found in '{CONFIG_FILE}'.")
        print(f"âŒ Nie znaleziono konfiguracji maszyn serwerowych w pliku '{CONFIG_FILE}'.")
        return

    print("\nAvailable servers:")
    print("DostÄ™pne serwery:")
    for key, data in servers.items():
        print(f"  - {key}: {data['name']}")

    server_key = input("\nSelect server:\nWybierz serwer:\n> ").strip().upper()
    if server_key not in servers:
        print(f"\nâŒ ERROR: Key '{server_key}' not found.")
        print(f"âŒ BÅÄ„D: Klucz '{server_key}' nie zostaÅ‚ znaleziony.")
        return

    server_data = servers[server_key]
    instance_name = server_data.get('name')
    ssh_host_ip = server_data.get('internal_ip')
    server_external_ip = server_data.get('external_ip')

    if not all([instance_name, ssh_host_ip, server_external_ip]):
        print(
            f"\nâŒ ERROR: Configuration for '{server_key}' is incomplete. Missing 'name', 'internal_ip', or 'external_ip'.")
        print(f"   Run configure_peer.py first to fetch IP addresses.")
        print(
            f"âŒ BÅÄ„D: Konfiguracja dla '{server_key}' jest niekompletna. Brakuje 'name', 'internal_ip' lub 'external_ip'.")
        print(f"   Uruchom najpierw configure_peer.py, aby pobraÄ‡ adresy IP.")
        return

    # --- Krok 3: Przygotuj adresacjÄ™ IP ---
    vm_number_match = re.search(r'\d+', server_key)
    if not vm_number_match:
        print(f"âŒ ERROR: Cannot determine server number from key '{server_key}'.")
        print(f"âŒ BÅÄ„D: Nie moÅ¼na ustaliÄ‡ numeru serwera z klucza '{server_key}'.")
        return
    vm_number = vm_number_match.group(0)

    # Adres IP serwera w sieci VPN
    server_ip_prefix = '.'.join(SERVER_SUBNET_CIDR.split('.')[:3]) + '.'
    server_vpn_ip = f"{server_ip_prefix}{vm_number}"
    print(f"â„¹ï¸  Server address on the VPN network / Adres serwera w sieci VPN: {server_vpn_ip}")

    # Automatyczne generowanie nazwy i IP klienta
    last_octet = server_data.get('last_eud_octet', 0)
    new_octet = last_octet + 1
    client_name = f"EUD{new_octet}"
    client_vpn_ip = f"{EUD_SUBNET_PREFIX}{new_octet}"

    print(f"\nğŸš€ Configuring new peer '{client_name}' with IP {client_vpn_ip} for server '{instance_name}'...")
    print(f"ğŸš€ Konfiguracja nowego peera '{client_name}' z IP {client_vpn_ip} dla serwera '{instance_name}'...")

    # --- Krok 4: Konfiguracja na serwerze przez SSH ---
    print("\n--- Step 4: Retrieving server's public key ---")
    print("--- Krok 4: Pobieranie klucza publicznego serwera ---")
    code, server_public_key = run_ssh_command(ssh_host_ip, ADMIN_USER, "sudo cat /etc/wireguard/server_public.key")
    if code != 0 or not server_public_key:
        print("âŒ ERROR: Failed to retrieve server's public key.")
        print("âŒ BÅÄ„D: Nie udaÅ‚o siÄ™ pobraÄ‡ klucza publicznego serwera.")
        return
    print("âœ… Server public key retrieved / Klucz publiczny serwera pobrany.")

    print("\n--- Step 5: Generating client keys ---")
    print("--- Krok 5: Generowanie kluczy dla klienta ---")
    code, client_private_key = run_local_command(['wg', 'genkey'])
    if code != 0: return
    code, client_public_key = run_local_command(['wg', 'pubkey'], command_input=client_private_key)
    if code != 0: return
    print("âœ… Client keys generated / Klucze klienta wygenerowane.")

    print("\n--- Step 6: Adding peer to server config ---")
    print("--- Krok 6: Dodawanie peera do konfiguracji serwera ---")
    peer_config_content = f"printf '\\n# Peer: {client_name}\\n[Peer]\\nPublicKey = {client_public_key}\\nAllowedIPs = {client_vpn_ip}/32\\n'"
    remote_command = f"sudo bash -c \"{peer_config_content} >> /etc/wireguard/wg0.conf\""
    code, _ = run_ssh_command(ssh_host_ip, ADMIN_USER, remote_command)
    if code != 0: return
    print("âœ… Peer added to server configuration / Peer dodany do konfiguracji serwera.")

    print("\n--- Step 7: Restarting WireGuard service ---")
    print("--- Krok 7: Restartowanie usÅ‚ugi WireGuard ---")
    code, _ = run_ssh_command(ssh_host_ip, ADMIN_USER, "sudo systemctl restart wg-quick@wg0")
    if code != 0: return
    print("âœ… WireGuard service restarted / UsÅ‚uga WireGuard zrestartowana.")

    # --- Krok 8: Generowanie kodu QR ---
    print("\n--- Step 8: Creating QR code ---")
    print("--- Krok 8: Tworzenie kodu QR ---")

    # DomyÅ›lny tryb SPLIT TUNNEL (dostÄ™p tylko do serwera przez jego IP wewn. i wewn. VPN)
    allowed_ips = f"{ssh_host_ip}/32, {server_vpn_ip}/32"
    print(f"â„¹ï¸  Default client configuration with server-only access (AllowedIPs = {allowed_ips})")
    print(f"â„¹ï¸  DomyÅ›lna konfiguracja klienta z dostÄ™pem tylko do serwera (AllowedIPs = {allowed_ips})")

    client_conf_content = f"""[Interface]
PrivateKey = {client_private_key}
Address = {client_vpn_ip}/32
DNS = 8.8.8.8

[Peer]
PublicKey = {server_public_key}
Endpoint = {server_external_ip}:51820
AllowedIPs = {allowed_ips}
PersistentKeepalive = 25
"""
    qr_filename = os.path.join(QR_CODE_PATH, f"QR_{client_name}_{server_key}.png")
    code, _ = run_local_command(['qrencode', '-o', qr_filename, '-t', 'PNG'], command_input=client_conf_content)

    if code == 0:
        print("\n" + "=" * 60)
        print("âœ¨ FINISHED SUCCESSFULLY! / ZAKOÅƒCZONO POMYÅšLNIE! âœ¨")
        print(f"âœ… QR code saved to file / Kod QR zostaÅ‚ zapisany w pliku: {os.path.abspath(qr_filename)}")
        print("\nEnglish: Now open the WireGuard app on your phone, press '+' and select 'Scan from QR code'.")
        print(
            "Polski:  Teraz otwÃ³rz aplikacjÄ™ WireGuard na swoim telefonie, naciÅ›nij '+' i wybierz 'Skanuj z kodu QR'.")

        config[server_key]['last_eud_octet'] = new_octet
        save_config(config)
        print(f"\nâœ… Updated 'last_eud_octet' counter for '{server_key}' to {new_octet} in the config file.")
        print(f"âœ… Zaktualizowano licznik 'last_eud_octet' dla '{server_key}' na {new_octet} w pliku konfiguracyjnym.")
        print("=" * 60)
    else:
        print(
            "\nâŒ ERROR: Failed to generate QR code. Make sure 'qrencode' is installed (`sudo apt-get install qrencode`).")
        print(
            "âŒ BÅÄ„D: Nie udaÅ‚o siÄ™ wygenerowaÄ‡ kodu QR. Upewnij siÄ™, Å¼e program 'qrencode' jest zainstalowany (`sudo apt-get install qrencode`).")


if __name__ == '__main__':
    main()
--- END FILE: configure_peer_android.py ---

--- START FILE: deploy_vm.py ---
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# =====================================================================================
# === VM CREATION SCRIPT (v2.0 - Centralized Variables) ===
# === SKRYPT DO TWORZENIA MASZYN WIRTUALNYCH (v2.0 - Zmienne Scentralizowane) ===
# =====================================================================================

import os
import subprocess
import datetime
import yaml

# --- Configuration ---
# --- Konfiguracja ---
CONFIG_FILE = 'config.yaml'
SSH_KEY_FILE = os.path.expanduser('~/.ssh/id_ed25519_sk.pub')


# =====================================================================================
# === HELPER FUNCTIONS (bez zmian) ===
# === FUNKCJE POMOCNICZE (no changes) ===
# =====================================================================================

def run_command(command, capture_output=False):
    """
    English: Helper function to run system commands and print their output in real-time.
    Polski:  Funkcja pomocnicza do uruchamiania poleceÅ„ systemowych i drukowania ich wyjÅ›cia w czasie rzeczywistym.
    """
    try:
        process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True,
                                   encoding='utf-8')
        output_lines = []
        while True:
            output = process.stdout.readline()
            if output == '' and process.poll() is not None:
                break
            if output:
                line = output.strip()
                if capture_output:
                    output_lines.append(line)
                else:
                    print(line)
        return_code = process.poll()
        return return_code, output_lines
    except FileNotFoundError:
        print(f"âŒ ERROR: Command '{command[0]}' not found. Make sure it is installed.")
        print(f"âŒ BÅÄ„D: Polecenie '{command[0]}' nie zostaÅ‚o znalezione. Upewnij siÄ™, Å¼e jest zainstalowane.")
        return 1, []
    except Exception as e:
        print(f"âŒ An unexpected error occurred / WystÄ…piÅ‚ nieoczekiwany bÅ‚Ä…d: {e}")
        return 1, []


def load_config():
    """
    English: Loads the entire config.yaml file.
    Polski:  Wczytuje caÅ‚y plik config.yaml.
    """
    if not os.path.exists(CONFIG_FILE):
        print(f"âŒ Config file '{CONFIG_FILE}' not found.")
        print(f"âŒ Plik konfiguracyjny '{CONFIG_FILE}' nie zostaÅ‚ znaleziony.")
        return None
    try:
        with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
            return yaml.safe_load(f)
    except (IOError, yaml.YAMLError) as e:
        print(f"âŒ Error loading config file '{CONFIG_FILE}': {e}")
        print(f"âŒ BÅ‚Ä…d Å‚adowania pliku konfiguracyjnego '{CONFIG_FILE}': {e}")
        return None


def get_ssh_key():
    """
    English: Reads the SSH public key from the default file location.
    Polski:  Odczytuje publiczny klucz SSH z domyÅ›lnej lokalizacji pliku.
    """
    if not os.path.exists(SSH_KEY_FILE):
        print(f"âŒ ERROR: SSH key file not found at '{SSH_KEY_FILE}'")
        print(f"âŒ BÅÄ„D: Nie znaleziono pliku klucza SSH w '{SSH_KEY_FILE}'")
        return None
    try:
        with open(SSH_KEY_FILE, 'r', encoding='utf-8') as f:
            key_content = f.read().strip()
            print(f"âœ… Successfully loaded SSH key from '{SSH_KEY_FILE}'")
            print(f"âœ… PomyÅ›lnie zaÅ‚adowano klucz SSH z '{SSH_KEY_FILE}'")
            return key_content
    except IOError as e:
        print(f"âŒ ERROR: Could not read SSH key file: {e}")
        print(f"âŒ BÅÄ„D: Nie moÅ¼na odczytaÄ‡ pliku klucza SSH: {e}")
        return None


def get_next_vm_key():
    """
    English: Checks config.yaml and returns the next available key (e.g., VM3 if VM1 and VM2 exist).
    Polski:  Sprawdza config.yaml i zwraca nastÄ™pny dostÄ™pny klucz (np. VM3, jeÅ›li istnieje VM1 i VM2).
    """
    if not os.path.exists(CONFIG_FILE):
        return 'VM1'
    try:
        with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
            config_data = yaml.safe_load(f) or {}
        vm_keys = [k for k in config_data.keys() if isinstance(k, str) and k.startswith('VM')]
        if not vm_keys:
            return 'VM1'
        last_num = max([int(k.replace('VM', '')) for k in vm_keys])
        return f'VM{last_num + 1}'
    except (IOError, yaml.YAMLError, ValueError):
        return 'VM1'


def generate_credentials():
    """
    English: Generates a unique, GCP-compliant VM name and a password.
    Polski:  Generuje unikalnÄ…, zgodnÄ… z GCP nazwÄ™ maszyny wirtualnej oraz hasÅ‚o.
    """
    now = datetime.datetime.now()
    timestamp_for_name = now.strftime('%Y-%m-%d-%H-%M-%S')
    vm_name = f'blox-tak-server-vm-{timestamp_for_name}'
    timestamp_for_password = now.strftime('%Y-%m-%d_%H-%M-%S')
    password = f'*P@ssw0rd_*_{timestamp_for_password}*'
    return vm_name, password


def update_config_file(vm_key, vm_name, password, ssh_key):
    """
    English: Updates config.yaml, saving the name, password, and SSH key of the machine.
    Polski:  Aktualizuje config.yaml, zapisujÄ…c nazwÄ™, hasÅ‚o i klucz SSH maszyny.
    """
    config_data = {}
    if os.path.exists(CONFIG_FILE):
        with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
            config_data = yaml.safe_load(f) or {}
    config_data[vm_key] = {
        'name': vm_name,
        'password': password,
        'ssh_public_key': ssh_key
    }
    with open(CONFIG_FILE, 'w', encoding='utf-8') as f:
        yaml.dump(config_data, f, default_flow_style=False, sort_keys=False)

    print("\n" + "*" * 60)
    print(f"âœ… Configuration file '{CONFIG_FILE}' successfully updated with data for {vm_key}.")
    print(f"âœ… Plik konfiguracyjny '{CONFIG_FILE}' pomyÅ›lnie zaktualizowany danymi dla {vm_key}.")
    print("*" * 60)


# =====================================================================================
# === MAIN SCRIPT LOGIC (ZMODYFIKOWANA / MODIFIED) ===
# =====================================================================================

def main():
    """
    English: Main function of the VM creation script.
    Polski:  GÅ‚Ã³wna funkcja skryptu do tworzenia maszyn wirtualnych.
    """
    os.system("clear || cls")
    print("=" * 60)
    print("=== TERRAFORM VM CREATION WIZARD (v2.0) ===")
    print("=== KREATOR TWORZENIA MASZYN WIRTUALNYCH TERRAFORM (v2.0) ===")
    print("=" * 60)

    # --- Krok 1: Wczytaj konfiguracjÄ™ ---
    config = load_config()
    if not config:
        return

    # --- Krok 2: Wczytaj ustawienia globalne ---
    global_settings = config.get('GLOBAL_SETTINGS', {})
    if not global_settings:
        print("\nâŒ ERROR: Section 'GLOBAL_SETTINGS' not found in config.yaml.")
        print("âŒ BÅÄ„D: Sekcja 'GLOBAL_SETTINGS' nie zostaÅ‚a znaleziona w pliku config.yaml.")
        return

    gcp_settings = global_settings.get('gcp', {})
    vm_settings = global_settings.get('vm', {})

    # --- Krok 3: SprawdÅº inicjalizacjÄ™ Terraform ---
    if not os.path.isdir('.terraform'):
        print("\nâŒ ERROR: The '.terraform' directory does not exist.")
        print("   Please run 'terraform init' in this directory before running the script.")
        print("\nâŒ BÅÄ„D: Katalog '.terraform' nie istnieje.")
        print("   ProszÄ™ uruchomiÄ‡ 'terraform init' w tym katalogu przed uruchomieniem skryptu.")
        return

    # --- Krok 4: Wczytaj klucz SSH ---
    ssh_public_key = get_ssh_key()
    if not ssh_public_key:
        print("\nAborting due to missing SSH key.")
        print("Przerywam z powodu braku klucza SSH.")
        return

    # --- Krok 5: Wygeneruj dane dla nowej maszyny ---
    vm_key = get_next_vm_key()
    new_vm_name, new_password = generate_credentials()

    print(f"\nâ–¶ï¸  Next available key / NastÄ™pny dostÄ™pny klucz: {vm_key}")
    print(f"ğŸ–¥ï¸  Generated name for the new machine / Wygenerowana nazwa dla nowej maszyny: {new_vm_name}")

    # --- Krok 6: StwÃ³rz i przeÅ‚Ä…cz na nowy obszar roboczy Terraform ---
    print(f"\nğŸ”„ Creating and switching to workspace '{vm_key}'...")
    print(f"ğŸ”„ Tworzenie i przeÅ‚Ä…czanie na obszar roboczy '{vm_key}'...")
    run_command(['terraform', 'workspace', 'new', vm_key])
    run_command(['terraform', 'workspace', 'select', vm_key])

    # --- Krok 7: Wykonaj Terraform Apply z nowymi zmiennymi ---
    print("\n--- Running Terraform Apply ---")
    print("--- Uruchamianie Terraform Apply ---")
    apply_command = [
        'terraform', 'apply', '-auto-approve',
        # Zmienne podstawowe
        f'-var=instance_name={new_vm_name}',
        f'-var=root_password={new_password}',
        f'-var=ssh_public_key={ssh_public_key}',
        # Zmienne z GLOBAL_SETTINGS
        f'-var=gcp_project_id={gcp_settings.get("project_id")}',
        f'-var=gcp_region={gcp_settings.get("region")}',
        f'-var=gcp_zone={gcp_settings.get("zone")}',
        f'-var=vm_machine_type={vm_settings.get("machine_type")}',
        f'-var=vm_disk_image={vm_settings.get("disk_image")}',
        f'-var=vm_disk_size_gb={vm_settings.get("disk_size_gb")}',
        f'-var=vm_disk_type={vm_settings.get("disk_type")}',
        f'-var=vm_admin_user={vm_settings.get("admin_user")}',
    ]
    return_code, _ = run_command(apply_command)

    # --- Krok 8: Zaktualizuj plik konfiguracyjny po sukcesie ---
    if return_code == 0:
        print("\n--- âœ… Terraform Apply completed successfully ---")
        print("--- âœ… Terraform Apply zakoÅ„czone sukcesem ---")
        update_config_file(vm_key, new_vm_name, new_password, ssh_public_key)
    else:
        print(f"\n--- âŒ ERROR: Terraform Apply failed with exit code: {return_code} ---")
        print(f"--- âŒ BÅÄ„D: Terraform Apply zakoÅ„czone z kodem bÅ‚Ä™du: {return_code} ---")
        print("The workspace was not cleaned up. Check the errors above.")
        print("Obszar roboczy nie zostaÅ‚ wyczyszczony. SprawdÅº bÅ‚Ä™dy powyÅ¼ej.")

    # --- Krok 9: PrzeÅ‚Ä…cz z powrotem na domyÅ›lny obszar roboczy ---
    print("\nğŸ”„ Switching back to the 'default' workspace...")
    print("ğŸ”„ PrzeÅ‚Ä…czam z powrotem na obszar roboczy 'default'...")
    run_command(['terraform', 'workspace', 'select', 'default'])

    if return_code == 0:
        print("\nâœ¨ Process completed successfully! âœ¨")
        print("âœ¨ Proces zakoÅ„czony pomyÅ›lnie! âœ¨")


if __name__ == '__main__':
    main()
--- END FILE: deploy_vm.py ---

--- START FILE: destroy_vm.py ---
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# =====================================================================================
# === VM DESTRUCTION SCRIPT (v3.0 - Centralized Variables) ===
# === SKRYPT DO USUWANIA MASZYN WIRTUALNYCH (v3.0 - Zmienne Scentralizowane) ===
# =====================================================================================

import os
import subprocess
import yaml

# --- Configuration ---
# --- Konfiguracja ---
CONFIG_FILE = 'config.yaml'


# =====================================================================================
# === HELPER FUNCTIONS (bez zmian) ===
# === FUNKCJE POMOCNICZE (no changes) ===
# =====================================================================================

def run_command(command):
    """
    English: Helper function to run system commands and print their output in real-time.
    Polski:  Funkcja pomocnicza do uruchamiania poleceÅ„ systemowych i drukowania ich wyjÅ›cia w czasie rzeczywistym.
    """
    try:
        process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True,
                                   encoding='utf-8')
        while True:
            output = process.stdout.readline()
            if output == '' and process.poll() is not None:
                break
            if output:
                print(output.strip())
        return process.poll()
    except Exception as e:
        print(f"âŒ An unexpected error occurred / WystÄ…piÅ‚ nieoczekiwany bÅ‚Ä…d: {e}")
        return 1


def load_config():
    """
    English: Loads config.yaml and returns a dictionary of available VMs.
    Polski:  Wczytuje config.yaml i zwraca sÅ‚ownik dostÄ™pnych maszyn wirtualnych.
    """
    if not os.path.exists(CONFIG_FILE):
        return None
    try:
        with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
            return yaml.safe_load(f)
    except (IOError, yaml.YAMLError):
        return None


def remove_from_config(vm_key_to_delete):
    """
    English: Removes a given key from the config.yaml file.
    Polski:  Usuwa dany klucz z pliku config.yaml.
    """
    config_data = load_config()
    if vm_key_to_delete in config_data:
        del config_data[vm_key_to_delete]
    with open(CONFIG_FILE, 'w', encoding='utf-8') as f:
        yaml.dump(config_data, f, default_flow_style=False, sort_keys=False)

    print("\n" + "*" * 60)
    print(f"âœ… Entry for '{vm_key_to_delete}' has been removed from {CONFIG_FILE}.")
    print(f"âœ… Wpis dla '{vm_key_to_delete}' zostaÅ‚ usuniÄ™ty z pliku {CONFIG_FILE}.")
    print("*" * 60)


# =====================================================================================
# === MAIN SCRIPT LOGIC (ZMODYFIKOWANA / MODIFIED) ===
# =====================================================================================

def main():
    """
    English: Main function of the VM destruction script.
    Polski:  GÅ‚Ã³wna funkcja skryptu do usuwania maszyn wirtualnych.
    """
    os.system("clear || cls")
    print("=" * 60)
    print("=== TERRAFORM VM DESTRUCTION WIZARD (v3.0) ===")
    print("=== KREATOR USUWANIA MASZYN WIRTUALNYCH TERRAFORM (v3.0) ===")
    print("=" * 60)

    all_config = load_config()
    if not all_config:
        print(f"\nâŒ Configuration file '{CONFIG_FILE}' does not exist or is empty.")
        print(f"âŒ Plik konfiguracyjny '{CONFIG_FILE}' nie istnieje lub jest pusty.")
        return

    # --- Krok 1: Wczytaj ustawienia ---
    global_settings = all_config.get('GLOBAL_SETTINGS', {})
    gcp_settings = global_settings.get('gcp', {})
    vm_settings = global_settings.get('vm', {})

    if not all([gcp_settings, vm_settings]):
        print("\nâŒ ERROR: Section 'GLOBAL_SETTINGS' in config.yaml is incomplete.")
        print("âŒ BÅÄ„D: Sekcja 'GLOBAL_SETTINGS' w config.yaml jest niekompletna.")
        return

    # --- Krok 2: Wybierz maszynÄ™ do usuniÄ™cia ---
    vms = {k: v for k, v in all_config.items() if isinstance(v, dict) and 'name' in v}
    if not vms:
        print(f"\nâŒ No machine configurations found in '{CONFIG_FILE}'.")
        print(f"âŒ Nie znaleziono konfiguracji maszyn w pliku '{CONFIG_FILE}'.")
        return

    print("\nAvailable machines for deletion:")
    print("DostÄ™pne maszyny do usuniÄ™cia:")
    for key, data in vms.items():
        print(f"  - {key}: {data['name']}")

    vm_key = input(
        "\nEnter the key of the machine to delete (e.g., VM1):\nPodaj klucz maszyny do usuniÄ™cia (np. VM1): ").strip().upper()
    if vm_key not in vms:
        print(f"\nâŒ ERROR: Key '{vm_key}' not found in the configuration file.")
        print(f"âŒ BÅÄ„D: Klucz '{vm_key}' nie zostaÅ‚ znaleziony w pliku konfiguracyjnym.")
        return

    vm_to_delete_data = vms[vm_key]
    vm_name = vm_to_delete_data['name']
    ssh_key = vm_to_delete_data.get('ssh_public_key', 'dummy-key-for-destroy')

    print("\n" + "!" * 60)
    print("!!! WARNING: This operation is irreversible and will permanently delete the VM. !!!")
    print("!!! OSTRZEÅ»ENIE: Ta operacja jest nieodwracalna i trwale usunie maszynÄ™ wirtualnÄ…. !!!")
    print("!" * 60)
    confirm = input(
        f"\nAre you sure you want to permanently delete machine '{vm_name}' ({vm_key})? [y/N]:\nCzy na pewno chcesz trwale usunÄ…Ä‡ maszynÄ™ '{vm_name}' ({vm_key})? [t/N]: ").strip().lower()
    if confirm not in ['y', 't']:
        print("\nOperation cancelled by user / Operacja anulowana przez uÅ¼ytkownika.")
        return

    # --- Krok 3: Uruchom Terraform Destroy z peÅ‚nym zestawem zmiennych ---
    print(f"\nğŸ”„ Switching to workspace '{vm_key}' for deletion...")
    print(f"ğŸ”„ PrzeÅ‚Ä…czanie na obszar roboczy '{vm_key}' w celu usuniÄ™cia...")
    run_command(['terraform', 'workspace', 'select', vm_key])

    print("\n--- Running Terraform Destroy ---")
    print("--- Uruchamianie Terraform Destroy ---")

    destroy_command = [
        'terraform', 'destroy', '-auto-approve',
        # Zmienne podstawowe
        f'-var=instance_name={vm_name}',
        f'-var=root_password=dummy-password',  # HasÅ‚o nie jest potrzebne do usuniÄ™cia
        f'-var=ssh_public_key={ssh_key}',
        # Zmienne z GLOBAL_SETTINGS - konieczne, aby Terraform poprawnie odczytaÅ‚ stan
        f'-var=gcp_project_id={gcp_settings.get("project_id")}',
        f'-var=gcp_region={gcp_settings.get("region")}',
        f'-var=gcp_zone={gcp_settings.get("zone")}',
        f'-var=vm_machine_type={vm_settings.get("machine_type")}',
        f'-var=vm_disk_image={vm_settings.get("disk_image")}',
        f'-var=vm_disk_size_gb={vm_settings.get("disk_size_gb")}',
        f'-var=vm_disk_type={vm_settings.get("disk_type")}',
        f'-var=vm_admin_user={vm_settings.get("admin_user")}',
    ]
    return_code = run_command(destroy_command)

    # --- Krok 4: PosprzÄ…taj po udanym usuniÄ™ciu ---
    if return_code == 0:
        print("\n--- âœ… Terraform Destroy completed successfully ---")
        print("--- âœ… Terraform Destroy zakoÅ„czone sukcesem ---")
        remove_from_config(vm_key)

        print("\nğŸ§¹ Cleaning up workspace...")
        print("ğŸ§¹ SprzÄ…tanie obszaru roboczego...")
        run_command(['terraform', 'workspace', 'select', 'default'])
        run_command(['terraform', 'workspace', 'delete', vm_key])

        print("\nâœ¨ Process completed successfully! âœ¨")
        print("âœ¨ Proces zakoÅ„czony pomyÅ›lnie! âœ¨")
    else:
        print(f"\n--- âŒ ERROR: Terraform Destroy failed with exit code: {return_code} ---")
        print(f"--- âŒ BÅÄ„D: Terraform Destroy zakoÅ„czone z kodem bÅ‚Ä™du: {return_code} ---")
        print("Check the errors above. The entry in config.yaml and the workspace were not removed.")
        print("SprawdÅº bÅ‚Ä™dy powyÅ¼ej. Wpis w config.yaml i obszar roboczy nie zostaÅ‚y usuniÄ™te.")


if __name__ == '__main__':
    main()
--- END FILE: destroy_vm.py ---

--- START FILE: gdown.py ---
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# =====================================================================================
# === REMOTE GDRIVE DOWNLOADER (v2.0 - Centralized Variables) ===
# === SKRYPT ZDALNEGO POBIERANIA Z GDRIVE (v2.0 - Zmienne Scentralizowane) ===
# =====================================================================================

import os
import subprocess
import yaml
import sys
import re

# --- Configuration ---
# --- Konfiguracja ---
CONFIG_FILE = 'config.yaml'

# =====================================================================================
# === HELPER FUNCTIONS (bez zmian) ===
# === FUNKCJE POMOCNICZE (no changes) ===
# =====================================================================================

def run_ssh_command(host_ip, user, command):
    """
    English: Runs a command on a remote machine using standard ssh.
    Polski:  Uruchamia polecenie na zdalnej maszynie uÅ¼ywajÄ…c standardowego ssh.
    """
    full_command = [
        'ssh',
        '-o', 'StrictHostKeyChecking=no',
        '-o', 'ConnectTimeout=10',
        f'{user}@{host_ip}',
        command
    ]
    print(f"\nğŸ”„ Executing remote command on '{host_ip}'...")
    print(f"ğŸ”„ Wykonywanie zdalnego polecenia na '{host_ip}'...")
    print(f"    COMMAND: {command}")

    try:
        process = subprocess.Popen(
            full_command,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            encoding='utf-8',
            bufsize=1
        )
        while True:
            output = process.stdout.readline()
            if output == '' and process.poll() is not None:
                break
            if output:
                print(f"    [{host_ip}] > {output.strip()}")

        returncode = process.poll()
        if returncode != 0:
            print(f"âŒ Error executing SSH command (exit code: {returncode}).")
            print(f"âŒ BÅ‚Ä…d wykonania polecenia SSH (kod wyjÅ›cia: {returncode}).")
        return returncode
    except FileNotFoundError:
        print("âŒ ERROR: Command 'ssh' not found.")
        print("âŒ BÅÄ„D: Polecenie 'ssh' nie zostaÅ‚o znalezione.")
        return 1
    except Exception as e:
        print(f"âŒ An unexpected error occurred during SSH: {e}")
        print(f"âŒ WystÄ…piÅ‚ nieoczekiwany bÅ‚Ä…d podczas SSH: {e}")
        return 1


def load_config():
    """
    English: Loads the main configuration file.
    Polski:  Wczytuje gÅ‚Ã³wny plik konfiguracyjny.
    """
    if not os.path.exists(CONFIG_FILE):
        print(f"âŒ Configuration file '{CONFIG_FILE}' not found.")
        print(f"âŒ Plik konfiguracyjny '{CONFIG_FILE}' nie zostaÅ‚ znaleziony.")
        return None
    try:
        with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
            return yaml.safe_load(f)
    except (IOError, yaml.YAMLError) as e:
        print(f"âŒ Error loading configuration file '{CONFIG_FILE}': {e}")
        print(f"âŒ BÅ‚Ä…d Å‚adowania pliku konfiguracyjnego '{CONFIG_FILE}': {e}")
        return None


# =====================================================================================
# === MAIN SCRIPT LOGIC (ZMODYFIKOWANA / MODIFIED) ===
# =====================================================================================

def main():
    os.system("clear || cls")
    print("=" * 60)
    print("=== GCP REMOTE FILE DOWNLOADER SCRIPT (v2.0) ===")
    print("=== SKRYPT ZDALNEGO POBIERANIA PLIKÃ“W NA MASZYNÄ˜ GCP (v2.0) ===")
    print("=" * 60)

    config = load_config()
    if not config:
        return

    # --- Krok 1: Wczytaj ustawienia globalne ---
    global_settings = config.get('GLOBAL_SETTINGS', {})
    tak_files = global_settings.get('tak_server_files', {})
    vm_settings = global_settings.get('vm', {})

    if not all([tak_files, vm_settings]):
        print("\nâŒ ERROR: Section 'GLOBAL_SETTINGS.tak_server_files' or 'GLOBAL_SETTINGS.vm' not found in config.yaml.")
        print("âŒ BÅÄ„D: Sekcja 'GLOBAL_SETTINGS.tak_server_files' lub 'GLOBAL_SETTINGS.vm' nie zostaÅ‚a znaleziona w pliku config.yaml.")
        return

    # UÅ¼yj zmiennych z konfiguracji
    TAK_SERVER_FOLDER_ID = tak_files.get('folder_id')
    TAK_ZIP_FILE_ID = tak_files.get('zip_id')
    TAK_ZIP_FILENAME = tak_files.get('zip_filename')
    TAK_SERVER_DIRNAME = "tak-server" # MoÅ¼na teÅ¼ przenieÅ›Ä‡ do configu, jeÅ›li potrzeba
    ADMIN_USER = vm_settings.get('admin_user', 'blox_tak_server_admin')

    # --- Krok 2: Wybierz serwer docelowy ---
    servers = {k: v for k, v in config.items() if isinstance(v, dict) and 'name' in v}
    if not servers:
        print(f"\nâŒ No server configurations found in '{CONFIG_FILE}'.")
        print(f"âŒ Nie znaleziono konfiguracji serwerÃ³w w pliku '{CONFIG_FILE}'.")
        return

    print("\nAvailable servers:")
    print("DostÄ™pne serwery:")
    for key, data in servers.items():
        print(f"  - {key}: {data['name']}")

    server_key = input(
        "\nSelect the server to download files to:\nWybierz serwer, na ktÃ³rym majÄ… byÄ‡ pobrane pliki:\n> ").strip().upper()
    if server_key not in servers:
        print(f"\nâŒ ERROR: Key '{server_key}' not found.")
        print(f"âŒ BÅÄ„D: Klucz '{server_key}' nie zostaÅ‚ znaleziony.")
        return

    server_data = servers[server_key]
    instance_name = server_data.get('name')
    ssh_host_ip = server_data.get('internal_ip')

    if not all([instance_name, ssh_host_ip]):
        print(f"\nâŒ ERROR: Configuration for '{server_key}' is incomplete. Missing 'name' or 'internal_ip'.")
        print(f"âŒ BÅÄ„D: Konfiguracja dla '{server_key}' jest niekompletna. Brakuje 'name' lub 'internal_ip'.")
        return

    # --- Krok 3: Wykonaj zdalne polecenia ---
    print(f"\nğŸš€ Preparing machine '{instance_name}' and downloading files...")
    print(f"ğŸš€ Przygotowywanie maszyny '{instance_name}' i pobieranie plikÃ³w...")

    remote_commands = [
        "sudo apt-get update -y",
        "sudo apt-get install -y python3-pip unzip",
        "sudo python3 -m pip install gdown",
        f"python3 -m gdown --folder {TAK_SERVER_FOLDER_ID}",
        f"python3 -m gdown --id {TAK_ZIP_FILE_ID} -O {TAK_ZIP_FILENAME}",
        f"mv {TAK_ZIP_FILENAME} {TAK_SERVER_DIRNAME}/",
        "echo '--- Folder contents / ZawartoÅ›Ä‡ folderu ---'",
        f"ls -l {TAK_SERVER_DIRNAME}"
    ]

    full_remote_command = " && ".join(remote_commands)
    return_code = run_ssh_command(ssh_host_ip, ADMIN_USER, full_remote_command)

    # --- Krok 4: PokaÅ¼ wynik ---
    print("\n" + "=" * 60)
    if return_code == 0:
        print("âœ¨ FINISHED SUCCESSFULLY!")
        print("âœ¨ ZAKOÅƒCZONO POMYÅšLNIE!")
        print(f"âœ… Files have been downloaded and prepared on machine '{instance_name}'.")
        print(f"âœ… Pliki zostaÅ‚y pobrane i przygotowane na maszynie '{instance_name}'.")
    else:
        print("âŒ OPERATION FAILED.")
        print("âŒ OPERACJA ZAKOÅƒCZONA BÅÄ˜DEM.")
        print("âŒ Check the messages above to diagnose the issue.")
        print("âŒ SprawdÅº powyÅ¼sze komunikaty, aby zdiagnozowaÄ‡ problem.")
    print("=" * 60)


if __name__ == '__main__':
    main()
--- END FILE: gdown.py ---

--- START FILE: install_docker.py ---
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# =====================================================================================
# === DOCKER INSTALLATION SCRIPT (v5.0 - Centralized Variables) ===
# === SKRYPT INSTALACJI DOCKERA (v5.0 - Zmienne Scentralizowane) ===
# =====================================================================================

import os
import subprocess
import yaml
import sys

# --- Configuration ---
# --- Konfiguracja ---
CONFIG_FILE = 'config.yaml'


# =====================================================================================
# === HELPER FUNCTIONS (bez zmian) ===
# === FUNKCJE POMOCNICZE (no changes) ===
# =====================================================================================

def load_config():
    """
    English: Loads the main configuration file.
    Polski:  Wczytuje gÅ‚Ã³wny plik konfiguracyjny.
    """
    if not os.path.exists(CONFIG_FILE):
        print(f"âŒ ERROR: Configuration file '{CONFIG_FILE}' not found.")
        print(f"âŒ BÅÄ„D: Plik konfiguracyjny '{CONFIG_FILE}' nie zostaÅ‚ znaleziony.")
        return None
    try:
        with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
            return yaml.safe_load(f)
    except (IOError, yaml.YAMLError) as e:
        print(f"âŒ ERROR: Error loading config file: {e}")
        print(f"âŒ BÅÄ„D: BÅ‚Ä…d Å‚adowania pliku konfiguracyjnego: {e}")
        return None


def run_ssh_command(host_ip, user, command):
    """
    English: Runs a command on a remote machine via SSH and streams the output.
    Polski:  Uruchamia polecenie na zdalnej maszynie przez SSH i strumieniuje wyjÅ›cie.
    """
    full_command = ['ssh', '-o', 'StrictHostKeyChecking=no', '-o', 'ConnectTimeout=10', f'{user}@{host_ip}', command]
    print(f"\nğŸ”„ Executing command on '{host_ip}'...")
    print(f"ğŸ”„ Wykonywanie polecenia na '{host_ip}'...")
    print("-" * 60)
    try:
        process = subprocess.Popen(
            full_command,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            encoding='utf-8',
            bufsize=1
        )
        while True:
            output = process.stdout.readline()
            if output == '' and process.poll() is not None:
                break
            if output:
                print(f"  [{host_ip}] > {output.strip()}")

        returncode = process.poll()
        if returncode != 0:
            print(f"âŒ SSH command failed with exit code: {returncode}.")
            print(f"âŒ Polecenie SSH zakoÅ„czone bÅ‚Ä™dem (kod: {returncode}).")
        return returncode
    except Exception as e:
        print(f"âŒ An unexpected error occurred during SSH: {e}")
        print(f"âŒ WystÄ…piÅ‚ nieoczekiwany bÅ‚Ä…d podczas SSH: {e}")
        return 1


# =====================================================================================
# === MAIN SCRIPT LOGIC (ZMODYFIKOWANA / MODIFIED) ===
# =====================================================================================

def main():
    os.system("clear || cls")
    print("=" * 60)
    print("=== DOCKER INSTALLATION SCRIPT (v5.0) ===")
    print("=== SKRYPT INSTALACJI DOCKERA (v5.0) ===")
    print("=" * 60)

    config = load_config()
    if not config: return

    # --- Krok 1: Wczytaj ustawienia ---
    global_settings = config.get('GLOBAL_SETTINGS', {})
    vm_settings = global_settings.get('vm', {})
    if not vm_settings:
        print("\nâŒ ERROR: Section 'GLOBAL_SETTINGS.vm' not found in config.yaml.")
        print("âŒ BÅÄ„D: Sekcja 'GLOBAL_SETTINGS.vm' nie zostaÅ‚a znaleziona w pliku config.yaml.")
        return

    ADMIN_USER = vm_settings.get('admin_user', 'blox_tak_server_admin')

    # --- Krok 2: Wybierz maszynÄ™ docelowÄ… ---
    vms = {k: v for k, v in config.items() if isinstance(v, dict) and 'name' in v}
    if not vms:
        print(f"\nâŒ ERROR: No VMs found in '{CONFIG_FILE}'.")
        print(f"âŒ BÅÄ„D: Nie znaleziono maszyn w '{CONFIG_FILE}'.")
        return

    print("\nAvailable VMs / DostÄ™pne maszyny wirtualne:")
    for key, data in vms.items():
        print(f"  - {key}: {data['name']}")

    server_key = input(
        "\nEnter the key of the VM to install Docker on:\nWprowadÅº klucz maszyny, na ktÃ³rej zainstalowaÄ‡ Dockera:\n> ").strip().upper()
    if server_key not in vms:
        print(f"\nâŒ ERROR: Key '{server_key}' not found.")
        print(f"âŒ BÅÄ„D: Klucz '{server_key}' nie zostaÅ‚ znaleziony.")
        return

    server_data = vms[server_key]
    ssh_host_ip = server_data.get('internal_ip')

    if not ssh_host_ip:
        print(f"\nâŒ ERROR: Missing 'internal_ip' for VM '{server_key}' in config.yaml.")
        print(f"   Run 'configure_peer.py' first to fetch and save the IP addresses.")
        print(f"\nâŒ BÅÄ„D: Brak 'internal_ip' dla maszyny '{server_key}' w pliku config.yaml.")
        print("   Uruchom najpierw skrypt `configure_peer.py`, aby pobraÄ‡ i zapisaÄ‡ adresy IP.")
        return

    print(f"\nâ„¹ï¸  Connecting to VM via internal IP / ÅÄ…czÄ™ z maszynÄ… przez wewnÄ™trzny adres IP: {ssh_host_ip}")

    # --- Krok 3: Przygotuj i uruchom skrypt instalacyjny ---
    docker_install_script = f"""
    set -e
    echo "--- Starting Docker installation ---"

    # 1. Update package index and install dependencies
    sudo apt-get update
    sudo apt-get install -y ca-certificates curl

    # 2. Add Docker's official GPG key
    sudo install -m 0755 -d /etc/apt/keyrings
    sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
    sudo chmod a+r /etc/apt/keyrings/docker.asc

    # 3. Set up the repository
    echo \\
      "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \\
      $(. /etc/os-release && echo $VERSION_CODENAME) stable" | \\
      sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

    # 4. Install Docker Engine
    sudo apt-get update
    sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

    # 5. Add user to the 'docker' group
    sudo usermod -aG docker {ADMIN_USER}

    echo "âœ… Docker installed successfully."
    """

    return_code = run_ssh_command(ssh_host_ip, ADMIN_USER, docker_install_script)

    print("\n" + "=" * 60)
    if return_code == 0:
        print("âœ¨ DOCKER INSTALLATION FINISHED SUCCESSFULLY! âœ¨")
        print("âœ¨ INSTALACJA DOCKERA ZAKOÅƒCZONA POMYÅšLNIE! âœ¨")
    else:
        print("âŒ DOCKER INSTALLATION FAILED. Check the output above.")
        print("âŒ INSTALACJA DOCKERA NIE POWIODÅA SIÄ˜. SprawdÅº powyÅ¼sze komunikaty.")
    print("=" * 60)


if __name__ == '__main__':
    main()
--- END FILE: install_docker.py ---

--- START FILE: install_wireguard.py ---
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# =====================================================================================
# === WIREGUARD INSTALLATION SCRIPT (v4.0 - Centralized Variables) ===
# === SKRYPT INSTALACJI WIREGUARD (v4.0 - Zmienne Scentralizowane) ===
# =====================================================================================

import os
import subprocess
import yaml
import sys
import re

# --- Configuration ---
# --- Konfiguracja ---
CONFIG_FILE = 'config.yaml'


# =====================================================================================
# === HELPER FUNCTIONS (bez zmian) ===
# === FUNKCJE POMOCNICZE (no changes) ===
# =====================================================================================

def run_command(command, capture_output=False, shell=False):
    """
    English: Runs system commands and handles their output.
    Polski:  Uruchamia polecenia systemowe i obsÅ‚uguje ich wyjÅ›cie.
    """
    try:
        process = subprocess.Popen(
            command, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
            text=True, encoding='utf-8', shell=shell
        )
        stdout, stderr = process.communicate()
        output_lines = []
        if stdout:
            lines = filter(None, stdout.strip().split('\n'))
            for line in lines:
                if capture_output:
                    output_lines.append(line)
                else:
                    print(line)
        if stderr and not capture_output:
            print(f"DEBUG/STDERR: {stderr.strip()}", file=sys.stderr)
        return process.returncode, output_lines
    except Exception as e:
        print(f"âŒ An unexpected error occurred: {e}")
        print(f"âŒ WystÄ…piÅ‚ nieoczekiwany bÅ‚Ä…d: {e}")
        return 1, []


def load_config():
    """
    English: Loads the entire config.yaml file.
    Polski:  Wczytuje caÅ‚y plik config.yaml.
    """
    if not os.path.exists(CONFIG_FILE):
        print(f"âŒ Config file '{CONFIG_FILE}' not found.")
        print(f"âŒ Plik konfiguracyjny '{CONFIG_FILE}' nie zostaÅ‚ znaleziony.")
        return None
    try:
        with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
            return yaml.safe_load(f)
    except (IOError, yaml.YAMLError) as e:
        print(f"âŒ Error loading config file '{CONFIG_FILE}': {e}")
        print(f"âŒ BÅ‚Ä…d Å‚adowania pliku konfiguracyjnego '{CONFIG_FILE}': {e}")
        return None


# =====================================================================================
# === MAIN SCRIPT LOGIC (ZMODYFIKOWANA / MODIFIED) ===
# =====================================================================================

def main():
    os.system("clear || cls")
    print("=" * 60)
    print("=== WIREGUARD INSTALLATION WIZARD (v4.0) ===")
    print("=== KREATOR INSTALACJI WIREGUARD (v4.0) ===")
    print("=" * 60)

    config = load_config()
    if not config: return

    # --- Krok 1: Wczytaj ustawienia globalne ---
    global_settings = config.get('GLOBAL_SETTINGS', {})
    vpn_settings = global_settings.get('vpn', {})
    gcp_settings = global_settings.get('gcp', {})
    vm_settings = global_settings.get('vm', {})

    if not all([vpn_settings, gcp_settings, vm_settings]):
        print("\nâŒ ERROR: 'GLOBAL_SETTINGS' section in config.yaml is incomplete.")
        print("âŒ BÅÄ„D: Sekcja 'GLOBAL_SETTINGS' w config.yaml jest niekompletna.")
        return

    ADMIN_USER = vm_settings.get('admin_user', 'blox_tak_server_admin')
    PROJECT_ID = gcp_settings.get('project_id')
    ZONE = gcp_settings.get('zone')

    # --- Krok 2: Wybierz maszynÄ™ docelowÄ… ---
    vms = {k: v for k, v in config.items() if isinstance(v, dict) and 'name' in v}
    if not vms:
        print(f"\nâŒ No server machine configurations found in '{CONFIG_FILE}'.")
        print(f"\nâŒ Nie znaleziono konfiguracji maszyn serwerowych w pliku '{CONFIG_FILE}'.")
        return

    print("\nAvailable server machines for WireGuard installation:")
    print("DostÄ™pne maszyny serwerowe do instalacji WireGuard:")
    for key, data in vms.items():
        print(f"  - {key}: {data['name']}")

    vm_key = input(
        "\nEnter the key of the machine to install WireGuard on:\nPodaj klucz maszyny, na ktÃ³rej zainstalowaÄ‡ WireGuard:\n> ").strip().upper()
    if vm_key not in vms:
        print(f"\nâŒ ERROR: Key '{vm_key}' not found in the list of available machines.")
        print(f"âŒ BÅÄ„D: Klucz '{vm_key}' nie zostaÅ‚ znaleziony na liÅ›cie dostÄ™pnych maszyn.")
        return

    vm_name = vms[vm_key]['name']

    # --- Krok 3: Przygotuj adresacjÄ™ IP z pliku konfiguracyjnego ---
    vm_number_match = re.search(r'\d+', vm_key)
    if not vm_number_match:
        print(f"âŒ ERROR: Cannot determine server number from key '{vm_key}'. Key must contain a number (e.g., VM1).")
        print(f"âŒ BÅÄ„D: Nie moÅ¼na ustaliÄ‡ numeru serwera z klucza '{vm_key}'. Klucz musi zawieraÄ‡ cyfrÄ™ (np. VM1).")
        return
    vm_number = vm_number_match.group(0)

    server_subnet_cidr = vpn_settings.get('server_subnet')  # np. '10.200.0.0/24'
    ip_prefix = '.'.join(server_subnet_cidr.split('.')[:3]) + '.'  # np. '10.200.0.'
    subnet_mask = server_subnet_cidr.split('/')[1]  # np. '24'

    server_vpn_ip = f"{ip_prefix}{vm_number}"  # np. '10.200.0.1'
    server_vpn_ip_with_mask = f"{server_vpn_ip}/{subnet_mask}"  # np. '10.200.0.1/24'

    print(f"\nğŸš€ Starting WireGuard installation on '{vm_name}'...")
    print(f"ğŸš€ Rozpoczynanie instalacji WireGuard na '{vm_name}'...")
    print(f"   Server VPN IP will be set to / Adres IP serwera VPN zostanie ustawiony na: {server_vpn_ip_with_mask}")

    # --- Krok 4: Uruchom skrypt instalacyjny na zdalnej maszynie ---
    install_script = f"""
        set -e
        echo "--- Installing WireGuard / Instalacja WireGuard ---"
        sudo apt-get update -y && sudo apt-get install -y wireguard

        echo "--- Generating server keys / Generowanie kluczy serwera ---"
        sudo wg genkey | sudo tee /etc/wireguard/server_private.key | sudo wg pubkey | sudo tee /etc/wireguard/server_public.key > /dev/null
        sudo chmod 600 /etc/wireguard/server_private.key /etc/wireguard/server_public.key

        echo "--- Creating server config with IP {server_vpn_ip_with_mask} ---"
        PRIVATE_KEY=$(sudo cat /etc/wireguard/server_private.key)
        echo "[Interface]
Address = {server_vpn_ip_with_mask}
ListenPort = 51820
PrivateKey = ${{PRIVATE_KEY}}
PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -t nat -A POSTROUTING -o ens4 -j MASQUERADE
PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -t nat -D POSTROUTING -o ens4 -j MASQUERADE" | sudo tee /etc/wireguard/wg0.conf > /dev/null

        echo "--- Enabling IP forwarding / WÅ‚Ä…czenie przekierowywania IP ---"
        sudo sysctl -w net.ipv4.ip_forward=1
        echo 'net.ipv4.ip_forward=1' | sudo tee -a /etc/sysctl.conf

        echo "--- Starting WireGuard service / Uruchomienie usÅ‚ugi WireGuard ---"
        sudo systemctl enable wg-quick@wg0
        sudo systemctl start wg-quick@wg0

        echo "âœ¨ WireGuard installation completed successfully! / Instalacja WireGuard zakoÅ„czona pomyÅ›lnie! âœ¨"
    """

    gcloud_ssh_command = [
        'gcloud', 'compute', 'ssh',
        f'{ADMIN_USER}@{vm_name}',
        f'--project={PROJECT_ID}',
        f'--zone={ZONE}',
        '--quiet',
        '--',
        install_script
    ]

    code, _ = run_command(gcloud_ssh_command)

    if code == 0:
        print(f"\nâœ… WireGuard installation on '{vm_name}' completed successfully!")
        print(f"âœ… Instalacja WireGuard na '{vm_name}' zakoÅ„czona pomyÅ›lnie!")
    else:
        print(f"\nâŒ ERROR: WireGuard installation on '{vm_name}' failed with exit code: {code}.")
        print(f"âŒ BÅÄ„D: Instalacja WireGuard na '{vm_name}' zakoÅ„czona bÅ‚Ä™dem. Kod bÅ‚Ä™du: {code}.")


if __name__ == '__main__':
    main()
--- END FILE: install_wireguard.py ---

--- START FILE: main.tf ---
# =====================================================================================
# === TERRAFORM CONFIGURATION FOR GOOGLE CLOUD VM (v2.0 - Centralized Variables) ===
# === KONFIGURACJA TERRAFORM DLA MASZYNY WIRTUALNEJ W GOOGLE CLOUD (v2.0 - Zmienne Scentralizowane) ===
# =====================================================================================

terraform {
  required_providers {
    google = {
      source  = "hashicorp/google"
      version = ">= 4.25.0"
    }
  }
}

# --- Zmienne wejÅ›ciowe / Input Variables ---
# Te zmienne sÄ… przekazywane przez skrypt deploy_vm.py z pliku config.yaml
# This variables are passed from the deploy_vm.py script from the config.yaml file

# Zmienne podstawowe
variable "instance_name" {
  description = "The name of the Compute Engine instance. / Nazwa instancji Compute Engine."
  type        = string
}
variable "root_password" {
  description = "The password for the admin user. / HasÅ‚o dla uÅ¼ytkownika."
  type        = string
  sensitive   = true
}
variable "ssh_public_key" {
  description = "Public SSH key for the admin user. / Publiczny klucz SSH dla uÅ¼ytkownika."
  type        = string
  sensitive   = true
}

# Zmienne z GLOBAL_SETTINGS.gcp
variable "gcp_project_id" {
  description = "Google Cloud Project ID. / ID projektu w Google Cloud."
  type        = string
}
variable "gcp_region" {
  description = "Google Cloud Region. / Region w Google Cloud."
  type        = string
}
variable "gcp_zone" {
  description = "Google Cloud Zone. / Strefa w Google Cloud."
  type        = string
}

# Zmienne z GLOBAL_SETTINGS.vm
variable "vm_machine_type" {
  description = "The machine type for the VM. / Typ maszyny dla VM."
  type        = string
}
variable "vm_disk_image" {
  description = "The boot disk image for the VM. / Obraz dysku startowego dla VM."
  type        = string
}
variable "vm_disk_size_gb" {
  description = "The boot disk size in GB. / Rozmiar dysku startowego w GB."
  type        = number
}
variable "vm_disk_type" {
  description = "The boot disk type. / Typ dysku startowego."
  type        = string
}
variable "vm_admin_user" {
  description = "The username for the admin user on the VM. / Nazwa uÅ¼ytkownika admina na VM."
  type        = string
}

# --- Konfiguracja dostawcy / Provider Configuration ---

provider "google" {
  project = var.gcp_project_id
  region  = var.gcp_region
}

# --- GÅ‚Ã³wny zasÃ³b maszyny wirtualnej / Main VM Resource ---

resource "google_compute_instance" "tak-server-vm" {
  name         = var.instance_name
  zone         = var.gcp_zone
  machine_type = var.vm_machine_type

  boot_disk {
    auto_delete = true
    device_name = var.instance_name
    initialize_params {
      image = var.vm_disk_image
      size  = var.vm_disk_size_gb
      type  = var.vm_disk_type
    }
    mode = "READ_WRITE"
  }

  metadata = {
    # Dodanie klucza SSH do autoryzowanych kluczy uÅ¼ytkownika
    ssh-keys = "${var.vm_admin_user}:${var.ssh_public_key}"

    # Konfiguracja poczÄ…tkowa maszyny za pomocÄ… cloud-init
    user-data = <<-EOT
      #cloud-config

      # StwÃ³rz nowego uÅ¼ytkownika z uprawnieniami sudo
      users:
        - name: ${var.vm_admin_user}
          sudo: ALL=(ALL) NOPASSWD:ALL
          groups: [adm, sudo]
          shell: /bin/bash

      # Ustaw hasÅ‚o dla nowego uÅ¼ytkownika
      chpasswd:
        list: |
          ${var.vm_admin_user}:${var.root_password}
        expire: False

      # Rekomendacja: WyÅ‚Ä…cz logowanie hasÅ‚em, skoro mamy klucze SSH
      runcmd:
        - [ sed, -i, -e, 's/^#?PasswordAuthentication .*/PasswordAuthentication no/g', /etc/ssh/sshd_config ]
        - [ systemctl, restart, sshd ]
    EOT
  }

  network_interface {
    subnetwork = "projects/${var.gcp_project_id}/regions/${var.gcp_region}/subnetworks/default"
    access_config {
      network_tier = "PREMIUM"
    }
  }

  scheduling {
    automatic_restart   = true
    on_host_maintenance = "MIGRATE"
    preemptible         = false
    provisioning_model  = "STANDARD"
  }

  shielded_instance_config {
    enable_integrity_monitoring = true
    enable_secure_boot          = true
    enable_vtpm                 = true
  }

  deletion_protection = true
  can_ip_forward      = false
  enable_display      = false
  hostname            = "takserver.local"
  tags                = ["tak-server"]

  labels = {
    goog-ec-src         = "vm_add-tf"
    goog-ops-agent-policy = "v2-x86-template-1-4-0"
  }
}
--- END FILE: main.tf ---

--- START FILE: requirements.txt ---
PyYAML==6.0.1

--- END FILE: requirements.txt ---

--- START FILE: setup.py ---
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# =====================================================================================
# === TAK SERVER REMOTE INSTALLER (v3.1 - Dependency Fix) ===
# === ZDALNY INSTALATOR TAK SERVER (v3.1 - Poprawka ZaleÅ¼noÅ›ci) ===
# =====================================================================================

import os
import subprocess
import yaml
import sys

# --- Configuration ---
# --- Konfiguracja ---
CONFIG_FILE = 'config.yaml'
LOCAL_CERTS_BASE_PATH = 'gcp_tak_certs'


# =====================================================================================
# === HELPER FUNCTIONS ===
# =====================================================================================

def run_command_local(command):
    """
    English: Runs a command on the local machine.
    Polski:  Uruchamia polecenie na lokalnej maszynie.
    """
    print(f"\nğŸ”„ Executing local command / Wykonywanie polecenia lokalnego: {' '.join(command)}")
    try:
        process = subprocess.run(command, check=True, capture_output=True, text=True)
        print("âœ… Command executed successfully / Polecenie wykonane pomyÅ›lnie.")
        return True
    except subprocess.CalledProcessError as e:
        print(f"âŒ ERROR: Command failed / BÅÄ„D: Polecenie zakoÅ„czyÅ‚o siÄ™ bÅ‚Ä™dem.")
        print(f"   Stderr: {e.stderr.strip()}")
        return False


def load_config():
    """
    English: Loads the main configuration file.
    Polski:  Wczytuje gÅ‚Ã³wny plik konfiguracyjny.
    """
    if not os.path.exists(CONFIG_FILE):
        print(f"âŒ ERROR: Configuration file '{CONFIG_FILE}' not found.")
        print(f"âŒ BÅÄ„D: Plik konfiguracyjny '{CONFIG_FILE}' nie zostaÅ‚ znaleziony.")
        return None
    try:
        with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
            return yaml.safe_load(f)
    except (IOError, yaml.YAMLError) as e:
        print(f"âŒ ERROR: Could not load configuration file '{CONFIG_FILE}': {e}")
        print(f"âŒ BÅÄ„D: Nie moÅ¼na wczytaÄ‡ pliku konfiguracyjnego '{CONFIG_FILE}': {e}")
        return None


def run_ssh_command(host_ip, user, command):
    """
    English: Runs a command in a non-interactive SSH session.
    Polski:  Uruchamia polecenie w sesji SSH (nieinteraktywnie).
    """
    ssh_command = ['ssh', '-o', 'StrictHostKeyChecking=no', '-o', 'ConnectTimeout=10', f'{user}@{host_ip}', command]
    print(f"\nğŸ”„ Executing command on '{host_ip}': {command}")
    print(f"ğŸ”„ Wykonywanie polecenia na '{host_ip}': {command}")
    try:
        # Use Popen to stream output in real-time
        process = subprocess.Popen(ssh_command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True,
                                   encoding='utf-8')
        while True:
            output = process.stdout.readline()
            if output == '' and process.poll() is not None:
                break
            if output:
                print(f"  [{host_ip}] > {output.strip()}")
        return process.poll()
    except Exception as e:
        print(f"âŒ An unexpected error occurred during SSH: {e}")
        print(f"âŒ WystÄ…piÅ‚ nieoczekiwany bÅ‚Ä…d podczas SSH: {e}")
        return 1


def run_ssh_interactive(host_ip, user, command):
    """
    English: Runs a command in an interactive SSH session.
    Polski:  Uruchamia polecenie w interaktywnej sesji SSH.
    """
    ssh_command = ['ssh', '-t', '-o', 'StrictHostKeyChecking=no', '-o', 'ConnectTimeout=10', f'{user}@{host_ip}',
                   command]
    print(f"\nğŸ”„ Connecting to '{host_ip}' as '{user}' to run the installation script...")
    print(f"ğŸ”„ ÅÄ…czenie z '{host_ip}' jako '{user}' w celu uruchomienia skryptu instalacyjnego...")
    print(f"    COMMAND / POLECENIE: {command}")
    print("-" * 60)
    print(">>> Starting interactive SSH session. / Rozpoczynanie interaktywnej sesji SSH. <<<")
    print("-" * 60)
    try:
        process = subprocess.run(ssh_command, check=False)
        return process.returncode
    except Exception as e:
        print(f"\nâŒ An unexpected error occurred during SSH: {e}")
        print(f"âŒ WystÄ…piÅ‚ nieoczekiwany bÅ‚Ä…d podczas SSH: {e}")
        return 1


# =====================================================================================
# === MAIN SCRIPT LOGIC ===
# =====================================================================================

def main():
    os.system("clear || cls")
    print("=" * 60)
    print("=== TAK SERVER REMOTE INSTALLER (v3.1) ===")
    print("=== ZDALNY INSTALATOR TAK SERVER (v3.1) ===")
    print("=" * 60)

    config = load_config()
    if not config: return

    # --- Krok 1: Wczytaj ustawienia ---
    global_settings = config.get('GLOBAL_SETTINGS', {})
    vm_settings = global_settings.get('vm', {})
    if not vm_settings:
        print("\nâŒ ERROR: Section 'GLOBAL_SETTINGS.vm' not found in config.yaml.")
        print("âŒ BÅÄ„D: Sekcja 'GLOBAL_SETTINGS.vm' nie zostaÅ‚a znaleziona w pliku config.yaml.")
        return

    ADMIN_USER = vm_settings.get('admin_user', 'blox_tak_server_admin')
    REMOTE_PROJECT_PATH = f'/home/{ADMIN_USER}/tak-server'

    # --- Krok 2: Wybierz serwer docelowy ---
    servers = {k: v for k, v in config.items() if isinstance(v, dict) and 'name' in v}
    if not servers:
        print(f"\nâŒ No server configurations found in '{CONFIG_FILE}'.")
        print(f"âŒ Nie znaleziono konfiguracji serwerÃ³w w pliku '{CONFIG_FILE}'.")
        return

    print("\nAvailable servers for installation:")
    print("DostÄ™pne serwery do instalacji:")
    for key, data in servers.items():
        print(f"  - {key}: {data['name']}")

    server_key = input(
        "\nSelect the server to run setup.sh on:\nWybierz serwer, na ktÃ³rym chcesz uruchomiÄ‡ setup.sh:\n> ").strip().upper()
    if server_key not in servers:
        print(f"\nâŒ ERROR: Key '{server_key}' not found.")
        print(f"âŒ BÅÄ„D: Klucz '{server_key}' nie zostaÅ‚ znaleziony.")
        return

    server_data = servers[server_key]
    ssh_host_ip = server_data.get('internal_ip')
    if not ssh_host_ip:
        print(f"âŒ ERROR: Missing 'internal_ip' for VM '{server_key}'. A VPN connection is required.")
        print(f"âŒ BÅÄ„D: Brak 'internal_ip' dla maszyny '{server_key}'. PoÅ‚Ä…czenie przez VPN jest wymagane.")
        return

    # --- Krok 3: Instalacja zaleÅ¼noÅ›ci na zdalnej maszynie (PRZYWRÃ“CONY) ---
    print("\n--- Step 3: Installing dependencies on the remote machine ---")
    print("--- Krok 3: Instalacja zaleÅ¼noÅ›ci na zdalnej maszynie ---")
    install_deps_command = "sudo apt-get update && sudo apt-get install -y net-tools zip"
    if run_ssh_command(ssh_host_ip, ADMIN_USER, install_deps_command) != 0:
        print("\nâŒ Failed to install dependencies. Aborting.")
        print("âŒ Nie udaÅ‚o siÄ™ zainstalowaÄ‡ zaleÅ¼noÅ›ci. Prerywam dziaÅ‚anie.")
        return
    print("âœ… Dependencies installed successfully. / ZaleÅ¼noÅ›ci zainstalowane pomyÅ›lnie.")

    # --- Krok 4: Uruchomienie skryptu setup.sh ---
    print("\n--- Step 4: Running remote TAK Server installation ---")
    print("--- Krok 4: Uruchomienie zdalnej instalacji TAK Server ---")
    remote_command = (f"sudo bash -c 'cd {REMOTE_PROJECT_PATH} && "
                      f"find scripts/ -type f -name \"*.sh\" -exec chmod +x {{}} \\; && "
                      f"./scripts/setup.sh'")
    return_code = run_ssh_interactive(ssh_host_ip, ADMIN_USER, remote_command)

    # --- Krok 5: Kopiowanie certyfikatÃ³w po udanej instalacji ---
    if return_code == 0:
        print("\n--- Step 5: Copying certificates to the local machine ---")
        print("--- Krok 5: Kopiowanie certyfikatÃ³w na maszynÄ™ lokalnÄ… ---")
        local_cert_path = os.path.join(LOCAL_CERTS_BASE_PATH, server_key)
        print(f"Creating local directory / Tworzenie lokalnego katalogu: {local_cert_path}")
        os.makedirs(local_cert_path, exist_ok=True)
        remote_cert_path = f"{REMOTE_PROJECT_PATH}/tak/certs/files/"
        scp_command = ["scp", "-r", f"{ADMIN_USER}@{ssh_host_ip}:{remote_cert_path}*", f"{local_cert_path}/"]
        run_command_local(scp_command)
    else:
        print("\n--- Step 5 skipped due to installation error. ---")
        print("--- Krok 5 pominiÄ™ty z powodu bÅ‚Ä™du instalacji. ---")

    print("\n" + "=" * 60)
    if return_code == 0:
        print("âœ¨ PROCESS FINISHED SUCCESSFULLY (Installation and Copying)!")
        print("âœ¨ PROCES ZAKOÅƒCZONY POMYÅšLNIE (Instalacja i Kopiowanie)!")
    else:
        print(f"âŒ PROCESS FINISHED WITH AN ERROR (exit code: {return_code}).")
        print(f"âŒ PROCES ZAKOÅƒCZONY BÅÄ˜DEM (kod wyjÅ›cia: {return_code}).")
    print("=" * 60)


if __name__ == '__main__':
    main()
--- END FILE: setup.py ---


--- END FILE: BLOX-TAK-SERVER-GCP_Early_Stage_Access_1.0.0.1_bundle.txt ---

--- START FILE: CODE_OF_CONDUCT.md ---
## Contributor Covenant Code of Conduct

### Our Pledge

We as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, religion, or sexual identity
and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.

### Our Standards

Examples of behavior that contributes to a positive environment for our
community include:

* Demonstrating empathy and kindness toward other people
* Being respectful of differing opinions, viewpoints, and experiences
* Giving and gracefully accepting constructive feedback
* Accepting responsibility and apologizing to those affected by our mistakes,
    and learning from the experience
* Focusing on what is best not just for us as individuals, but for the
    overall community

Examples of unacceptable behavior include:

* The use of sexualized language or imagery, and sexual attention or
    advances of any kind
* Trolling, insulting or derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or email
    address, without their explicit permission
* Other conduct which could reasonably be considered inappropriate in a
    professional setting

### Enforcement Responsibilities

Community leaders are responsible for clarifying and enforcing our standards and
will take appropriate and fair corrective action in response to any behavior
that they deem inappropriate, threatening, offensive, or harmful.

Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.

### Scope

This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.

### Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at
**luke.strider.gm@gmail.com**.
All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the
reporter of any incident.

### Enforcement Guidelines

Community leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:

### 1. Correction

**Community Impact**: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.

**Consequence**: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.

### 2. Warning

**Community Impact**: A violation through a single incident or series
of actions.

**Consequence**: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interaction in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or
permanent ban.

### 3. Temporary Ban

**Community Impact**: A serious violation of community standards, including
sustained inappropriate behavior.

**Consequence**: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.

### 4. Permanent Ban

**Community Impact**: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior, harassment of an
individual, or aggression toward or disparagement of classes of individuals.

**Consequence**: A permanent ban from any sort of public interaction within
the community.

---
Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage],
version 2.1, available at
[https://www.contributor-covenant.org/version/2/1/code_of_conduct.html][v2.1].

[homepage]: https://www.contributor-covenant.org
[v2.1]: https://www.contributor-covenant.org/version/2/1/code_of_conduct.html
--- END FILE: CODE_OF_CONDUCT.md ---

--- START FILE: LICENSE.txt ---
MIT License

Copyright (c) 2025 Åukasz "LukeStriderGM" Andruszkiewicz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
--- END FILE: LICENSE.txt ---

--- START FILE: README.md ---
# ğŸ‡ºğŸ‡¸ BLOX-TAK-SERVER-GCP (Early Stage Access)

Welcome to the early stage private repository for the **BLOX-TAK-SERVER-GCP** project. This suite of scripts is designed to provide a robust, secure, and highly automated foundation for deploying a TAK (Team Awareness Kit) ecosystem on the Google Cloud Platform.

This repository is currently shared with a select group of authorities, mentors, and leaders within the TAK community for feedback, discussion, and testing. The goal is to refine this core infrastructure before a potential public release.

<details>

<summary>ğŸ‡µğŸ‡± [Kliknij TrÃ³jkÄ…t Po Lewej Stronie Aby RozwinÄ…Ä‡ Opis w JÄ™zyku Polskim]</summary>

# ğŸ‡µğŸ‡± BLOX-TAK-SERVER-GCP (DostÄ™p Do Wczesnego Etapu)

Witaj we wczesnym, prywatnym repozytorium projektu **BLOX-TAK-SERVER-GCP**. Ten pakiet skryptÃ³w zostaÅ‚ zaprojektowany, aby zapewniÄ‡ solidnÄ…, bezpiecznÄ… i wysoce zautomatyzowanÄ… podstawÄ™ do wdraÅ¼ania ekosystemu TAK (Team Awareness Kit) na platformie Google Cloud Platform.

To repozytorium jest obecnie udostÄ™pniane wybranej grupie autorytetÃ³w, mentorÃ³w i liderÃ³w w spoÅ‚ecznoÅ›ci TAK w celu uzyskania opinii, dyskusji i testÃ³w. Celem jest udoskonalenie tej podstawowej infrastruktury przed potencjalnym publicznym wydaniem.

</details>

---

## ğŸ‡ºğŸ‡¸ Core Features

This package contains the foundational scripts to deploy and manage a complete server instance from scratch. The entire process, from a clean GCP project to a fully operational server with an admin and first client, can be completed in **under one hour**.

* **Automated VM Deployment**: Utilizes **Terraform** to create and configure a secure GCP virtual machine based on Ubuntu 22.04 LTS.
* **Mandatory Hardware-Key Security**: Enforces the use of a **YubiKey** (or similar FIDO/U2F key) for all SSH administrative access, eliminating password-based logins.
    I also use the YubiKey to secure my Google services, as well as all operations requiring sudo on my MDC2 laptop - including login + disk encryption.
* **Automated WireGuard VPN**: Deploys a WireGuard server for secure, encrypted communication tunnels. Includes scripts to configure both admin (split-tunnel by default) and end-user (split-tunnel by default) clients.
* **For mission-critical security**, at this stage you can manually switch to the full-tunnel function, which completely cuts off external network traffic and allows you to operate only in a pure TAK ecosystem.
* **Docker & TAK Server Installation**: Fully automates the installation of Docker and the TAK Server itself, including downloading necessary files from Google Drive.
* **Client & Certificate Management**: Includes Python scripts to add new SSH keys and configure clients for WireGuard.
* **Bilingual Interface**: All scripts provide interactive prompts and status messages in both English and Polish.

<details>

<summary>ğŸ‡µğŸ‡±</summary>

## ğŸ‡µğŸ‡± GÅ‚Ã³wne FunkcjonalnoÅ›ci

Ten pakiet zawiera podstawowe skrypty do wdroÅ¼enia i zarzÄ…dzania kompletnÄ… instancjÄ… serwera od zera. CaÅ‚y proces, od czystego projektu GCP do w peÅ‚ni dziaÅ‚ajÄ…cego serwera z administratorem i pierwszym klientem, moÅ¼na ukoÅ„czyÄ‡ w **mniej niÅ¼ godzinÄ™**.

* **Automatyczne WdroÅ¼enie Maszyny Wirtualnej**: Wykorzystuje **Terraform** do tworzenia i konfigurowania bezpiecznej maszyny wirtualnej GCP opartej na Ubuntu 22.04 LTS.
* **Wymuszone BezpieczeÅ„stwo Kluczem SprzÄ™towym**: Wymusza uÅ¼ycie **YubiKey** (lub podobnego klucza FIDO/U2F) do caÅ‚ego administracyjnego dostÄ™pu przez SSH, eliminujÄ…c logowanie oparte na haÅ›le.
    Klucza YubiKey uÅ¼ywam rÃ³wnieÅ¼ do zabezpiecznia moich usÅ‚ug w Google, a takÅ¼e wszystkich operacji wymagajÄ…cych sudo na laptopie MDC2 - rÃ³wnieÅ¼ przy logowaniu + szyfrowanie dyskÃ³w. 
* **Automatyczny VPN WireGuard**: WdraÅ¼a serwer WireGuard do bezpiecznych, szyfrowanych tuneli komunikacyjnych. Zawiera skrypty do konfiguracji zarÃ³wno klientÃ³w administracyjnych (domyÅ›lnie split-tunnel), jak i koÅ„cowych uÅ¼ytkownikÃ³w (domyÅ›lnie split-tunnel).
* **Dla bezpieczeÅ„stwa misji o znaczeniu krytycznym**, na tym etapie moÅ¼na przejÅ›Ä‡ rÄ™cznie na funkcjÄ™ full-tunnel ktÃ³ra caÅ‚kowicie odcina zewnÄ™trzny ruch z sieci i pozwala operowaÄ‡ tylko w czystym ekosystemie TAK.
* **Instalacja Dockera i Serwera TAK**: W peÅ‚ni automatyzuje instalacjÄ™ Dockera i samego Serwera TAK, w tym pobieranie niezbÄ™dnych plikÃ³w z Dysku Google.
* **ZarzÄ…dzanie Klientami i Certyfikatami**: Zawiera skrypty Pythona do dodawania nowych kluczy SSH i konfigurowania klientÃ³w dla WireGuard.
* **DwujÄ™zyczny Interfejs**: Wszystkie skrypty zapewniajÄ… interaktywne monity i komunikaty o stanie w jÄ™zyku angielskim i polskim.

</details>

---

## ğŸ‡ºğŸ‡¸ Prerequisites

To use these scripts, you will need the following on your **local admin machine** (which should be Ubuntu 22.04 for full compatibility):

1.  **Google Cloud Platform (GCP) Account**: A GCP account with an active project and billing enabled.
2.  **Google Cloud CLI**: The `gcloud` command-line tool installed and authenticated.
3.  **Terraform**: The Terraform CLI installed.
4.  **YubiKey (or other FIDO/U2F key)**: A hardware security key for generating your `ed25519-sk` SSH key. **This is not optional.**
5.  **Python 3 & Dependencies**.
6.  **Ubuntu 22.04 LTS**.


<details>

<summary>ğŸ‡µğŸ‡±</summary>

## ğŸ‡µğŸ‡± Wymagania WstÄ™pne

Do uÅ¼ycia tych skryptÃ³w potrzebne bÄ™dÄ… nastÄ™pujÄ…ce elementy na Twojej **lokalnej maszynie administracyjnej** (ktÃ³ra dla peÅ‚nej kompatybilnoÅ›ci powinna byÄ‡ oparta na Ubuntu 22.04):

1.  **Konto Google Cloud Platform (GCP)**: Konto GCP z aktywnym projektem i wÅ‚Ä…czonymi pÅ‚atnoÅ›ciami.
2.  **Google Cloud CLI**: Zainstalowane i uwierzytelnione narzÄ™dzie wiersza poleceÅ„ `gcloud`.
3.  **Terraform**: Zainstalowany interfejs CLI Terraform.
4.  **YubiKey (lub inny klucz FIDO/U2F)**: SprzÄ™towy klucz bezpieczeÅ„stwa do wygenerowania Twojego klucza SSH `ed25519-sk`. **To nie jest opcjonalne.**
5.  **Python 3 i ZaleÅ¼noÅ›ci**.
6.  **Ubuntu 22.04 LTS**.

</details>

---

## ğŸ‡ºğŸ‡¸ Deployment Guide / ğŸ‡µğŸ‡± Instrukcja WdroÅ¼enia

Follow these steps in order to set up your complete TAK Server ecosystem.

### ğŸ‡ºğŸ‡¸ Step 1: Prerequisites, Setup, and Firewall Configuration

This initial step covers everything you need to do on your **local admin machine** and in the **GCP Console** before deploying the virtual machine.

### Part A: Local Admin Machine Setup

1.  **Install Core Dependencies**:
    * First, update your system and install Python, pip, venv, and other required tools like `qrencode` and `wireguard`.
        ```bash
        sudo apt-get update && sudo apt-get install -y python3-pip python3-venv qrencode wireguard apt-transport-https ca-certificates curl
        ```

2.  **Install Google Cloud CLI**:
    * Add the gcloud CLI package source and install the command-line tool.
        ```bash
        curl -fsSL https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo gpg --dearmor -o /usr/share/keyrings/cloud.google.gpg
        echo "deb [signed-by=/usr/share/keyrings/cloud.google.gpg] https://packages.cloud.google.com/apt cloud-sdk main" | sudo tee /etc/apt/sources.list.d/google-cloud-sdk.list
        sudo apt-get update && sudo apt-get install -y google-cloud-cli
        ```

3.  **Install Terraform**:
    * Add the HashiCorp repository and install Terraform.
        ```bash
        sudo curl -fsSL https://apt.releases.hashicorp.com/gpg | sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg
        echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
        sudo apt-get update && sudo apt-get install -y terraform
        ```

4.  **Configure GCP Account & Generate SSH Key**:
    * Log in to your GCP account, set the project, and generate a new hardware-backed SSH key. **A YubiKey (or similar FIDO/U2F key) is mandatory.**
        ```bash
        # Log in to your Google Account (will open a browser)
        gcloud auth login
        ```
        
        ```bash 
        # Set your target GCP Project ID
        gcloud config set project <YOUR_PROJECT_ID>
        ````

        ```bash
        # Generate a new security key-backed SSH key
        ssh-keygen -t ed25519-sk -C "your_email@example.com"
        ```

5.  **Clone Repository & Install Python Dependencies**

    * If you don't have it configured - first:
        ```bash
        sudo apt install gh
        gh auth login
        ```

    * Finally, clone the project repository and install the required Python packages.
        ```bash
        git clone https://github.com/LukeStriderGM/BLOX-TAK-SERVER-GCP_Early_Stage_Access
        cd BLOX-TAK-SERVER-GCP_Early_Stage_Access
        pip install -r requirements.txt
        ```

### Part B: GCP Firewall Configuration

Before deploying the virtual machine, you must configure the firewall in your GCP project's VPC network to allow necessary traffic.

1.  Navigate to **VPC network -> Firewall** in your Google Cloud Console.
2.  Click **CREATE FIREWALL RULE** and create the following two rules:

#### Rule 1: Allow SSH Access from Admin IP
* **Name**: `ssh-22`
* **Direction of traffic**: `Ingress`
* **Action on match**: `Allow`
* **Targets**: `Specified target tags`
* **Target tags**: `tak-server`
* **Source filter**: `IPv4 ranges`
* **Source IPv4 ranges**: `0.0.0.0/32` (Enter your own admin IP here)
* **Protocols and ports**: `Specified protocols and ports` -> `tcp`: `22`

#### Rule 2: Allow WireGuard VPN Traffic
* **Name**: `wire-guard`
* **Direction of traffic**: `Ingress`
* **Action on match**: `Allow`
* **Targets**: `Specified target tags`
* **Target tags**: `tak-server`
* **Source filter**: `IPv4 ranges`
* **Source IPv4 ranges**: `0.0.0.0/0`
* **Protocols and ports**: `Specified protocols and ports` -> `udp`: `51820`

<details>
<summary>ğŸ‡µğŸ‡±</summary>

### ğŸ‡µğŸ‡± Krok 1: Wymagania, Konfiguracja i ReguÅ‚y Zapory Sieciowej

Ten poczÄ…tkowy krok obejmuje wszystko, co musisz zrobiÄ‡ na swojej **lokalnej maszynie administracyjnej** oraz w **Konsoli GCP** przed wdroÅ¼eniem maszyny wirtualnej.

### CzÄ™Å›Ä‡ A: Konfiguracja Lokalnej Maszyny Administracyjnej

1.  **Zainstaluj Podstawowe ZaleÅ¼noÅ›ci**:
    * Najpierw zaktualizuj system i zainstaluj Python, pip, venv oraz inne wymagane narzÄ™dzia, takie jak `qrencode` i `wireguard`.
        ```bash
        sudo apt-get update && sudo apt-get install -y python3-pip python3-venv qrencode wireguard apt-transport-https ca-certificates curl
        ```

2.  **Zainstaluj Google Cloud CLI**:
    * Dodaj ÅºrÃ³dÅ‚o pakietÃ³w gcloud CLI i zainstaluj narzÄ™dzie wiersza poleceÅ„.
        ```bash
        curl -fsSL https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo gpg --dearmor -o /usr/share/keyrings/cloud.google.gpg
        echo "deb [signed-by=/usr/share/keyrings/cloud.google.gpg] https://packages.cloud.google.com/apt cloud-sdk main" | sudo tee /etc/apt/sources.list.d/google-cloud-sdk.list
        sudo apt-get update && sudo apt-get install -y google-cloud-cli
        ```

3.  **Zainstaluj Terraform**:
    * Dodaj repozytorium HashiCorp i zainstaluj Terraform.
        ```bash
        sudo curl -fsSL https://apt.releases.hashicorp.com/gpg | sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg
        echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
        sudo apt-get update && sudo apt-get install -y terraform
        ```

4.  **Skonfiguruj Konto GCP i Wygeneruj Klucz SSH**:
    * Zaloguj siÄ™ na swoje konto GCP, ustaw projekt i wygeneruj nowy klucz SSH wspierany sprzÄ™towo. **Klucz YubiKey (lub podobny klucz FIDO/U2F) jest obowiÄ…zkowy.**
        ```bash
        # Zaloguj siÄ™ na swoje konto Google (otworzy siÄ™ przeglÄ…darka)
        gcloud auth login
        ```
        
        ```bash
        # Ustaw docelowy identyfikator projektu GCP
        gcloud config set project <TWÃ“J_PROJECT_ID>
        ```
   
        ```bash
        # Wygeneruj nowy klucz SSH oparty na kluczu bezpieczeÅ„stwa
        ssh-keygen -t ed25519-sk -C "twoj_email@example.com"
        ```

5.  **Sklonuj Repozytorium i Zainstaluj ZaleÅ¼noÅ›ci Python**
    
    * JeÅ›li nie masz skonfigurowane - najpierw:
        ```bash
        sudo apt install gh
        gh auth login
        ```
    
    * Na koniec sklonuj repozytorium projektu i zainstaluj wymagane pakiety Python.
        ```bash
        git clone https://github.com/LukeStriderGM/BLOX-TAK-SERVER-GCP_Early_Stage_Access
        cd BLOX-TAK-SERVER-GCP_Early_Stage_Access
        pip install -r requirements.txt
        ```

### CzÄ™Å›Ä‡ B: Konfiguracja ReguÅ‚ Zapory Sieciowej GCP

Przed wdroÅ¼eniem maszyny wirtualnej musisz skonfigurowaÄ‡ zaporÄ™ sieciowÄ… (firewall) w sieci VPC swojego projektu GCP, aby zezwoliÄ‡ na niezbÄ™dny ruch.

1.  W konsoli Google Cloud przejdÅº do **SieÄ‡ VPC -> Zapora sieciowa**.
2.  Kliknij **UTWÃ“RZ REGUÅÄ˜ ZAPORY SIECIOWEJ** i utwÃ³rz dwie poniÅ¼sze reguÅ‚y:

#### ReguÅ‚a 1: ZezwÃ³l na DostÄ™p SSH z Adresu IP Administratora
* **Nazwa**: `ssh-22`
* **Kierunek ruchu**: `PrzychodzÄ…cy`
* **DziaÅ‚anie w przypadku dopasowania**: `Zezwalaj`
* **Cele**: `OkreÅ›lone tagi docelowe`
* **Tagi docelowe**: `tak-server`
* **Filtr ÅºrÃ³dÅ‚owy**: `Zakresy IPv4`
* **Å¹rÃ³dÅ‚owe zakresy IPv4**: `0.0.0.0/32` (WprowadÅº tutaj wÅ‚asny adres IP administratora)
* **ProtokoÅ‚y i porty**: `OkreÅ›lone protokoÅ‚y i porty` -> `tcp`: `22`

#### ReguÅ‚a 2: ZezwÃ³l na Ruch VPN WireGuard
* **Nazwa**: `wire-guard`
* **Kierunek ruchu**: `PrzychodzÄ…cy`
* **DziaÅ‚anie w przypadku dopasowania**: `Zezwalaj`
* **Cele**: `OkreÅ›lone tagi docelowe`
* **Tagi docelowe**: `tak-server`
* **Filtr ÅºrÃ³dÅ‚owy**: `Zakresy IPv4`
* **Å¹rÃ³dÅ‚owe zakresy IPv4**: `0.0.0.0/0`
* **ProtokoÅ‚y i porty**: `OkreÅ›lone protokoÅ‚y i porty` -> `udp`: `51820`

</details>

---

### ğŸ‡ºğŸ‡¸ Step 2: Deploy the GCP Virtual Machine

This script uses Terraform to create the VM, sets up a dedicated user, and adds your YubiKey public key for access.

```bash
# Initialize Terraform
terraform init

# After this step, enter your variables into config.yaml
cp config-example.yaml config.yaml
```

```bash
# Run the deployment script
python3 deploy_vm.py
```

The script will automatically create a config.yaml file with the new VM's details.

### Step 3: Configure VPN & Core Services

Install WireGuard on the Server:

```bash
python3 install_wireguard.py
```

Configure Your Admin VPN Peer:
This creates a local WireGuard configuration to connect your admin machine to the server's private network.

```bash
python3 configure_peer.py
```

After it completes, activate the tunnel:

```bash
# The path will be shown at the end of the script's output
sudo wg-quick up /etc/wireguard/admin_VM1/admin.conf
```
VM1, VM2, VM3 ...

You should now be able to connect to the server using its internal VPN IP (e.g., 10.200.0.1). 2, 3 ... 

<br>
Install Docker:
This script will connect to the server over the VPN to perform the installation.

```bash
python3 install_docker.py
```

### Step 4: Install TAK Server

Download TAK Server Files to the VM:
This script uses gdown on the remote server to download the necessary TAK Server zip file.

```bash
python3 gdown.py
```

Run the TAK Server Setup:
This is an interactive script that will guide you through the TAK server installation on the remote machine.

```bash
python3 setup.py
```

After the installation is complete, it will automatically copy the generated client certificates to your local machine.

### Step 5: Configure Clients
Add an Android WireGuard Client:
This will generate a QR code to easily add a new VPN profile to the WireGuard app on an Android device. By default, this tunnel is configured for split-tunnel traffic to conserve battery and allow normal phone operation. It can be manually changed to full-tunnel if the mission requires it.

```bash
python3 configure_peer_android.py
```

Your basic TAK server ecosystem is now operational!

<details>

<summary>ğŸ‡µğŸ‡±</summary>

### ğŸ‡µğŸ‡± Krok 2: WdrÃ³Å¼ MaszynÄ™ WirtualnÄ… GCP
Ten skrypt uÅ¼ywa Terraform do stworzenia maszyny wirtualnej, konfiguruje dedykowanego uÅ¼ytkownika i dodaje TwÃ³j publiczny klucz YubiKey w celu uzyskania dostÄ™pu.

```bash
# Zainicjuj Terraform
terraform init

# Po tym kroku wprowadÅº swoje zmienne do config.yaml

cp config-example.yaml config.yaml
```

```bash
# Uruchom skrypt wdroÅ¼enia
python3 deploy_vm.py
```

Skrypt automatycznie utworzy plik config.yaml ze szczegÃ³Å‚ami nowej maszyny wirtualnej.

### Krok 3: Skonfiguruj VPN i Podstawowe UsÅ‚ugi

Zainstaluj WireGuard na Serwerze:

```bash
python3 install_wireguard.py
```

Skonfiguruj SwÃ³j Administracyjny Peer VPN:
Tworzy to lokalnÄ… konfiguracjÄ™ WireGuard do poÅ‚Ä…czenia Twojej maszyny administracyjnej z prywatnÄ… sieciÄ… serwera.


```bash
python3 configure_peer.py
```

Po zakoÅ„czeniu, aktywuj tunel:

```bash
# ÅšcieÅ¼ka zostanie pokazana na koÅ„cu wyniku skryptu
sudo wg-quick up /etc/wireguard/admin_VM1/admin.conf
```

VM1, VM2, VM3 ...

PowinieneÅ› teraz mÃ³c poÅ‚Ä…czyÄ‡ siÄ™ z serwerem, uÅ¼ywajÄ…c jego wewnÄ™trznego adresu IP VPN (np. 10.200.0.1). 2, 3 ...

<br>
Zainstaluj Docker:
Ten skrypt poÅ‚Ä…czy siÄ™ z serwerem przez VPN, aby przeprowadziÄ‡ instalacjÄ™.

```bash
python3 install_docker.py
```

### Krok 4: Zainstaluj Serwer TAK

Pobierz Pliki Serwera TAK na MaszynÄ™ WirtualnÄ…:
Ten skrypt uÅ¼ywa gdown na zdalnym serwerze do pobrania wymaganego pliku zip Serwera TAK.

```bash
python3 gdown.py
```

Uruchom Instalator Serwera TAK:
To interaktywny skrypt, ktÃ³ry przeprowadzi CiÄ™ przez proces instalacji serwera TAK na zdalnej maszynie.

```bash
python3 setup.py
```

Po zakoÅ„czeniu instalacji, automatycznie skopiuje wygenerowane certyfikaty klienta na TwojÄ… lokalnÄ… maszynÄ™.

### Krok 5: Skonfiguruj KlientÃ³w

Dodaj Klienta WireGuard na Androida:
Wygeneruje to kod QR, aby Å‚atwo dodaÄ‡ nowy profil VPN do aplikacji WireGuard na urzÄ…dzeniu z Androidem. DomyÅ›lnie ten tunel jest skonfigurowany jako split-tunnel, aby oszczÄ™dzaÄ‡ bateriÄ™ i umoÅ¼liwiaÄ‡ normalne dziaÅ‚anie telefonu. MoÅ¼na go rÄ™cznie zmieniÄ‡ na full-tunnel, jeÅ›li misja tego wymaga.

```bash
python3 configure_peer_android.py
```

TwÃ³j podstawowy ekosystem serwera TAK jest teraz gotowy do dziaÅ‚ania!

</details>

---

## ğŸ‡ºğŸ‡¸ This repository provides the core infrastructure for the TAK ecosystem.

### Extended options enable automatic configuration of the MUMBLE-MURMUR server for VoIP communication using the VOICE plugin in the ATAK application.

There is also the option to run a "drone simulation" for testing with the UAS-TOOL plugin. If needed, I am also ready to undertake the first-time integration of physical drones compatible with this plugin: in the BLOX-TAK-SERVER-GCP.

### But the true power of the BLOX-TAK-SERVER-GCP ecosystem is realized in cooperation with the BLOX-TAK-SERVER-IUCP-GCP software package (IUCP - Individual User Connection Profile).

The IUCP project integrates directly with this GCP foundation and provides:

* **Automated Onboarding from Google Forms:** Automatically processes new user submissions from a Google Form or a CSV file.
* **Bulk Certificate Generation:** Generates and signs TAK .p12 client certificates for dozens of users simultaneously.
* **Automated Configuration Packaging:** Creates user-specific .zip packages containing their certificate, ATAK preferences (.pref), and other necessary files.
* **Automated Email Distribution:** Securely delivers the user package directly to their inbox using the Gmail API.
* **Advanced Maintenance:** Scripts for bulk certificate revocation and user lifecycle management.

The IUCP extension transforms an hour-long server configuration into a system where adding a new, fully prepared user takes less than a minute of automated work.

<br>
The basic version of this software, which works with physical TAK servers (locally and remotely), is available in the public repository:

https://github.com/LukeStriderGM/BLOX-TAK-SERVER-IUCP

The GCP version is reserved for the BLOX-TAK-SaaS project and will be publicly available only once I'm out of debt.

<details>

<summary>ğŸ‡µğŸ‡±</summary>

## ğŸ‡µğŸ‡± To repozytorium dostarcza podstawowÄ… infrastrukturÄ™ ekosystemu TAK.

### Opcje rozszerzone zapweniajÄ… automatycznÄ… konfiguracjÄ™ serwera MUMBLE-MURMUR dla komunikacji VoIP dla wtyczki VOICE w aplikacji ATAK.

Jest rÃ³wnieÅ¼ moÅ¼liwoÅ›Ä‡ uruchomienia "symulacji drona" do testÃ³w z wtyczkÄ… UAS-TOOL. W razie potrzeby, jestem gotowy podjÄ…Ä‡ siÄ™ rÃ³wnieÅ¼ pierwszy raz integracji dronÃ³w fizycznych - kompatybilnych z tÄ… wtyczkÄ…: w BLOX-TAK-SERVER-GCP.

### Lecz prawdziwa moc ekosystemu BLOX-TAK-SERVER-GCP jest realizowana we wspÃ³Å‚pracy z pakietem oprogramowania BLOX-TAK-SERVER-IPPU-GCP (IPPU - Indywidualny Profil PoÅ‚Ä…czeniowy UÅ¼ytkownika).

Projekt IPPU integruje siÄ™ bezpoÅ›rednio z tÄ… podstawÄ… GCP i zapewnia:

* **Automatyczny Onboarding z Formularzy Google:** Automatycznie przetwarza nowe zgÅ‚oszenia uÅ¼ytkownikÃ³w z Formularza Google lub pliku CSV.
* **Grupowe Generowanie CertyfikatÃ³w:** Generuje i podpisuje certyfikaty klienta TAK .p12 dla dziesiÄ…tek uÅ¼ytkownikÃ³w jednoczeÅ›nie.
* **Automatyczne Pakowanie Konfiguracji:** Tworzy specyficzne dla uÅ¼ytkownika pakiety .zip zawierajÄ…ce ich certyfikat, preferencje ATAK (.pref) i inne niezbÄ™dne pliki.
* **Automatyczna Dystrybucja E-mail:** Bezpiecznie dostarcza pakiet uÅ¼ytkownika bezpoÅ›rednio na jego skrzynkÄ™ odbiorczÄ… za pomocÄ… API Gmaila.
* **Zaawansowana Konserwacja:** Skrypty do masowego uniewaÅ¼niania certyfikatÃ³w i zarzÄ…dzania cyklem Å¼ycia uÅ¼ytkownika.

Rozszerzenie IPPU przeksztaÅ‚ca godzinnÄ… konfiguracjÄ™ serwera w system, w ktÃ³rym dodanie nowego, w peÅ‚ni przygotowanego uÅ¼ytkownika zajmuje mniej niÅ¼ minutÄ™ zautomatyzowanej pracy.

<br>
Podstawowa wersja tego oprogramowania ktÃ³ra wspÃ³Å‚pracuje z fizycznymi serwerami TAK (lokalnie i zdalnie), znajduje siÄ™ w publicznym repozytorium:

https://github.com/LukeStriderGM/BLOX-TAK-SERVER-IUCP

Wersja dla GCP zarezerwowana jest dla projektu BLOX-TAK-SaaS i zostanie udostÄ™pniona publicznie dopiero - gdy wydostanÄ™ siÄ™ z dÅ‚ugÃ³w. 

</details>

---

## ğŸ‡ºğŸ‡¸ Maintenance & Teardown

```bash 
python3 cleanup_vm.py
```
Runs a script on the VM to remove all TAK-related components.

<br>

```bash 
python3 destroy_vm.py
```
IRREVERSIBLE. Uses Terraform to completely destroy the virtual machine and its associated workspace. Use with caution.

<details>

<summary>ğŸ‡µğŸ‡±</summary>

## Konserwacja i DemontaÅ¼

```bash 
python3 cleanup_vm.py
```
Uruchamia na maszynie wirtualnej skrypt usuwajÄ…cy wszystkie komponenty zwiÄ…zane z TAK.

<br>

```bash 
python3 destroy_vm.py
```

NIEODWRACALNE. UÅ¼ywa Terraform do caÅ‚kowitego zniszczenia maszyny wirtualnej i jej powiÄ…zanego obszaru roboczego. UÅ¼ywaj z ostroÅ¼noÅ›ciÄ….

</details>

---

## ğŸ‡ºğŸ‡¸ Smart Auditor & Forensic Reporting

This project includes a specialized, forensic-grade auditing suite designed to generate comprehensive operational reports. The process is divided into three phases to ensure data integrity, creating a complete "Chain of Custody" for your infrastructure.

The suite generates 4 PDF variants simultaneously (EN/PL x Public/Private) and packages everything into a master ZIP file.

### Phase 1: Diagnostics & Base Report (`auditor_smart.py`)
Connects to the VM via SSH and performs a deep scan of the system.
* **Deep Docker Inspection:** Lists **all** containers (running, stopped, and failed) using `docker ps -a --no-trunc`.
* **System Metrics:** Captures real-time uptime, kernel version, and resource usage.
* **Output:** Generates the initial 2-page PDF Operational Report.

```bash
python3 auditor_smart.py
```

### Phase 2: Evidence Collection (`log_collector.py`)

Harvests logs from the remote machine and integrates them into the report.

* **Harvesting:** Collects system logs (syslog, auth.log, dmesg) and logs from every Docker container detected in Phase 1.
* **Integrity:** Downloads the logs as a .tar.gz archive and calculates the MD5 checksum.
* **In-Place Update:** Appends "Appendix A: Log Package Manifest" to the existing PDF reports, listing every captured file and its size without breaking the document structure.

```bash
python3 log_collector.py
```

### Phase 3: Finalization & Cold Storage (`report_finisher.py`)

The most critical phase. It secures the infrastructure state and network evidence.

âš ï¸ **IMPORTANT:** You must disable the WireGuard VPN before running this step to ensure direct connectivity with the Google Cloud API for snapshot management.

```bash
# 1. Disconnect VPN (Example command)
sudo wg-quick down <path_to_your_conf_file>

# 2. Run the Finisher
python3 report_finisher.py
```

* **Cold Snapshot:** Automatically stops the VM, triggers a GCP Disk Snapshot (ensuring filesystem consistency), and restarts the VM.
* **Snapshot Metrics:** Reports both the Provisioned Disk Size and the Real (Compressed) Usage.
* **Network Forensics:** Scans local directories (defined in config.yaml) for Wireshark (.pcapng) files and catalogs them.
* **Master Packaging:** Appends "Appendix B: Infrastructure & Network Security" to the PDFs and zips all reports, logs, and PCAP files into a final, timestamped `EVIDENCE_... .zip` package.


* **PORTFOLIO:** https://github.com/LukeStriderGM/BLOX-TAK-SERVER-GCP_Early_Stage_Access/BLOX_TAK_ECOSYSTEM_PORTFOLIO_EN.pdf

If you are interested in the offer, collaboration, or support, please carefully read the posts and their links:

Linkedin: https://www.linkedin.com/posts/lukebluelox_onemanarmy-nightghost-c4isr-activity-7417879471732486144-PdGU

ğ•: https://x.com/LukeStriderGM/status/2012118634022183206

<details>

<summary>ğŸ‡µğŸ‡± [Kliknij Aby RozwinÄ…Ä‡ Opis ModuÅ‚u Audytowego]</summary>

## ğŸ‡µğŸ‡± Smart Auditor i Raportowanie Åšledcze

Ten projekt zawiera specjalistyczny pakiet audytowy klasy forensic, zaprojektowany do generowania kompleksowych raportÃ³w operacyjnych. Proces jest podzielony na trzy fazy, aby zapewniÄ‡ integralnoÅ›Ä‡ danych, tworzÄ…c peÅ‚ny "ÅaÅ„cuch Dowodowy" (Chain of Custody) dla Twojej infrastruktury.

Pakiet generuje jednoczeÅ›nie 4 warianty PDF (EN/PL x Publiczny/Prywatny) i pakuje wszystko w gÅ‚Ã³wny plik ZIP.

### Faza 1: Diagnostyka i Raport Bazowy (`auditor_smart.py`)

ÅÄ…czy siÄ™ z maszynÄ… wirtualnÄ… przez SSH i przeprowadza gÅ‚Ä™bokie skanowanie systemu.

* **GÅ‚Ä™boka Inspekcja Docker:** Listuje wszystkie kontenery (dziaÅ‚ajÄ…ce, zatrzymane i po awarii) uÅ¼ywajÄ…c `docker ps -a --no-trunc`.
* **Metryki Systemowe:** Przechwytuje czas pracy (uptime), wersjÄ™ jÄ…dra i zuÅ¼ycie zasobÃ³w w czasie rzeczywistym.
* **Wynik:** Generuje wstÄ™pny, 2-stronicowy Raport Operacyjny PDF.

```bash
python3 auditor_smart.py
```

### Faza 2: Zbieranie DowodÃ³w (`log_collector.py`)

Pobiera logi ze zdalnej maszyny i integruje je z raportem.

* **Zbieranie (Harvesting):** Pobiera logi systemowe (syslog, auth.log, dmesg) oraz logi z kaÅ¼dego kontenera wykrytego w Fazie 1.
* **IntegralnoÅ›Ä‡:** Pobiera logi jako archiwum .tar.gz i oblicza sumÄ™ kontrolnÄ… MD5.
* **Aktualizacja w Miejscu:** DoÅ‚Ä…cza "ZaÅ‚Ä…cznik A: Spis ZawartoÅ›ci LogÃ³w" do istniejÄ…cych raportÃ³w PDF, listujÄ…c kaÅ¼dy przechwycony plik i jego rozmiar, zachowujÄ…c strukturÄ™ dokumentu.

```bash
python3 log_collector.py
```

### Faza 3: Finalizacja i Zimny Magazyn (`report_finisher.py`)

NajwaÅ¼niejsza faza. Zabezpiecza stan infrastruktury i dowody sieciowe.

âš ï¸ **WAÅ»NE:** Musisz wyÅ‚Ä…czyÄ‡ VPN WireGuard przed uruchomieniem tego kroku, aby zapewniÄ‡ bezpoÅ›redniÄ… Å‚Ä…cznoÅ›Ä‡ z API Google Cloud do zarzÄ…dzania snapshotami.

```bash
# 1. RozÅ‚Ä…cz VPN (PrzykÅ‚adowa komenda)
sudo wg-quick down <Å›cieÅ¼ka_do_twojego_pliku_conf>

# 2. Uruchom Finalizator
python3 report_finisher.py
```

* **Zimna Migawka (Cold Snapshot):** Automatycznie zatrzymuje VM, wyzwala MigawkÄ™ Dysku GCP (gwarantujÄ…c spÃ³jnoÅ›Ä‡ systemu plikÃ³w) i restartuje VM.
* **Metryki Migawki:** Raportuje zarÃ³wno Zaaprowizowany Rozmiar Dysku, jak i Rzeczywiste (Skompresowane) ZuÅ¼ycie.
* **Informatyka Åšledcza Sieci:** Skanuje lokalne katalogi (zdefiniowane w config.yaml) w poszukiwaniu plikÃ³w Wireshark (.pcapng) i kataloguje je.
* **GÅ‚Ã³wne Pakowanie:** DoÅ‚Ä…cza "ZaÅ‚Ä…cznik B: BezpieczeÅ„stwo i Sieci" do plikÃ³w PDF i pakuje wszystkie raporty, logi oraz pliki PCAP w finalnÄ… paczkÄ™ `EVIDENCE_... .zip` z sygnaturÄ… czasowÄ….


* **PORTFOLIO:** https://github.com/LukeStriderGM/BLOX-TAK-SERVER-GCP_Early_Stage_Access/BLOX_TAK_ECOSYSTEM_PORTFOLIO_PL.pdf

JeÅ›li jesteÅ› zainteresowany ofertÄ…, wspÃ³Å‚pracÄ… lub wsparciem -zapoznaj siÄ™ dokÅ‚adnie z treÅ›ciÄ… postÃ³w i ich linkami dla:

Linkedin: https://www.linkedin.com/posts/lukebluelox_onemanarmy-nightghost-c4isr-activity-7417879508822958080-gnkK

ğ•: https://x.com/LukeStriderGM/status/2012117712370078032

</details>

---

## ğŸ‡ºğŸ‡¸ License
This project is licensed under the MIT License. See the LICENSE file for details.

<details>

<summary>ğŸ‡µğŸ‡±</summary>

## Licencja

Ten projekt jest objÄ™ty licencjÄ… MIT. Zobacz plik LICENSE, aby uzyskaÄ‡ szczegÃ³Å‚owe informacje.

TÅ‚umaczenie [PL]:

Licencja MIT

Prawa autorskie (c) 2025 Åukasz "LukeStriderGM" Andruszkiewicz

Niniejszym udziela siÄ™ bezpÅ‚atnej zgody kaÅ¼dej osobie wchodzÄ…cej w posiadanie kopii tego oprogramowania i powiÄ…zanych z nim plikÃ³w dokumentacji (dalej â€Oprogramowanieâ€), na obchodzenie siÄ™ z Oprogramowaniem bez ograniczeÅ„, wÅ‚Ä…czajÄ…c w to bez ograniczeÅ„ prawa do uÅ¼ywania, kopiowania, modyfikowania, Å‚Ä…czenia, publikowania, dystrybucji, sublicencjonowania i/lub sprzedaÅ¼y kopii Oprogramowania, oraz na zezwolenie osobom, ktÃ³rym Oprogramowanie jest dostarczane, aby to czyniÅ‚y, pod nastÄ™pujÄ…cymi warunkami:

PowyÅ¼sza nota o prawach autorskich i ta nota o pozwoleniu muszÄ… byÄ‡ doÅ‚Ä…czone do wszystkich kopii lub istotnych czÄ™Å›ci Oprogramowania.

OPROGRAMOWANIE JEST DOSTARCZANE "TAKIM, JAKIE JEST", BEZ JAKIEJKOLWIEK GWARANCJI, WYRAÅ¹NEJ LUB DOROZUMIANEJ, WÅÄ„CZAJÄ„C W TO, ALE NIE OGRANICZAJÄ„C SIÄ˜ DO, GWARANCJI PRZYDATNOÅšCI HANDLOWEJ, PRZYDATNOÅšCI DO OKREÅšLONEGO CELU ORAZ NIENARUSZALNOÅšCI PRAW. W Å»ADNYM WYPADKU AUTORZY LUB POSIADACZE PRAW AUTORSKICH NIE BÄ˜DÄ„ ODPOWIEDZIALNI ZA JAKIEKOLWIEK ROSZCZENIA, SZKODY LUB INNE ZOBOWIÄ„ZANIA, CZY TO W WYNIKU DZIAÅANIA UMOWY, DELIKTU CZY W INNY SPOSÃ“B, WYNIKAJÄ„CE Z, LUB W ZWIÄ„ZKU Z OPROGRAMOWANIEM LUB UÅ»YCIEM LUB INNYMI DZIAÅANIAMI W OPROGRAMOWANIU.

</details>

---

## ğŸ‡ºğŸ‡¸ Code of Conduct
This project and everyone participating in it is governed by the Contributor Covenant. See the CODE_OF_CONDUCT.md file for details.

<details>
<summary>ğŸ‡µğŸ‡±</summary>

Kodeks PostÄ™powania

Ten projekt i wszyscy w nim uczestniczÄ…cy podlegajÄ… Zasadom WspÃ³Å‚twÃ³rcy (Contributor Covenant). Zobacz plik CODE_OF_CONDUCT.md, aby uzyskaÄ‡ szczegÃ³Å‚owe informacje.

TÅ‚umaczenie [PL]:


## Kodeks PostÄ™powania - Contributor Covenant

### Nasza Obietnica

Jako czÅ‚onkinie i czÅ‚onkowie, wspÃ³Å‚twÃ³rczynie i wspÃ³Å‚twÃ³rcy oraz liderki i liderzy
zobowiÄ…zujemy siÄ™, Å¼e udziaÅ‚ w naszej spoÅ‚ecznoÅ›ci bÄ™dzie wolny od nÄ™kania dla
kaÅ¼dego, bez wzglÄ™du na wiek, budowÄ™ ciaÅ‚a, widocznÄ… lub niewidocznÄ…
niepeÅ‚nosprawnoÅ›Ä‡, pochodzenie etniczne, cechy pÅ‚ciowe, toÅ¼samoÅ›Ä‡ i ekspresjÄ™
pÅ‚ciowÄ…, poziom doÅ›wiadczenia, wyksztaÅ‚cenie, status spoÅ‚eczno-ekonomiczny,
narodowoÅ›Ä‡, wyglÄ…d, rasÄ™, religiÄ™ czy toÅ¼samoÅ›Ä‡ i orientacjÄ™ seksualnÄ….

ZobowiÄ…zujemy siÄ™ do dziaÅ‚ania i interakcji w sposÃ³b, ktÃ³ry przyczynia siÄ™ do
tworzenia otwartej, przyjaznej, zrÃ³Å¼nicowanej, inkluzywnej i zdrowej spoÅ‚ecznoÅ›ci.

### Nasze Standardy

PrzykÅ‚ady zachowaÅ„, ktÃ³re przyczyniajÄ… siÄ™ do tworzenia pozytywnego Å›rodowiska
dla naszej spoÅ‚ecznoÅ›ci, obejmujÄ…:

* Okazywanie empatii i Å¼yczliwoÅ›ci wobec innych osÃ³b
* Szacunek dla odmiennych opinii, punktÃ³w widzenia i doÅ›wiadczeÅ„
* Udzielanie i taktowne przyjmowanie konstruktywnej informacji zwrotnej
* Przyjmowanie odpowiedzialnoÅ›ci, przepraszanie osÃ³b dotkniÄ™tych naszymi
    bÅ‚Ä™dami i wyciÄ…ganie z nich wnioskÃ³w
* Skupianie siÄ™ nie tylko na tym, co najlepsze dla nas jako jednostek, ale dla
    caÅ‚ej spoÅ‚ecznoÅ›ci

PrzykÅ‚ady niedopuszczalnych zachowaÅ„ obejmujÄ…:

* UÅ¼ywanie jÄ™zyka lub obrazÃ³w o charakterze seksualnym oraz wszelkiego rodzaju
    zaloty lub umizgi o charakterze seksualnym
* Trolling, obraÅºliwe lub uwÅ‚aczajÄ…ce komentarze oraz ataki osobiste lub
    polityczne
* NÄ™kanie publiczne lub prywatne
* Publikowanie prywatnych informacji innych osÃ³b, takich jak adres fizyczny lub
    mailowy, bez ich wyraÅºnej zgody
* Inne zachowania, ktÃ³re moÅ¼na by uznaÄ‡ za niewÅ‚aÅ›ciwe w Å›rodowisku
    profesjonalnym

### ObowiÄ…zki Egzekwowania Zasad

Liderki i liderzy spoÅ‚ecznoÅ›ci sÄ… odpowiedzialni za wyjaÅ›nianie i egzekwowanie
naszych standardÃ³w oraz podejmÄ… odpowiednie i sprawiedliwe dziaÅ‚ania naprawcze w
odpowiedzi na kaÅ¼de zachowanie, ktÃ³re uznajÄ… za niestosowne, zagraÅ¼ajÄ…ce,
obraÅºliwe lub szkodliwe.

Liderki i liderzy spoÅ‚ecznoÅ›ci majÄ… prawo i obowiÄ…zek usuwaÄ‡, edytowaÄ‡ lub
odrzucaÄ‡ komentarze, commity, kod, edycje wiki, zgÅ‚oszenia i inne formy wkÅ‚adu,
ktÃ³re nie sÄ… zgodne z niniejszym Kodeksem PostÄ™powania, i w razie potrzeby
przedstawiÄ… powody swoich decyzji moderacyjnych.

### Zakres

Niniejszy Kodeks PostÄ™powania obowiÄ…zuje we wszystkich przestrzeniach
spoÅ‚ecznoÅ›ci, a takÅ¼e wtedy, gdy dana osoba oficjalnie reprezentuje spoÅ‚ecznoÅ›Ä‡ w
przestrzeni publicznej. PrzykÅ‚ady reprezentowania naszej spoÅ‚ecznoÅ›ci obejmujÄ…
uÅ¼ywanie oficjalnego adresu e-mail, publikowanie postÃ³w za poÅ›rednictwem
oficjalnego konta w mediach spoÅ‚ecznoÅ›ciowych lub wystÄ™powanie w charakterze
wyznaczonej przedstawicielki lub przedstawiciela na wydarzeniu online lub offline.

### Egzekwowanie Zasad

Przypadki obraÅºliwego, nÄ™kajÄ…cego lub w inny sposÃ³b niedopuszczalnego zachowania
mogÄ… byÄ‡ zgÅ‚aszane liderkom i liderom spoÅ‚ecznoÅ›ci odpowiedzialnym za egzekwowanie
zasad pod adresem **luke.strider.gm@gmail.com**.
Wszystkie skargi zostanÄ… rozpatrzone i zbadane niezwÅ‚ocznie i sprawiedliwie.

Wszystkie liderki i liderzy spoÅ‚ecznoÅ›ci sÄ… zobowiÄ…zani do poszanowania prywatnoÅ›ci i
bezpieczeÅ„stwa osoby zgÅ‚aszajÄ…cej incydent.

### Wytyczne DotyczÄ…ce Egzekwowania Zasad

Liderki i liderzy spoÅ‚ecznoÅ›ci bÄ™dÄ… postÄ™powaÄ‡ zgodnie z niniejszymi Wytycznymi
DotyczÄ…cymi WpÅ‚ywu na SpoÅ‚ecznoÅ›Ä‡ przy okreÅ›laniu konsekwencji za kaÅ¼de
dziaÅ‚anie, ktÃ³re uznajÄ… za naruszenie niniejszego Kodeksu PostÄ™powania:

### 1. Naprawienie

**WpÅ‚yw na SpoÅ‚ecznoÅ›Ä‡**: UÅ¼ywanie niestosownego jÄ™zyka lub inne zachowanie uznane
za nieprofesjonalne lub niemile widziane w spoÅ‚ecznoÅ›ci.

**Konsekwencja**: Prywatne, pisemne upomnienie od liderek lub liderÃ³w spoÅ‚ecznoÅ›ci,
wyjaÅ›niajÄ…ce naturÄ™ naruszenia i powÃ³d, dla ktÃ³rego zachowanie byÅ‚o
niestosowne. MoÅ¼e zostaÄ‡ zaÅ¼Ä…dane publiczne przeproszenie.

### 2. OstrzeÅ¼enie

**WpÅ‚yw na SpoÅ‚ecznoÅ›Ä‡**: Naruszenie w wyniku pojedynczego incydentu lub serii
dziaÅ‚aÅ„.

**Konsekwencja**: OstrzeÅ¼enie z konsekwencjami za dalsze zachowanie. Zakaz
interakcji z osobami zaangaÅ¼owanymi, w tym nieproszonych interakcji z osobami
egzekwujÄ…cymi Kodeks PostÄ™powania, przez okreÅ›lony czas. Obejmuje to unikanie
interakcji w przestrzeniach spoÅ‚ecznoÅ›ci, jak i na kanaÅ‚ach zewnÄ™trznych, takich
jak media spoÅ‚ecznoÅ›ciowe. Naruszenie tych warunkÃ³w moÅ¼e prowadziÄ‡ do
tymczasowego lub staÅ‚ego bana.

### 3. Tymczasowy Ban

**WpÅ‚yw na SpoÅ‚ecznoÅ›Ä‡**: PowaÅ¼ne naruszenie standardÃ³w spoÅ‚ecznoÅ›ci, w tym
utrzymujÄ…ce siÄ™ niestosowne zachowanie.

**Konsekwencja**: Tymczasowy zakaz jakichkolwiek interakcji lub publicznej
komunikacji ze spoÅ‚ecznoÅ›ciÄ… na okreÅ›lony czas. W tym okresie zabronione sÄ…
publiczne i prywatne interakcje z osobami zaangaÅ¼owanymi, w tym nieproszone
interakcje z osobami egzekwujÄ…cymi Kodeks PostÄ™powania. Naruszenie tych
warunkÃ³w moÅ¼e prowadziÄ‡ do staÅ‚ego bana.

### 4. StaÅ‚y Ban

**WpÅ‚yw na SpoÅ‚ecznoÅ›Ä‡**: Wykazywanie wzorca naruszania standardÃ³w spoÅ‚ecznoÅ›ci,
w tym utrzymujÄ…ce siÄ™ niestosowne zachowanie, nÄ™kanie danej osoby lub agresja
wobec lub oczernianie grup osÃ³b.

**Konsekwencja**: StaÅ‚y zakaz jakichkolwiek publicznych interakcji w ramach
spoÅ‚ecznoÅ›ci.

---
Atrybucja

Niniejszy Kodeks PostÄ™powania jest adaptacjÄ… [Contributor Covenant][homepage],
wersja 2.1, dostÄ™pnej pod adresem
[https://www.contributor-covenant.org/version/2/1/code_of_conduct.html][v2.1].

[homepage]: https://www.contributor-covenant.org
[v2.1]: https://www.contributor-covenant.org/version/2/1/code_of_conduct.html

---

</details>
--- END FILE: README.md ---

--- START FILE: SECURITY.md ---
# Security Policy

### Supported Versions

| Version | Supported |
| :--- | :--- |
| 1.0.0.1 | :white_check_mark: |

### Reporting a Vulnerability

#### [INCIDENT DOCS - GitHUB](https://github.com/LukeStriderGM/BLOX-TAK-SERVER-GCP_Early_Stage_Access/tree/master/INCIDENTS)
#### [INCIDENT DOCS - GoogleDrive](https://drive.google.com/drive/folders/1DIs_7qLvylskWJz5AfjN15lrO8ZnhSQx)

EN: https://www.linkedin.com/posts/lukebluelox_security-incident-analysis-and-action-plan-activity-7355203415456595968-vCLE

PL: https://www.linkedin.com/posts/lukebluelox_analiza-incydentu-bezpiecze%C5%84stwa-i-plan-dzia%C5%82ania-activity-7355204039061516288-Kf-P

--- END FILE: SECURITY.md ---

--- START FILE: auditor_smart.py ---
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import subprocess
import yaml
import datetime
from fpdf import FPDF
from fpdf.enums import XPos, YPos

# --- CONFIGURATION & CONSTANTS ---
# --- KONFIGURACJA I STAÅE ---

CONFIG_FILE = 'config.yaml'

FONTS = {
    'R': "UbuntuMono-Regular.ttf",
    'B': "UbuntuMono-Bold.ttf",
    'I': "UbuntuMono-Italic.ttf"
}

SEP = "|||SECRET_DELIMITER|||"
REDACT_CHAR = "â–ˆ"

TEXTS = {
    'EN': {
        'file_prefix': "REPORT",
        'public_suffix': "_PUBLIC",
        'title': "OPERATIONAL REPORT",
        'footer': "Generated by Smart Auditor",
        'sec1': "1. OPERATION METRICS",
        'sec2': "2. SYSTEM HEALTH & RESOURCES",
        'sec3': "3. DOCKER SERVICES & CONTAINERS",
        'sec4': "4. LOGS & ARTIFACTS",
        'dock_name': "CONTAINER NAME", 'dock_status': "STATUS", 'dock_ports': "PORTS / INFO",
        'no_dock': "No running containers detected.", 'status_ok': "[ SYSTEM STATUS: ONLINE & SECURE ]",
        'logs_info': "Logs collected: PENDING (See Phase 2)",
        'labels': {
            'date': "Audit Date:", 'operator': "Operator:", 'target': "Target (VM):",
            'wan': "Host (WAN IP):", 'lan': "Host (LAN IP):", 'loc': "GCP Location:",
            'type': "Machine Type:", 'host': "Hostname:", 'os': "System:",
            'kernel': "Kernel:", 'up': "Uptime:", 'ram': "RAM Usage:", 'disk': "Disk Usage:"
        }
    },
    'PL': {
        'file_prefix': "RAPORT",
        'public_suffix': "_PUBLICZNY",
        'title': "RAPORT OPERACYJNY",
        'footer': "Wygenerowano przez Smart Auditor",
        'sec1': "1. METRYKA OPERACJI",
        'sec2': "2. STATUS ZASOBÃ“W SYSTEMOWYCH",
        'sec3': "3. USÅUGI DOCKER I KONTENERY",
        'sec4': "4. LOGI I ARTEFAKTY",
        'dock_name': "NAZWA KONTENERA", 'dock_status': "STATUS", 'dock_ports': "PORTY / INFO",
        'no_dock': "Nie wykryto uruchomionych kontenerÃ³w.", 'status_ok': "[ STATUS SYSTEMU: AKTYWNY I BEZPIECZNY ]",
        'logs_info': "Logi systemowe: OCZEKIWANIE (Patrz Faza 2)",
        'labels': {
            'date': "Data audytu:", 'operator': "Operator:", 'target': "Cel (VM):",
            'wan': "Adres (WAN IP):", 'lan': "Adres (LAN IP):", 'loc': "Lokalizacja GCP:",
            'type': "Typ Maszyny:", 'host': "Nazwa Hosta:", 'os': "System:",
            'kernel': "JÄ…dro:", 'up': "Czas pracy:", 'ram': "ZuÅ¼ycie RAM:", 'disk': "ZuÅ¼ycie Dysku:"
        }
    }
}

# --- HELPER FUNCTIONS ---
# --- FUNKCJE POMOCNICZE ---

def load_config():
    # Check if config file exists
    # SprawdÅº, czy plik konfiguracyjny istnieje
    if not os.path.exists(CONFIG_FILE): return None
    
    # Load and parse YAML file
    # Wczytaj i przetwÃ³rz plik YAML
    with open(CONFIG_FILE, 'r', encoding='utf-8') as f: return yaml.safe_load(f)

def run_ssh_command_capture(host_ip, user, command):
    # Prepare SSH command with options
    # Przygotuj komendÄ™ SSH z opcjami
    full_command = ['ssh', '-o', 'StrictHostKeyChecking=no', '-o', 'ConnectTimeout=10', f'{user}@{host_ip}', command]
    
    try:
        # Execute command and capture output
        # Wykonaj komendÄ™ i przechwyÄ‡ wyjÅ›cie
        res = subprocess.run(full_command, capture_output=True, text=True)
        if res.returncode != 0:
            print(f"âŒ SSH ERROR: {res.stderr.strip()}")
            print(f"âŒ BÅÄ„D SSH: {res.stderr.strip()}")
            return None
        return res.stdout.strip()
    except Exception as e:
        print(f"âŒ SSH EXCEPTION: {e}")
        print(f"âŒ WYJÄ„TEK SSH: {e}")
        return None

def parse_output(raw):
    # Initialize data dictionary
    # Inicjalizuj sÅ‚ownik danych
    data = {}
    if not raw: return data
    
    curr, buf = None, []
    # Iterate through lines to parse sections
    # Iteruj przez linie, aby przetworzyÄ‡ sekcje
    for line in raw.splitlines():
        if line.startswith(SEP):
            if curr: data[curr] = "\n".join(buf).strip()
            curr = line.replace(SEP, "").strip(); buf = []
        else: buf.append(line)
    if curr: data[curr] = "\n".join(buf).strip()
    return data

def redact(text, is_public, mode='full'):
    # Return original text if not public
    # ZwrÃ³Ä‡ oryginalny tekst, jeÅ›li nie jest publiczny
    if not is_public: return text
    
    # Apply full redaction
    # Zastosuj peÅ‚nÄ… redakcjÄ™
    if mode == 'full': return REDACT_CHAR * 10
    
    # Apply IP address redaction
    # Zastosuj redakcjÄ™ adresu IP
    if mode == 'ip': return f"{REDACT_CHAR*3}.{REDACT_CHAR*3}.{REDACT_CHAR*3}.{REDACT_CHAR*3}"
    return text

# --- PDF GENERATION CLASS ---
# --- KLASA GENEROWANIA PDF ---

class PDFReport(FPDF):
    def __init__(self, vm_name, lang='EN'):
        super().__init__()
        self.vm_name = vm_name
        self.lang = lang
        self.t = TEXTS[lang]

    def header(self):
        # Set font and create title
        # Ustaw czcionkÄ™ i utwÃ³rz tytuÅ‚
        self.set_font('UbuntuMono', 'B', 14)
        self.cell(0, 10, f"{self.t['title']}: {self.vm_name}", new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='C')
        self.line(10, 25, 200, 25)
        self.ln(10)

    def footer(self):
        # Position footer at bottom
        # Ustaw stopkÄ™ na dole
        self.set_y(-15)
        self.set_font('UbuntuMono', 'I', 8)
        self.cell(0, 10, f"{self.t['footer']} | {datetime.datetime.now().strftime('%Y-%m-%d %H:%M')} | {self.lang}", align='C')

    def print_row(self, data, widths, fill=False):
        # Calculate row height dynamically
        # Oblicz wysokoÅ›Ä‡ wiersza dynamicznie
        font_size = self.font_size_pt / 72 * 25.4
        line_height = font_size * 1.5
        max_lines = 1
        
        for i, text in enumerate(data):
            lines = self.multi_cell(widths[i], line_height, str(text), dry_run=True, output="LINES")
            max_lines = max(max_lines, len(lines))
        
        row_height = max_lines * line_height

        # Add page break if needed
        # Dodaj podziaÅ‚ strony w razie potrzeby
        if self.get_y() + row_height > self.page_break_trigger:
            self.add_page()

        x_start, y_start = self.get_x(), self.get_y()

        # Draw background if fill is enabled
        # Rysuj tÅ‚o, jeÅ›li wypeÅ‚nienie jest wÅ‚Ä…czone
        if fill:
            self.set_fill_color(220, 220, 220)
            self.rect(x_start, y_start, sum(widths), row_height, 'F')
        
        curr_x = x_start
        for i, text in enumerate(data):
            w = widths[i]
            self.set_xy(curr_x, y_start)
            self.multi_cell(w, line_height, str(text), border=0, align='L')
            self.rect(curr_x, y_start, w, row_height)
            curr_x += w

        self.set_xy(x_start, y_start + row_height)

def generate_pdf(vm_name, evidence, ext_ip, int_ip, lang, is_public):
    t = TEXTS[lang]
    l = t['labels']
    pdf = PDFReport(vm_name, lang)
    
    try:
        # Add fonts support
        # Dodaj obsÅ‚ugÄ™ czcionek
        pdf.add_font('UbuntuMono', '', FONTS['R'])
        pdf.add_font('UbuntuMono', 'B', FONTS['B'])
        pdf.add_font('UbuntuMono', 'I', FONTS['I'])
        font = 'UbuntuMono'
    except:
        font = 'Courier'
    
    pdf.add_page()
    pdf.set_font(font, size=10)

    # 1. METRICS
    # 1. METRYKI
    pdf.set_font(font, 'B', 12)
    pdf.cell(0, 8, t['sec1'], new_x=XPos.LMARGIN, new_y=YPos.NEXT)
    
    m_data = [
        (l['date'], datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')),
        (l['operator'], redact("Night Ghost", is_public)),
        (l['target'], vm_name),
        (l['wan'], redact(ext_ip, is_public, 'ip')),
        (l['lan'], redact(int_ip, is_public, 'ip') + " (SECURE SSH)"),
        (l['loc'], evidence.get('GCP_ZONE', 'Unknown')),
        (l['type'], evidence.get('GCP_MACHINE', 'Unknown'))
    ]

    pdf.set_font(font, '', 10)
    w_metrics = [60, 130]
    for label, val in m_data:
        pdf.print_row([label, val], w_metrics)
    pdf.ln(5)

    # 2. SYSTEM
    # 2. SYSTEM
    pdf.set_font(font, 'B', 12)
    pdf.cell(0, 8, t['sec2'], new_x=XPos.LMARGIN, new_y=YPos.NEXT)
    
    ram = evidence.get('MEMORY', 'N/A').split()
    r_dsp = f"{ram[2]}/{ram[1]} used" if len(ram)>2 else "N/A"
    dsk = evidence.get('DISK', 'N/A').split()
    d_dsp = f"{dsk[4]} of {dsk[1]}" if len(dsk)>4 else "N/A"

    s_data = [
        (l['host'], evidence.get('HOSTNAME', 'N/A')),
        (l['os'], evidence.get('DISTRO', 'N/A').strip()),
        (l['kernel'], redact(evidence.get('KERNEL', 'N/A'), is_public)),
        (l['up'], evidence.get('UPTIME', 'N/A')),
        (l['ram'], r_dsp),
        (l['disk'], d_dsp)
    ]

    pdf.set_font(font, '', 10)
    for label, val in s_data:
        pdf.print_row([label, val], w_metrics)
    pdf.ln(5)

    # 3. DOCKER
    # 3. DOCKER
    pdf.set_font(font, 'B', 12)
    pdf.cell(0, 8, t['sec3'], new_x=XPos.LMARGIN, new_y=YPos.NEXT)
    
    w_dock = [60, 35, 95]
    pdf.set_font(font, 'B', 9)
    pdf.print_row([t['dock_name'], t['dock_status'], t['dock_ports']], w_dock, fill=True)
    
    pdf.set_font(font, '', 8)
    docker_raw = evidence.get('DOCKER', '')
    has_cont = False
    
    if docker_raw:
        for row in docker_raw.splitlines():
            if not row.strip(): continue
            parts = row.split('|')
            if len(parts) >= 3:
                has_cont = True
                name, stat, ports = parts[0], parts[1], parts[2]
                if is_public:
                    ports = ports.replace("0.0.0.0", "XXX.XXX.XXX.XXX")
                pdf.print_row([name, stat, ports], w_dock)
    
    if not has_cont:
         pdf.cell(190, 6, t['no_dock'], border=1, new_x=XPos.LMARGIN, new_y=YPos.NEXT)

    # 4. LOGS
    # 4. LOGI
    pdf.ln(5)
    pdf.set_font(font, 'B', 12)
    pdf.cell(0, 8, t['sec4'], new_x=XPos.LMARGIN, new_y=YPos.NEXT)
    pdf.set_font(font, '', 10)
    pdf.cell(0, 5, t['logs_info'], new_x=XPos.LMARGIN, new_y=YPos.NEXT)
    pdf.ln(5)
    pdf.set_font(font, 'B', 11)
    pdf.cell(0, 10, t['status_ok'], new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='R')

    # PREFIX / SUFFIX
    # PREFIKS / SUFIKS
    prefix = t['file_prefix']
    ts = datetime.datetime.now().strftime('%Y%m%d_%H%M')
    
    suffix = ""
    if is_public:
        if lang == 'PL': suffix = "_PUBLICZNY"
        else: suffix = "_PUBLIC"

    filename = f"{prefix}_{vm_name}_{ts}_{lang}{suffix}.pdf"
    
    # Save file and notify user
    # Zapisz plik i powiadom uÅ¼ytkownika
    pdf.output(filename)
    vis = "ğŸ™ˆ PUBLIC" if is_public else "ğŸ”’ PRIVATE"
    print(f"âœ… Generated [{lang}][{vis}]: {filename}")
    print(f"âœ… Wygenerowano [{lang}][{vis}]: {filename}")
    return filename

# --- MAIN EXECUTION ---
# --- GÅÃ“WNE WYKONANIE ---

def main():
    # Clear terminal screen
    # WyczyÅ›Ä‡ ekran terminala
    os.system("clear || cls")
    
    print("=" * 60)
    print("=== SMART AUDITOR v12.1 (USER FIX) ===")
    print("=== SMART AUDITOR v12.1 (POPRAWKA UÅ»YTKOWNIKA) ===")
    print("=" * 60)
    
    config = load_config()
    if not config: return

    vms = {k: v for k, v in config.items() if isinstance(v, dict) and 'name' in v and k != 'LOCAL_CONFIG'}
    
    print("\nAvailable VMs:")
    print("DostÄ™pne VM:")
    for k, v in vms.items(): print(f"  [{k}] {v['name']}")

    print("\nEnter VM Key:")
    print("WprowadÅº klucz VM:")
    key = input("> ").strip().upper()
    
    if key not in vms: return
    vm = vms[key]
    
    # Configure user connection details
    # Skonfiguruj szczegÃ³Å‚y poÅ‚Ä…czenia uÅ¼ytkownika
    user = vm.get('user', 'blox_tak_server_admin')
    int_ip = vm.get('internal_ip')
    ext_ip = vm.get('external_ip', 'Unknown')
    
    print(f"   (Connecting as: {user}@{int_ip})")
    print(f"   (ÅÄ…czenie jako: {user}@{int_ip})")

    # Define remote script with -a and --no-trunc flags for Docker
    # Zdefiniuj zdalny skrypt z flagami -a i --no-trunc dla Dockera
    script = (
        f"echo '{SEP}HOSTNAME'; hostname; "
        f"echo '{SEP}UPTIME'; uptime -p; "
        f"echo '{SEP}KERNEL'; uname -sr; "
        f"echo '{SEP}DISTRO'; lsb_release -d | cut -f2; "
        f"echo '{SEP}DISK'; df -h / | grep /$; "
        f"echo '{SEP}MEMORY'; free -h | grep Mem; "
        f"echo '{SEP}GCP_ZONE'; curl -s -H 'Metadata-Flavor: Google' http://metadata.google.internal/computeMetadata/v1/instance/zone | rev | cut -d/ -f1 | rev; "
        f"echo '{SEP}GCP_MACHINE'; curl -s -H 'Metadata-Flavor: Google' http://metadata.google.internal/computeMetadata/v1/instance/machine-type | rev | cut -d/ -f1 | rev; "
        f"echo '{SEP}DOCKER'; sudo docker ps -a --no-trunc --format '{{{{.Names}}}}|{{{{.Status}}}}|{{{{.Ports}}}}'"
    )

    print(f"\nğŸš€ Auditing {vm['name']}...")
    print(f"ğŸš€ Audytowanie {vm['name']}...")
    
    raw = run_ssh_command_capture(int_ip, user, script)
    if not raw:
        print("âŒ CRITICAL: SSH Failed. Check if key is loaded (ssh-add).")
        print("âŒ KRYTYCZNE: BÅ‚Ä…d SSH. SprawdÅº czy klucz jest zaÅ‚adowany (ssh-add).")
        return

    evidence = parse_output(raw)
    
    print("\nğŸ“„ Generating Reports (4 variants)...")
    print("\nğŸ“„ Generowanie RaportÃ³w (4 warianty)...")
    
    for is_public in [False, True]:
        generate_pdf(vm['name'], evidence, ext_ip, int_ip, 'EN', is_public)
        generate_pdf(vm['name'], evidence, ext_ip, int_ip, 'PL', is_public)

    print("\n" + "=" * 60)
    print("âœ… PROCESS COMPLETE")
    print("âœ… PROCES ZAKOÅƒCZONY")
    print("=" * 60)

if __name__ == "__main__":
    main()

--- END FILE: auditor_smart.py ---

--- START FILE: bundle_project.py ---
import os
import datetime

# =====================================================================================
# === CONFIGURATION ===
# === KONFIGURACJA ===
# =====================================================================================

# English: Set your project version here. It will be used in the output filename.
# Polski:  Ustaw tutaj wersjÄ™ swojego projektu. Zostanie ona uÅ¼yta w nazwie pliku wyjÅ›ciowego.
VERSION = "1.0.0.2"

# List of directories to absolutely exclude from the bundling process.
# Lista katalogÃ³w do bezwzglÄ™dnego wykluczenia z procesu pakowania.
DIRECTORIES_TO_EXCLUDE = {
    '.git',
    '.idea',
    '.venv',
    'venv',
    'env',
    '__pycache__',
    '.terraform',
    'terraform.tfstate.d',
    'gcp_tak_certs'
}

# List of specific files to exclude (e.g., configuration files with passwords).
# Lista konkretnych plikÃ³w do wykluczenia (np. pliki konfiguracyjne z hasÅ‚ami).
FILES_TO_EXCLUDE = {
    'token.json',
    'client_secret.json',
    'config.yaml',
    '.terraform.lock.hcl'
}

# List of file extensions to be ignored.
# Lista rozszerzeÅ„ plikÃ³w, ktÃ³re majÄ… byÄ‡ ignorowane.
EXTENSIONS_TO_EXCLUDE = {
    '.p12',
    '.zip',
    '.png',
    '.log',
    '.tmp',
    '.pdf'
}


# =====================================================================================
# === MAIN SCRIPT LOGIC ===
# === GÅÃ“WNA LOGIKA SKRYPTU ===
# =====================================================================================

def bundle_project_files():
    """
    Walks through the project directory, collects the content of all allowed
    files, and saves them into a single, large text file.

    Przechodzi przez katalog projektu, zbiera zawartoÅ›Ä‡ wszystkich dozwolonych
    plikÃ³w i zapisuje je w jednym, duÅ¼ym pliku tekstowym.
    """
    project_root = os.path.abspath(os.path.dirname(__file__))
    project_name = os.path.basename(project_root)

    # --- ZMIANA: Dynamiczne tworzenie nazwy pliku wyjÅ›ciowego ---
    # --- CHANGE: Dynamically create the output filename ---
    output_filename = f"{project_name}_{VERSION}_bundle.txt"

    print("Starting project bundling...")
    print("Rozpoczynam pakowanie projektu...")
    print(f"Root directory: {project_root}")
    print(f"Katalog gÅ‚Ã³wny: {project_root}")
    print(f"Output file: {output_filename}\n")
    print(f"Plik wyjÅ›ciowy: {output_filename}\n")

    try:
        with open(output_filename, 'w', encoding='utf-8') as bundle_file:
            bundle_file.write(f"Project Bundle: {project_name}\n")
            bundle_file.write(f"Version: {VERSION}\n")
            bundle_file.write(f"Generated on: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            bundle_file.write("=" * 40 + "\n\n")

            for root, dirs, files in os.walk(project_root, topdown=True):
                dirs[:] = [d for d in dirs if d not in DIRECTORIES_TO_EXCLUDE]

                for filename in sorted(files):
                    # --- ZMIANA: Sprawdzanie dynamicznej nazwy pliku wyjÅ›ciowego ---
                    # --- CHANGE: Check against the dynamic output filename ---
                    if filename == output_filename or filename in FILES_TO_EXCLUDE or any(filename.endswith(ext) for ext in EXTENSIONS_TO_EXCLUDE):
                        print(f"--- Skipping file: {filename}")
                        print(f"--- Pomijam plik: {filename}")
                        continue

                    file_path = os.path.join(root, filename)
                    relative_path = os.path.relpath(file_path, project_root)

                    print(f"+++ Adding file: {relative_path}")
                    print(f"+++ DodajÄ™ plik: {relative_path}")

                    bundle_file.write(f"--- START FILE: {relative_path} ---\n")
                    try:
                        with open(file_path, 'r', encoding='utf-8', errors='ignore') as source_file:
                            bundle_file.write(source_file.read())
                    except Exception as e:
                        bundle_file.write(f"\n[ERROR READING FILE / BÅÄ„D ODCZYTU PLIKU: {e}]\n")
                    bundle_file.write(f"\n--- END FILE: {relative_path} ---\n\n")

        print("\nProject bundling completed successfully!")
        print("Pakowanie projektu zakoÅ„czone pomyÅ›lnie!")
        print(f"The result has been saved to the file: {output_filename}")
        print(f"Wynik zostaÅ‚ zapisany w pliku: {output_filename}")

    except IOError as e:
        print(f"\nERROR: Could not write to the output file: {e}")
        print(f"BÅÄ„D: Nie moÅ¼na zapisaÄ‡ pliku wyjÅ›ciowego: {e}")
    except Exception as e:
        print(f"\nERROR: An unexpected error occurred: {e}")
        print(f"BÅÄ„D: WystÄ…piÅ‚ nieoczekiwany problem: {e}")


if __name__ == "__main__":
    bundle_project_files()

--- END FILE: bundle_project.py ---

--- START FILE: cleanup_vm.py ---
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# =====================================================================================
# === REMOTE CLEANUP SCRIPT (v4.0 - Centralized Variables) ===
# === SKRYPT ZDALNEGO CZYSZCZENIA INSTALACJI (v4.0 - Zmienne Scentralizowane) ===
# =====================================================================================

import os
import subprocess
import yaml
import sys

# --- Configuration ---
# --- Konfiguracja ---
CONFIG_FILE = 'config.yaml'


# =====================================================================================
# === HELPER FUNCTIONS (bez zmian) ===
# === FUNKCJE POMOCNICZE (no changes) ===
# =====================================================================================

def run_ssh_command(host_ip, user, command, interactive=False):
    """
    English: Runs a command on a remote machine over VPN.
    Polski:  Uruchamia polecenie na zdalnej maszynie przez VPN.
    """
    tty_flag = ['-t'] if interactive else []
    full_command = ['ssh', *tty_flag, '-o', 'StrictHostKeyChecking=no', '-o', 'ConnectTimeout=10', f'{user}@{host_ip}',
                    command]

    if interactive:
        print(f"\nğŸ”„ Connecting to '{host_ip}' to run the cleanup script...")
        print(f"ğŸ”„ ÅÄ…czenie z '{host_ip}' w celu uruchomienia skryptu czyszczÄ…cego...")
        print(f"   COMMAND: {command}")
        print("-" * 60)
        print(">>> Starting SSH session. All output below is from the server. <<<")
        print(">>> Rozpoczynanie sesji SSH. Wszystkie poniÅ¼sze dane pochodzÄ… z serwera. <<<")
        print("-" * 60)
    else:
        print(f"\nğŸ”„ Executing command on '{host_ip}': {command}")
        print(f"ğŸ”„ Wykonywanie polecenia na '{host_ip}': {command}")

    try:
        process = subprocess.run(full_command, check=False)
        return process.returncode
    except Exception as e:
        print(f"\nâŒ An unexpected error occurred during SSH: {e}")
        print(f"âŒ WystÄ…piÅ‚ nieoczekiwany bÅ‚Ä…d podczas SSH: {e}")
        return 1


def load_config():
    """
    English: Loads the main configuration file.
    Polski:  Wczytuje gÅ‚Ã³wny plik konfiguracyjny.
    """
    if not os.path.exists(CONFIG_FILE):
        print(f"âŒ Configuration file '{CONFIG_FILE}' not found.")
        print(f"âŒ Plik konfiguracyjny '{CONFIG_FILE}' nie zostaÅ‚ znaleziony.")
        return None
    try:
        with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
            return yaml.safe_load(f)
    except (IOError, yaml.YAMLError) as e:
        print(f"âŒ Error loading configuration file '{CONFIG_FILE}': {e}")
        print(f"âŒ BÅ‚Ä…d Å‚adowania pliku konfiguracyjnego '{CONFIG_FILE}': {e}")
        return None


# =====================================================================================
# === MAIN SCRIPT LOGIC (ZMODYFIKOWANA / MODIFIED) ===
# =====================================================================================

def main():
    os.system("clear || cls")
    print("=" * 60)
    print("=== TAK SERVER VM CLEANUP SCRIPT (v4.0) ===")
    print("=== SKRYPT CZYSZCZENIA INSTALACJI TAK SERVER NA VM (v4.0) ===")
    print("=" * 60)

    config = load_config()
    if not config: return

    # --- Krok 1: Wczytaj ustawienia ---
    global_settings = config.get('GLOBAL_SETTINGS', {})
    vm_settings = global_settings.get('vm', {})
    if not vm_settings:
        print("\nâŒ ERROR: Section 'GLOBAL_SETTINGS.vm' not found in config.yaml.")
        print("âŒ BÅÄ„D: Sekcja 'GLOBAL_SETTINGS.vm' nie zostaÅ‚a znaleziona w pliku config.yaml.")
        return

    ADMIN_USER = vm_settings.get('admin_user', 'blox_tak_server_admin')

    # --- Krok 2: Wybierz serwer do wyczyszczenia ---
    servers = {k: v for k, v in config.items() if isinstance(v, dict) and 'name' in v}
    if not servers:
        print(f"\nâŒ No server configurations found in '{CONFIG_FILE}'.")
        print(f"âŒ Nie znaleziono konfiguracji serwerÃ³w w pliku '{CONFIG_FILE}'.")
        return

    print("\nAvailable servers to clean up:")
    print("DostÄ™pne serwery do wyczyszczenia:")
    for key, data in servers.items():
        print(f"  - {key}: {data['name']}")

    server_key = input("\nSelect the server to clean up:\nWybierz serwer, ktÃ³ry chcesz wyczyÅ›ciÄ‡:\n> ").strip().upper()
    if server_key not in servers:
        print(f"\nâŒ ERROR: Key '{server_key}' not found.")
        print(f"âŒ BÅÄ„D: Klucz '{server_key}' nie zostaÅ‚ znaleziony.")
        return

    server_data = servers[server_key]
    ssh_host_ip = server_data.get('internal_ip')

    if not ssh_host_ip:
        print(f"\nâŒ ERROR: Missing 'internal_ip' for VM '{server_key}'. A VPN connection is required.")
        print(f"âŒ BÅÄ„D: Brak 'internal_ip' dla maszyny '{server_key}'. Wymagane jest poÅ‚Ä…czenie VPN.")
        return

    # --- Krok 3: Uruchom polecenie czyszczÄ…ce ---
    cleanup_command = f"sudo bash -c 'cd /home/{ADMIN_USER}/tak-server && chmod +x scripts/cleanup.sh && ./scripts/cleanup.sh'"
    return_code = run_ssh_command(ssh_host_ip, ADMIN_USER, cleanup_command, interactive=True)

    print("\n" + "=" * 60)
    if return_code == 0:
        print("âœ¨ CLEANUP FINISHED SUCCESSFULLY!")
        print("âœ¨ CZYSZCZENIE ZAKOÅƒCZONE POMYÅšLNIE!")
    else:
        print("âŒ CLEANUP FINISHED WITH AN ERROR.")
        print("âŒ CZYSZCZENIE ZAKOÅƒCZONE BÅÄ˜DEM.")
        print("âŒ Check the messages above to diagnose the issue.")
        print("âŒ SprawdÅº powyÅ¼sze komunikaty, aby zdiagnozowaÄ‡ problem.")
    print("=" * 60)


if __name__ == '__main__':
    main()
--- END FILE: cleanup_vm.py ---

--- START FILE: config-example.yaml ---
# ======================================================
# === Main Configuration File for BLOX-TAK-SERVER-GCP ===
# === GÅ‚Ã³wny Plik Konfiguracyjny BLOX-TAK-SERVER-GCP ===
# ======================================================
#
# English: Fill in the variables below before running the scripts.
#          Copy this file to config.yaml and edit it.
#          The config.yaml file is ignored by Git.
#
# Polski:  UzupeÅ‚nij poniÅ¼sze zmienne przed uruchomieniem skryptÃ³w.
#          Skopiuj ten plik do config.yaml i edytuj go.
#          Plik config.yaml jest ignorowany przez Git.

# --- Local Settings ---
# --- Ustawienia Lokalne ---
LOCAL_CONFIG:
  # English: Sudo password for your local admin machine.
  # Polski:  HasÅ‚o do sudo na Twojej lokalnej maszynie administracyjnej.
  password: 'YOUR_SUDO_PASSWORD'
  
# --- Local File Paths (User specific) ---
# --- Lokalne ÅšcieÅ¼ki PlikÃ³w (Specyficzne dla uÅ¼ytkownika) ---
LOCAL_PATHS:
  # English: List of local directories containing .pcapng files to be included in the report.
  #          Use absolute paths or ~ for home directory.
  # Polski:  Lista lokalnych katalogÃ³w zawierajÄ…cych pliki .pcapng do doÅ‚Ä…czenia do raportu.
  #          UÅ¼yj peÅ‚nych Å›cieÅ¼ek lub ~ dla katalogu domowego.
  pcap_directories:
    - "~/Path/To/Your/Pcap/Folder_1"
    - "~/Path/To/Your/Pcap/Folder_2"
  
  # English: Directory where generated reports and logs will be stored.
  # Polski:  Katalog, w ktÃ³rym bÄ™dÄ… zapisywane wygenerowane raporty i logi.
  evidence_output_dir: "evidence"

# --- Global Project Settings ---
# --- Ustawienia Globalne Projektu ---
# English: Used by all scripts to configure the environment in GCP and on the server.
# Polski:  UÅ¼ywane przez wszystkie skrypty do konfiguracji Å›rodowiska w GCP i na serwerze.
GLOBAL_SETTINGS:
  # English: Google Cloud project settings.
  # Polski:  Ustawienia projektu Google Cloud.
  gcp:
    project_id: 'your-gcp-project-id'
    region: 'europe-central2'
    zone: 'europe-central2-c'

  # English: Virtual machine specification.
  # Polski:  Specyfikacja maszyny wirtualnej.
  vm:
    machine_type: 'e2-standard-4'
    disk_image: 'projects/ubuntu-os-cloud/global/images/ubuntu-2204-jammy-v20250701'
    disk_size_gb: 40
    disk_type: 'pd-ssd'
    admin_user: 'blox_tak_server_admin'

  # English: WireGuard VPN network settings.
  # Polski:  Ustawienia sieci WireGuard VPN.
  vpn:
    server_subnet: '10.200.0.0/24'
    admin_ip: '10.100.0.1/32'
    # English: The last octet will be added automatically for new clients.
    # Polski:  Ostatni oktet bÄ™dzie dodawany automatycznie dla nowych klientÃ³w.
    eud_subnet_prefix: '10.0.0.'


  # English: TAK Server file IDs on Google Drive.
  # Polski:  Identyfikatory plikÃ³w TAK Server na Google Drive.

  # English: NOTE - these are the repository ID to the files on my Google Drive
  # Polski: UWAGA - to sÄ… ID repozytoriÃ³w do plikÃ³w na moim Dysku Google
  tak_server_files:
    # English: ID to the takserver-docker*.zip file.
    # Polski:  ID do pliku takserver-docker*.zip.
    zip_id: '1FSP2TzSmSHTpkw3yUPsct9xolY_pamjB'
    zip_filename: 'takserver-docker-5.4-RELEASE-19.zip'
    # English: ID to the great repo of CloudRF install scripts:
    # https://github.com/Cloud-RF/tak-server
    # - modified for the project's needs with the original MIT license:

    # Polski:  ID do wspaniaÅ‚ego repo skryptÃ³w instalacyjnych od CloudRF:
    # https://github.com/Cloud-RF/tak-server
    # - zmodyfikowanego na potrzby projektu z pierwotnÄ… licencjÄ… MIT:

    folder_id: '1MdlXYJ-H9PSMJ6o89IfhXsSJcbMaXMxc'

# --- Machine Configuration ---
# --- Konfiguracja Maszyn ---
# English: This section will be automatically populated by the deploy_vm.py script.
#          Do not edit it manually.
# Polski:  Ta sekcja bÄ™dzie automatycznie uzupeÅ‚niana przez skrypt deploy_vm.py.
#          Nie edytuj jej rÄ™cznie.
VM0:
  name: example-vm-name-to-be-replaced
  # line 122 deploy_vm.py: password = f'*P@ssw0rd_*_{timestamp_for_password}*'
  password: '*****'
  ssh_public_key: 'ssh-ed25519-sk AAAA...'
  external_ip: '34.x.x.x'
  internal_ip: '10.x.x.x'
  last_eud_octet: 1

--- END FILE: config-example.yaml ---

--- START FILE: configure_peer.py ---
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# =====================================================================================
# === ADMIN WIREGUARD PEER CONFIGURATION SCRIPT (v5.0 - Centralized Variables) ===
# === SKRYPT KONFIGURACJI PEERA WIREGUARD DLA ADMINA (v5.0 - Zmienne Scentralizowane) ===
# =====================================================================================

import os
import subprocess
import yaml
import sys
import shlex

# --- Configuration ---
# --- Konfiguracja ---
CONFIG_FILE = 'config.yaml'


# =====================================================================================
# === HELPER FUNCTIONS (bez zmian) ===
# === FUNKCJE POMOCNICZE (no changes) ===
# =====================================================================================

def run_command_local(command, password=None, capture_output=False, shell=False):
    """
    English: Executes a command on the local machine.
    Polski:  Wykonuje polecenie na lokalnej maszynie.
    """
    try:
        if shell and isinstance(command, list):
            command = shlex.join(command)
        process = subprocess.Popen(
            command,
            stdin=subprocess.PIPE if password else None,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            encoding='utf-8',
            shell=shell
        )
        stdout, stderr = process.communicate(input=password + '\n' if password else None)
        if stdout:
            if capture_output:
                return process.returncode, stdout.strip().split('\n')
            else:
                print(stdout.strip())
        if stderr and not capture_output:
            print(f"DEBUG/STDERR: {stderr.strip()}", file=sys.stderr)
        return process.returncode, [] if capture_output else None
    except Exception as e:
        print(f"âŒ An unexpected error occurred: {e}")
        print(f"âŒ WystÄ…piÅ‚ nieoczekiwany bÅ‚Ä…d: {e}")
        return 1, [] if capture_output else None


def run_command_remote(vm_name, remote_command_str, user, project_id, zone, capture_output=False):
    """
    English: Executes a command on a remote GCloud VM via SSH.
    Polski:  Wykonuje polecenie na zdalnej maszynie GCloud przez SSH.
    """
    gcloud_ssh_command = [
        'gcloud', 'compute', 'ssh',
        f'{user}@{vm_name}',
        f'--project={project_id}',
        f'--zone={zone}',
        '--quiet',
        '--',
        remote_command_str
    ]
    try:
        process = subprocess.Popen(
            gcloud_ssh_command,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            encoding='utf-8',
            shell=False
        )
        stdout, stderr = process.communicate()
        if stdout:
            if capture_output:
                return process.returncode, stdout.strip().split('\n')
            else:
                print(stdout.strip())
        if stderr and not capture_output:
            print(f"DEBUG/STDERR (Remote): {stderr.strip()}", file=sys.stderr)
        return process.returncode, [] if capture_output else None
    except Exception as e:
        print(f"âŒ An unexpected error occurred during remote command execution: {e}")
        print(f"âŒ WystÄ…piÅ‚ nieoczekiwany bÅ‚Ä…d podczas wykonywania zdalnego polecenia: {e}")
        return 1, [] if capture_output else None


def load_config():
    """
    English: Loads the YAML configuration file.
    Polski:  Wczytuje plik konfiguracyjny YAML.
    """
    if not os.path.exists(CONFIG_FILE):
        print(f"âŒ Config file '{CONFIG_FILE}' not found.")
        print(f"âŒ Plik konfiguracyjny '{CONFIG_FILE}' nie zostaÅ‚ znaleziony.")
        return None
    try:
        with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
            return yaml.safe_load(f)
    except (IOError, yaml.YAMLError) as e:
        print(f"âŒ Error loading config file '{CONFIG_FILE}': {e}")
        print(f"âŒ BÅ‚Ä…d Å‚adowania pliku konfiguracyjnego '{CONFIG_FILE}': {e}")
        return None


def save_config(config_data):
    """
    English: Saves the configuration data back to the YAML file.
    Polski:  Zapisuje dane konfiguracyjne z powrotem do pliku YAML.
    """
    try:
        with open(CONFIG_FILE, 'w', encoding='utf-8') as f:
            yaml.dump(config_data, f, default_flow_style=False, sort_keys=False)
        print(f"âœ… Configuration saved to '{CONFIG_FILE}'.")
        print(f"âœ… Konfiguracja zapisana w '{CONFIG_FILE}'.")
    except (IOError, yaml.YAMLError) as e:
        print(f"âŒ Error saving config file '{CONFIG_FILE}': {e}")
        print(f"âŒ BÅ‚Ä…d zapisu pliku konfiguracyjnego '{CONFIG_FILE}': {e}")


# =====================================================================================
# === MAIN SCRIPT LOGIC (ZMODYFIKOWANA / MODIFIED) ===
# =====================================================================================

def main():
    os.system("clear || cls")
    print("=" * 60)
    print("=== ADMIN WIREGUARD PEER WIZARD (v5.0) ===")
    print("=== KREATOR PEERA WIREGUARD DLA ADMINA (v5.0) ===")
    print("=" * 60)

    config = load_config()
    if not config: return

    # --- Krok 1: Wczytaj ustawienia ---
    local_config = config.get('LOCAL_CONFIG', {})
    global_settings = config.get('GLOBAL_SETTINGS', {})

    local_password = local_config.get('password')

    gcp_settings = global_settings.get('gcp', {})
    vm_settings = global_settings.get('vm', {})
    vpn_settings = global_settings.get('vpn', {})

    if not all([local_password, gcp_settings, vm_settings, vpn_settings]):
        print("\nâŒ ERROR: 'LOCAL_CONFIG' or 'GLOBAL_SETTINGS' sections in config.yaml are incomplete.")
        print("âŒ BÅÄ„D: Sekcje 'LOCAL_CONFIG' lub 'GLOBAL_SETTINGS' w config.yaml sÄ… niekompletne.")
        return

    ADMIN_USER = vm_settings.get('admin_user', 'blox_tak_server_admin')
    PROJECT_ID = gcp_settings.get('project_id')
    ZONE = gcp_settings.get('zone')
    ADMIN_VPN_IP = vpn_settings.get('admin_ip')

    # --- Krok 2: Wybierz maszynÄ™ docelowÄ… ---
    vms = {k: v for k, v in config.items() if isinstance(v, dict) and 'name' in v}
    if not vms:
        print(f"\nâŒ No server machine configurations found in '{CONFIG_FILE}'.")
        print(f"âŒ Nie znaleziono konfiguracji maszyn serwerowych w pliku '{CONFIG_FILE}'.")
        return

    print("\nAvailable server machines to configure peer:")
    print("DostÄ™pne maszyny serwerowe do konfiguracji peera:")
    for key, data in vms.items():
        print(f"  - {key}: {data['name']}")

    vm_key = input(
        "\nEnter the key of the machine to configure the admin peer on:\nPodaj klucz maszyny, na ktÃ³rej skonfigurowaÄ‡ peera admina:\n> ").strip().upper()
    if vm_key not in vms:
        print(f"\nâŒ ERROR: Key '{vm_key}' not found.")
        print(f"âŒ BÅÄ„D: Klucz '{vm_key}' nie zostaÅ‚ znaleziony.")
        return

    vm_name = vms[vm_key]['name']

    # --- Krok 3: Pobierz informacje o serwerze (IP, klucz publiczny) ---
    print(f"\nğŸ”„ Retrieving server information for '{vm_name}'...")
    print(f"ğŸ”„ Pobieranie informacji o serwerze dla '{vm_name}'...")

    code, server_public_key_lines = run_command_remote(vm_name, "sudo cat /etc/wireguard/server_public.key", ADMIN_USER,
                                                       PROJECT_ID, ZONE, capture_output=True)
    if code != 0 or not server_public_key_lines:
        print(f"âŒ ERROR: Failed to retrieve server public key from '{vm_name}'.")
        print(f"âŒ BÅÄ„D: Nie udaÅ‚o siÄ™ pobraÄ‡ klucza publicznego serwera z '{vm_name}'.")
        return
    server_public_key = server_public_key_lines[0]
    print(f"âœ… Server Public Key / Klucz publiczny serwera: {server_public_key}")

    get_ext_ip_cmd = ['gcloud', 'compute', 'instances', 'describe', vm_name, f'--project={PROJECT_ID}',
                      f'--zone={ZONE}', '--format=get(networkInterfaces[0].accessConfigs[0].natIP)']
    code, server_external_ip_lines = run_command_local(get_ext_ip_cmd, capture_output=True)
    if code != 0 or not server_external_ip_lines:
        print(f"âŒ ERROR: Could not fetch server's external IP for '{vm_name}'.")
        print(f"âŒ BÅÄ„D: Nie moÅ¼na byÅ‚o pobraÄ‡ zewnÄ™trznego adresu IP serwera dla '{vm_name}'.")
        return
    server_external_ip = server_external_ip_lines[0]
    print(f"âœ… Server External IP / ZewnÄ™trzny adres IP serwera: {server_external_ip}")

    get_int_ip_cmd = ['gcloud', 'compute', 'instances', 'describe', vm_name, f'--project={PROJECT_ID}',
                      f'--zone={ZONE}', '--format=get(networkInterfaces[0].networkIP)']
    code, server_internal_ip_lines = run_command_local(get_int_ip_cmd, capture_output=True)
    if code != 0 or not server_internal_ip_lines:
        print(f"âŒ ERROR: Could not fetch server's internal IP for '{vm_name}'.")
        print(f"âŒ BÅÄ„D: Nie moÅ¼na byÅ‚o pobraÄ‡ wewnÄ™trznego adresu IP serwera dla '{vm_name}'.")
        return
    server_internal_ip = server_internal_ip_lines[0]
    print(f"âœ… Server Internal IP / WewnÄ™trzny adres IP serwera: {server_internal_ip}")

    print(f"\nğŸ”„ Updating '{CONFIG_FILE}' with new IP addresses...")
    print(f"ğŸ”„ Aktualizacja '{CONFIG_FILE}' nowymi adresami IP...")
    config[vm_key]['external_ip'] = server_external_ip
    config[vm_key]['internal_ip'] = server_internal_ip
    save_config(config)

    # --- Krok 4: Generuj lokalne klucze admina ---
    base_client_path = '/etc/wireguard/'
    client_keys_path = os.path.join(base_client_path, f"admin_{vm_key}")
    client_conf_path = os.path.join(client_keys_path, "admin.conf")
    private_key_path = os.path.join(client_keys_path, 'admin_private.key')
    public_key_path = os.path.join(client_keys_path, 'admin_public.key')

    print(f"\nğŸ”„ Generating WireGuard admin keys in '{client_keys_path}'...")
    print(f"ğŸ”„ Generowanie kluczy admina WireGuard w '{client_keys_path}'...")
    run_command_local(f"sudo -S mkdir -p {client_keys_path}", password=local_password, shell=True)
    run_command_local(f"sudo -S wg genkey | sudo -S tee {private_key_path} > /dev/null", password=local_password,
                      shell=True)
    run_command_local(f"sudo -S cat {private_key_path} | sudo -S wg pubkey | sudo -S tee {public_key_path} > /dev/null",
                      password=local_password, shell=True)

    code, client_public_key_lines = run_command_local(f"sudo -S cat {public_key_path}", password=local_password,
                                                      capture_output=True, shell=True)
    if code != 0 or not client_public_key_lines: return
    client_public_key = client_public_key_lines[0]
    print(f"âœ… Admin Public Key / Klucz publiczny admina: {client_public_key}")

    code, client_private_key_lines = run_command_local(f"sudo -S cat {private_key_path}", password=local_password,
                                                       capture_output=True, shell=True)
    if code != 0 or not client_private_key_lines: return
    client_private_key = client_private_key_lines[0]

    # --- Krok 5: Dodaj peera admina do serwera WireGuard ---
    print(f"\nğŸ”„ Adding admin peer to WireGuard configuration on '{vm_name}'...")
    print(f"ğŸ”„ Dodawanie peera admina do konfiguracji WireGuard na '{vm_name}'...")

    admin_vpn_ip_no_mask = ADMIN_VPN_IP.split('/')[0]
    peer_config_content = f"\\n# Peer: Admin for {vm_key}\\n[Peer]\\nPublicKey = {client_public_key}\\nAllowedIPs = {admin_vpn_ip_no_mask}/32\\n"
    remote_command = f"sudo printf '{peer_config_content}' | sudo tee -a /etc/wireguard/wg0.conf"
    code, _ = run_command_remote(vm_name, remote_command, ADMIN_USER, PROJECT_ID, ZONE)
    if code != 0: return

    print(f"âœ… Admin peer ({admin_vpn_ip_no_mask}) added to server's WireGuard configuration.")
    print(f"âœ… Peer admina ({admin_vpn_ip_no_mask}) dodany do konfiguracji serwera.")

    # --- Krok 6: Zrestartuj WireGuard na serwerze i utwÃ³rz lokalnÄ… konfiguracjÄ™ ---
    print(f"\nğŸ”„ Restarting WireGuard service on '{vm_name}'...")
    print(f"ğŸ”„ Ponowne uruchamianie usÅ‚ugi WireGuard na '{vm_name}'...")
    code, _ = run_command_remote(vm_name, "sudo systemctl restart wg-quick@wg0", ADMIN_USER, PROJECT_ID, ZONE)
    if code != 0: return
    print(f"âœ… WireGuard service restarted on '{vm_name}'.")
    print(f"âœ… UsÅ‚uga WireGuard pomyÅ›lnie ponownie uruchomiona na '{vm_name}'.")

    print(f"\nğŸ”„ Creating WireGuard admin configuration file at '{client_conf_path}'...")
    print(f"ğŸ”„ Tworzenie pliku konfiguracyjnego admina WireGuard w '{client_conf_path}'...")

    allowed_ips_for_peer = "0.0.0.0/0, ::/0"  # PeÅ‚ny tunel dla admina
    client_conf_content = f"""
[Interface]
# Admin Client for {vm_key}
PrivateKey = {client_private_key}
Address = {ADMIN_VPN_IP}
ListenPort = 51820
DNS = 8.8.8.8

[Peer]
# Server: {vm_name}
PublicKey = {server_public_key}
Endpoint = {server_external_ip}:51820
AllowedIPs = {allowed_ips_for_peer}
PersistentKeepalive = 25
""".strip()

    write_client_conf_cmd = f"echo '{client_conf_content}' | sudo -S tee {client_conf_path} > /dev/null"
    code, _ = run_command_local(write_client_conf_cmd, password=local_password, shell=True)
    if code != 0: return

    print(f"âœ… WireGuard admin configuration saved to '{client_conf_path}'.")
    print(f"âœ… Konfiguracja admina WireGuard zapisana w '{client_conf_path}'.")
    print("\nâœ¨ Admin peer configuration completed successfully! âœ¨")
    print("âœ¨ Konfiguracja peera admina zakoÅ„czona pomyÅ›lnie! âœ¨")
    print(f"\nTo enable the client, run / Aby wÅ‚Ä…czyÄ‡ klienta, uruchom:")
    print(f"  sudo wg-quick up {client_conf_path}")
    print(f"\nTo disable, run / Aby wyÅ‚Ä…czyÄ‡, uruchom:")
    print(f"  sudo wg-quick down {client_conf_path}")


if __name__ == '__main__':
    main()
--- END FILE: configure_peer.py ---

--- START FILE: configure_peer_android.py ---
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# =====================================================================================
# === ANDROID WIREGUARD PEER CONFIGURATION SCRIPT (v2.0 - Centralized Variables) ===
# === SKRYPT KONFIGURACJI PEERA WIREGUARD DLA ANDROID (v2.0 - Zmienne Scentralizowane) ===
# =====================================================================================

import os
import subprocess
import yaml
import sys
import json
import re

# --- Configuration ---
# --- Konfiguracja ---
CONFIG_FILE = 'config.yaml'
QR_CODE_PATH = './'


# =====================================================================================
# === HELPER FUNCTIONS (bez zmian) ===
# === FUNKCJE POMOCNICZE (no changes) ===
# =====================================================================================

def run_ssh_command(host_ip, user, command):
    """
    English: Executes a command on a remote machine using standard ssh.
    Polski:  Uruchamia polecenie na zdalnej maszynie uÅ¼ywajÄ…c standardowego ssh.
    """
    full_command = ['ssh', '-o', 'StrictHostKeyChecking=no', '-o', 'ConnectTimeout=10', f'{user}@{host_ip}', command]
    try:
        process = subprocess.Popen(full_command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True,
                                   encoding='utf-8')
        stdout, stderr = process.communicate()
        if process.returncode != 0:
            print(f"âŒ Error executing SSH command on {host_ip}: {stderr.strip()}")
            print(f"âŒ BÅ‚Ä…d wykonania polecenia SSH na {host_ip}: {stderr.strip()}")
        return process.returncode, stdout.strip()
    except Exception as e:
        print(f"âŒ An unexpected error occurred during SSH: {e}")
        print(f"âŒ WystÄ…piÅ‚ nieoczekiwany bÅ‚Ä…d podczas SSH: {e}")
        return 1, ""


def run_local_command(command, command_input=None):
    """
    English: Executes a local command, optionally with input data.
    Polski:  Uruchamia lokalne polecenie, opcjonalnie z danymi wejÅ›ciowymi.
    """
    try:
        process = subprocess.run(command, input=command_input, capture_output=True, text=True, encoding='utf-8',
                                 check=True)
        return process.returncode, process.stdout.strip()
    except subprocess.CalledProcessError as e:
        print(f"âŒ Error executing local command '{' '.join(e.cmd)}': {e.stderr.strip()}")
        print(f"âŒ BÅ‚Ä…d wykonania lokalnego polecenia '{' '.join(e.cmd)}': {e.stderr.strip()}")
        return e.returncode, ""
    except Exception as e:
        print(f"âŒ An unexpected error occurred: {e}")
        print(f"âŒ WystÄ…piÅ‚ nieoczekiwany bÅ‚Ä…d: {e}")
        return 1, ""


def load_config():
    """
    English: Loads the main configuration file.
    Polski:  Wczytuje gÅ‚Ã³wny plik konfiguracyjny.
    """
    if not os.path.exists(CONFIG_FILE):
        print(f"âŒ Config file '{CONFIG_FILE}' not found.")
        print(f"âŒ Plik konfiguracyjny '{CONFIG_FILE}' nie zostaÅ‚ znaleziony.")
        return None
    try:
        with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
            return yaml.safe_load(f) or {}
    except (IOError, yaml.YAMLError) as e:
        print(f"âŒ Error loading config file '{CONFIG_FILE}': {e}")
        print(f"âŒ BÅ‚Ä…d Å‚adowania pliku konfiguracyjnego '{CONFIG_FILE}': {e}")
        return None


def save_config(config_data):
    """
    English: Saves configuration data back to the YAML file.
    Polski:  Zapisuje dane konfiguracyjne z powrotem do pliku YAML.
    """
    try:
        with open(CONFIG_FILE, 'w', encoding='utf-8') as f:
            yaml.dump(config_data, f, default_flow_style=False, sort_keys=False)
    except (IOError, yaml.YAMLError) as e:
        print(f"âŒ Error saving config file '{CONFIG_FILE}': {e}")
        print(f"âŒ BÅ‚Ä…d zapisu pliku konfiguracyjnego '{CONFIG_FILE}': {e}")


# =====================================================================================
# === MAIN SCRIPT LOGIC (ZMODYFIKOWANA / MODIFIED) ===
# =====================================================================================

def main():
    os.system("clear || cls")
    print("=" * 60)
    print("=== ANDROID WIREGUARD PEER WIZARD (v2.0) ===")
    print("=== KREATOR PEERA WIREGUARD DLA ANDROID (v2.0) ===")
    print("=" * 60)

    config = load_config()
    if not config: return

    # --- Krok 1: Wczytaj ustawienia ---
    global_settings = config.get('GLOBAL_SETTINGS', {})
    gcp_settings = global_settings.get('gcp', {})
    vm_settings = global_settings.get('vm', {})
    vpn_settings = global_settings.get('vpn', {})

    if not all([gcp_settings, vm_settings, vpn_settings]):
        print("\nâŒ ERROR: 'GLOBAL_SETTINGS' section in config.yaml is incomplete.")
        print("âŒ BÅÄ„D: Sekcja 'GLOBAL_SETTINGS' w config.yaml jest niekompletna.")
        return

    ADMIN_USER = vm_settings.get('admin_user', 'blox_tak_server_admin')
    PROJECT_ID = gcp_settings.get('project_id')
    ZONE = gcp_settings.get('zone')
    EUD_SUBNET_PREFIX = vpn_settings.get('eud_subnet_prefix')
    SERVER_SUBNET_CIDR = vpn_settings.get('server_subnet')

    # --- Krok 2: Wybierz serwer ---
    servers = {k: v for k, v in config.items() if isinstance(v, dict) and 'name' in v}
    if not servers:
        print(f"\nâŒ No server machine configurations found in '{CONFIG_FILE}'.")
        print(f"âŒ Nie znaleziono konfiguracji maszyn serwerowych w pliku '{CONFIG_FILE}'.")
        return

    print("\nAvailable servers:")
    print("DostÄ™pne serwery:")
    for key, data in servers.items():
        print(f"  - {key}: {data['name']}")

    server_key = input("\nSelect server:\nWybierz serwer:\n> ").strip().upper()
    if server_key not in servers:
        print(f"\nâŒ ERROR: Key '{server_key}' not found.")
        print(f"âŒ BÅÄ„D: Klucz '{server_key}' nie zostaÅ‚ znaleziony.")
        return

    server_data = servers[server_key]
    instance_name = server_data.get('name')
    ssh_host_ip = server_data.get('internal_ip')
    server_external_ip = server_data.get('external_ip')

    if not all([instance_name, ssh_host_ip, server_external_ip]):
        print(
            f"\nâŒ ERROR: Configuration for '{server_key}' is incomplete. Missing 'name', 'internal_ip', or 'external_ip'.")
        print(f"   Run configure_peer.py first to fetch IP addresses.")
        print(
            f"âŒ BÅÄ„D: Konfiguracja dla '{server_key}' jest niekompletna. Brakuje 'name', 'internal_ip' lub 'external_ip'.")
        print(f"   Uruchom najpierw configure_peer.py, aby pobraÄ‡ adresy IP.")
        return

    # --- Krok 3: Przygotuj adresacjÄ™ IP ---
    vm_number_match = re.search(r'\d+', server_key)
    if not vm_number_match:
        print(f"âŒ ERROR: Cannot determine server number from key '{server_key}'.")
        print(f"âŒ BÅÄ„D: Nie moÅ¼na ustaliÄ‡ numeru serwera z klucza '{server_key}'.")
        return
    vm_number = vm_number_match.group(0)

    # Adres IP serwera w sieci VPN
    server_ip_prefix = '.'.join(SERVER_SUBNET_CIDR.split('.')[:3]) + '.'
    server_vpn_ip = f"{server_ip_prefix}{vm_number}"
    print(f"â„¹ï¸  Server address on the VPN network / Adres serwera w sieci VPN: {server_vpn_ip}")

    # Automatyczne generowanie nazwy i IP klienta
    last_octet = server_data.get('last_eud_octet', 0)
    new_octet = last_octet + 1
    client_name = f"EUD{new_octet}"
    client_vpn_ip = f"{EUD_SUBNET_PREFIX}{new_octet}"

    print(f"\nğŸš€ Configuring new peer '{client_name}' with IP {client_vpn_ip} for server '{instance_name}'...")
    print(f"ğŸš€ Konfiguracja nowego peera '{client_name}' z IP {client_vpn_ip} dla serwera '{instance_name}'...")

    # --- Krok 4: Konfiguracja na serwerze przez SSH ---
    print("\n--- Step 4: Retrieving server's public key ---")
    print("--- Krok 4: Pobieranie klucza publicznego serwera ---")
    code, server_public_key = run_ssh_command(ssh_host_ip, ADMIN_USER, "sudo cat /etc/wireguard/server_public.key")
    if code != 0 or not server_public_key:
        print("âŒ ERROR: Failed to retrieve server's public key.")
        print("âŒ BÅÄ„D: Nie udaÅ‚o siÄ™ pobraÄ‡ klucza publicznego serwera.")
        return
    print("âœ… Server public key retrieved / Klucz publiczny serwera pobrany.")

    print("\n--- Step 5: Generating client keys ---")
    print("--- Krok 5: Generowanie kluczy dla klienta ---")
    code, client_private_key = run_local_command(['wg', 'genkey'])
    if code != 0: return
    code, client_public_key = run_local_command(['wg', 'pubkey'], command_input=client_private_key)
    if code != 0: return
    print("âœ… Client keys generated / Klucze klienta wygenerowane.")

    print("\n--- Step 6: Adding peer to server config ---")
    print("--- Krok 6: Dodawanie peera do konfiguracji serwera ---")
    peer_config_content = f"printf '\\n# Peer: {client_name}\\n[Peer]\\nPublicKey = {client_public_key}\\nAllowedIPs = {client_vpn_ip}/32\\n'"
    remote_command = f"sudo bash -c \"{peer_config_content} >> /etc/wireguard/wg0.conf\""
    code, _ = run_ssh_command(ssh_host_ip, ADMIN_USER, remote_command)
    if code != 0: return
    print("âœ… Peer added to server configuration / Peer dodany do konfiguracji serwera.")

    print("\n--- Step 7: Restarting WireGuard service ---")
    print("--- Krok 7: Restartowanie usÅ‚ugi WireGuard ---")
    code, _ = run_ssh_command(ssh_host_ip, ADMIN_USER, "sudo systemctl restart wg-quick@wg0")
    if code != 0: return
    print("âœ… WireGuard service restarted / UsÅ‚uga WireGuard zrestartowana.")

    # --- Krok 8: Generowanie kodu QR ---
    print("\n--- Step 8: Creating QR code ---")
    print("--- Krok 8: Tworzenie kodu QR ---")

    # DomyÅ›lny tryb SPLIT TUNNEL (dostÄ™p tylko do serwera przez jego IP wewn. i wewn. VPN)
    allowed_ips = f"{ssh_host_ip}/32, {server_vpn_ip}/32"
    print(f"â„¹ï¸  Default client configuration with server-only access (AllowedIPs = {allowed_ips})")
    print(f"â„¹ï¸  DomyÅ›lna konfiguracja klienta z dostÄ™pem tylko do serwera (AllowedIPs = {allowed_ips})")

    client_conf_content = f"""[Interface]
PrivateKey = {client_private_key}
Address = {client_vpn_ip}/32
DNS = 8.8.8.8

[Peer]
PublicKey = {server_public_key}
Endpoint = {server_external_ip}:51820
AllowedIPs = {allowed_ips}
PersistentKeepalive = 25
"""
    qr_filename = os.path.join(QR_CODE_PATH, f"QR_{client_name}_{server_key}.png")
    code, _ = run_local_command(['qrencode', '-o', qr_filename, '-t', 'PNG'], command_input=client_conf_content)

    if code == 0:
        print("\n" + "=" * 60)
        print("âœ¨ FINISHED SUCCESSFULLY! / ZAKOÅƒCZONO POMYÅšLNIE! âœ¨")
        print(f"âœ… QR code saved to file / Kod QR zostaÅ‚ zapisany w pliku: {os.path.abspath(qr_filename)}")
        print("\nEnglish: Now open the WireGuard app on your phone, press '+' and select 'Scan from QR code'.")
        print(
            "Polski:  Teraz otwÃ³rz aplikacjÄ™ WireGuard na swoim telefonie, naciÅ›nij '+' i wybierz 'Skanuj z kodu QR'.")

        config[server_key]['last_eud_octet'] = new_octet
        save_config(config)
        print(f"\nâœ… Updated 'last_eud_octet' counter for '{server_key}' to {new_octet} in the config file.")
        print(f"âœ… Zaktualizowano licznik 'last_eud_octet' dla '{server_key}' na {new_octet} w pliku konfiguracyjnym.")
        print("=" * 60)
    else:
        print(
            "\nâŒ ERROR: Failed to generate QR code. Make sure 'qrencode' is installed (`sudo apt-get install qrencode`).")
        print(
            "âŒ BÅÄ„D: Nie udaÅ‚o siÄ™ wygenerowaÄ‡ kodu QR. Upewnij siÄ™, Å¼e program 'qrencode' jest zainstalowany (`sudo apt-get install qrencode`).")


if __name__ == '__main__':
    main()
--- END FILE: configure_peer_android.py ---

--- START FILE: deploy_vm.py ---
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# =====================================================================================
# === VM CREATION SCRIPT (v2.0 - Centralized Variables) ===
# === SKRYPT DO TWORZENIA MASZYN WIRTUALNYCH (v2.0 - Zmienne Scentralizowane) ===
# =====================================================================================

import os
import subprocess
import datetime
import yaml

# --- Configuration ---
# --- Konfiguracja ---
CONFIG_FILE = 'config.yaml'
SSH_KEY_FILE = os.path.expanduser('~/.ssh/id_ed25519_sk.pub')


# =====================================================================================
# === HELPER FUNCTIONS (bez zmian) ===
# === FUNKCJE POMOCNICZE (no changes) ===
# =====================================================================================

def run_command(command, capture_output=False):
    """
    English: Helper function to run system commands and print their output in real-time.
    Polski:  Funkcja pomocnicza do uruchamiania poleceÅ„ systemowych i drukowania ich wyjÅ›cia w czasie rzeczywistym.
    """
    try:
        process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True,
                                   encoding='utf-8')
        output_lines = []
        while True:
            output = process.stdout.readline()
            if output == '' and process.poll() is not None:
                break
            if output:
                line = output.strip()
                if capture_output:
                    output_lines.append(line)
                else:
                    print(line)
        return_code = process.poll()
        return return_code, output_lines
    except FileNotFoundError:
        print(f"âŒ ERROR: Command '{command[0]}' not found. Make sure it is installed.")
        print(f"âŒ BÅÄ„D: Polecenie '{command[0]}' nie zostaÅ‚o znalezione. Upewnij siÄ™, Å¼e jest zainstalowane.")
        return 1, []
    except Exception as e:
        print(f"âŒ An unexpected error occurred / WystÄ…piÅ‚ nieoczekiwany bÅ‚Ä…d: {e}")
        return 1, []


def load_config():
    """
    English: Loads the entire config.yaml file.
    Polski:  Wczytuje caÅ‚y plik config.yaml.
    """
    if not os.path.exists(CONFIG_FILE):
        print(f"âŒ Config file '{CONFIG_FILE}' not found.")
        print(f"âŒ Plik konfiguracyjny '{CONFIG_FILE}' nie zostaÅ‚ znaleziony.")
        return None
    try:
        with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
            return yaml.safe_load(f)
    except (IOError, yaml.YAMLError) as e:
        print(f"âŒ Error loading config file '{CONFIG_FILE}': {e}")
        print(f"âŒ BÅ‚Ä…d Å‚adowania pliku konfiguracyjnego '{CONFIG_FILE}': {e}")
        return None


def get_ssh_key():
    """
    English: Reads the SSH public key from the default file location.
    Polski:  Odczytuje publiczny klucz SSH z domyÅ›lnej lokalizacji pliku.
    """
    if not os.path.exists(SSH_KEY_FILE):
        print(f"âŒ ERROR: SSH key file not found at '{SSH_KEY_FILE}'")
        print(f"âŒ BÅÄ„D: Nie znaleziono pliku klucza SSH w '{SSH_KEY_FILE}'")
        return None
    try:
        with open(SSH_KEY_FILE, 'r', encoding='utf-8') as f:
            key_content = f.read().strip()
            print(f"âœ… Successfully loaded SSH key from '{SSH_KEY_FILE}'")
            print(f"âœ… PomyÅ›lnie zaÅ‚adowano klucz SSH z '{SSH_KEY_FILE}'")
            return key_content
    except IOError as e:
        print(f"âŒ ERROR: Could not read SSH key file: {e}")
        print(f"âŒ BÅÄ„D: Nie moÅ¼na odczytaÄ‡ pliku klucza SSH: {e}")
        return None


def get_next_vm_key():
    """
    English: Checks config.yaml and returns the next available key (e.g., VM3 if VM1 and VM2 exist).
    Polski:  Sprawdza config.yaml i zwraca nastÄ™pny dostÄ™pny klucz (np. VM3, jeÅ›li istnieje VM1 i VM2).
    """
    if not os.path.exists(CONFIG_FILE):
        return 'VM1'
    try:
        with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
            config_data = yaml.safe_load(f) or {}
        vm_keys = [k for k in config_data.keys() if isinstance(k, str) and k.startswith('VM')]
        if not vm_keys:
            return 'VM1'
        last_num = max([int(k.replace('VM', '')) for k in vm_keys])
        return f'VM{last_num + 1}'
    except (IOError, yaml.YAMLError, ValueError):
        return 'VM1'


def generate_credentials():
    """
    English: Generates a unique, GCP-compliant VM name and a password.
    Polski:  Generuje unikalnÄ…, zgodnÄ… z GCP nazwÄ™ maszyny wirtualnej oraz hasÅ‚o.
    """
    now = datetime.datetime.now()
    timestamp_for_name = now.strftime('%Y-%m-%d-%H-%M-%S')
    vm_name = f'blox-tak-server-vm-{timestamp_for_name}'
    timestamp_for_password = now.strftime('%Y-%m-%d_%H-%M-%S')
    password = f'*P@ssw0rd_*_{timestamp_for_password}*'
    return vm_name, password


def update_config_file(vm_key, vm_name, password, ssh_key):
    """
    English: Updates config.yaml, saving the name, password, and SSH key of the machine.
    Polski:  Aktualizuje config.yaml, zapisujÄ…c nazwÄ™, hasÅ‚o i klucz SSH maszyny.
    """
    config_data = {}
    if os.path.exists(CONFIG_FILE):
        with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
            config_data = yaml.safe_load(f) or {}
    config_data[vm_key] = {
        'name': vm_name,
        'password': password,
        'ssh_public_key': ssh_key
    }
    with open(CONFIG_FILE, 'w', encoding='utf-8') as f:
        yaml.dump(config_data, f, default_flow_style=False, sort_keys=False)

    print("\n" + "*" * 60)
    print(f"âœ… Configuration file '{CONFIG_FILE}' successfully updated with data for {vm_key}.")
    print(f"âœ… Plik konfiguracyjny '{CONFIG_FILE}' pomyÅ›lnie zaktualizowany danymi dla {vm_key}.")
    print("*" * 60)


# =====================================================================================
# === MAIN SCRIPT LOGIC (ZMODYFIKOWANA / MODIFIED) ===
# =====================================================================================

def main():
    """
    English: Main function of the VM creation script.
    Polski:  GÅ‚Ã³wna funkcja skryptu do tworzenia maszyn wirtualnych.
    """
    os.system("clear || cls")
    print("=" * 60)
    print("=== TERRAFORM VM CREATION WIZARD (v2.0) ===")
    print("=== KREATOR TWORZENIA MASZYN WIRTUALNYCH TERRAFORM (v2.0) ===")
    print("=" * 60)

    # --- Krok 1: Wczytaj konfiguracjÄ™ ---
    config = load_config()
    if not config:
        return

    # --- Krok 2: Wczytaj ustawienia globalne ---
    global_settings = config.get('GLOBAL_SETTINGS', {})
    if not global_settings:
        print("\nâŒ ERROR: Section 'GLOBAL_SETTINGS' not found in config.yaml.")
        print("âŒ BÅÄ„D: Sekcja 'GLOBAL_SETTINGS' nie zostaÅ‚a znaleziona w pliku config.yaml.")
        return

    gcp_settings = global_settings.get('gcp', {})
    vm_settings = global_settings.get('vm', {})

    # --- Krok 3: SprawdÅº inicjalizacjÄ™ Terraform ---
    if not os.path.isdir('.terraform'):
        print("\nâŒ ERROR: The '.terraform' directory does not exist.")
        print("   Please run 'terraform init' in this directory before running the script.")
        print("\nâŒ BÅÄ„D: Katalog '.terraform' nie istnieje.")
        print("   ProszÄ™ uruchomiÄ‡ 'terraform init' w tym katalogu przed uruchomieniem skryptu.")
        return

    # --- Krok 4: Wczytaj klucz SSH ---
    ssh_public_key = get_ssh_key()
    if not ssh_public_key:
        print("\nAborting due to missing SSH key.")
        print("Przerywam z powodu braku klucza SSH.")
        return

    # --- Krok 5: Wygeneruj dane dla nowej maszyny ---
    vm_key = get_next_vm_key()
    new_vm_name, new_password = generate_credentials()

    print(f"\nâ–¶ï¸  Next available key / NastÄ™pny dostÄ™pny klucz: {vm_key}")
    print(f"ğŸ–¥ï¸  Generated name for the new machine / Wygenerowana nazwa dla nowej maszyny: {new_vm_name}")

    # --- Krok 6: StwÃ³rz i przeÅ‚Ä…cz na nowy obszar roboczy Terraform ---
    print(f"\nğŸ”„ Creating and switching to workspace '{vm_key}'...")
    print(f"ğŸ”„ Tworzenie i przeÅ‚Ä…czanie na obszar roboczy '{vm_key}'...")
    run_command(['terraform', 'workspace', 'new', vm_key])
    run_command(['terraform', 'workspace', 'select', vm_key])

    # --- Krok 7: Wykonaj Terraform Apply z nowymi zmiennymi ---
    print("\n--- Running Terraform Apply ---")
    print("--- Uruchamianie Terraform Apply ---")
    apply_command = [
        'terraform', 'apply', '-auto-approve',
        # Zmienne podstawowe
        f'-var=instance_name={new_vm_name}',
        f'-var=root_password={new_password}',
        f'-var=ssh_public_key={ssh_public_key}',
        # Zmienne z GLOBAL_SETTINGS
        f'-var=gcp_project_id={gcp_settings.get("project_id")}',
        f'-var=gcp_region={gcp_settings.get("region")}',
        f'-var=gcp_zone={gcp_settings.get("zone")}',
        f'-var=vm_machine_type={vm_settings.get("machine_type")}',
        f'-var=vm_disk_image={vm_settings.get("disk_image")}',
        f'-var=vm_disk_size_gb={vm_settings.get("disk_size_gb")}',
        f'-var=vm_disk_type={vm_settings.get("disk_type")}',
        f'-var=vm_admin_user={vm_settings.get("admin_user")}',
    ]
    return_code, _ = run_command(apply_command)

    # --- Krok 8: Zaktualizuj plik konfiguracyjny po sukcesie ---
    if return_code == 0:
        print("\n--- âœ… Terraform Apply completed successfully ---")
        print("--- âœ… Terraform Apply zakoÅ„czone sukcesem ---")
        update_config_file(vm_key, new_vm_name, new_password, ssh_public_key)
    else:
        print(f"\n--- âŒ ERROR: Terraform Apply failed with exit code: {return_code} ---")
        print(f"--- âŒ BÅÄ„D: Terraform Apply zakoÅ„czone z kodem bÅ‚Ä™du: {return_code} ---")
        print("The workspace was not cleaned up. Check the errors above.")
        print("Obszar roboczy nie zostaÅ‚ wyczyszczony. SprawdÅº bÅ‚Ä™dy powyÅ¼ej.")

    # --- Krok 9: PrzeÅ‚Ä…cz z powrotem na domyÅ›lny obszar roboczy ---
    print("\nğŸ”„ Switching back to the 'default' workspace...")
    print("ğŸ”„ PrzeÅ‚Ä…czam z powrotem na obszar roboczy 'default'...")
    run_command(['terraform', 'workspace', 'select', 'default'])

    if return_code == 0:
        print("\nâœ¨ Process completed successfully! âœ¨")
        print("âœ¨ Proces zakoÅ„czony pomyÅ›lnie! âœ¨")


if __name__ == '__main__':
    main()
--- END FILE: deploy_vm.py ---

--- START FILE: destroy_vm.py ---
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# =====================================================================================
# === VM DESTRUCTION SCRIPT (v3.0 - Centralized Variables) ===
# === SKRYPT DO USUWANIA MASZYN WIRTUALNYCH (v3.0 - Zmienne Scentralizowane) ===
# =====================================================================================

import os
import subprocess
import yaml

# --- Configuration ---
# --- Konfiguracja ---
CONFIG_FILE = 'config.yaml'


# =====================================================================================
# === HELPER FUNCTIONS (bez zmian) ===
# === FUNKCJE POMOCNICZE (no changes) ===
# =====================================================================================

def run_command(command):
    """
    English: Helper function to run system commands and print their output in real-time.
    Polski:  Funkcja pomocnicza do uruchamiania poleceÅ„ systemowych i drukowania ich wyjÅ›cia w czasie rzeczywistym.
    """
    try:
        process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True,
                                   encoding='utf-8')
        while True:
            output = process.stdout.readline()
            if output == '' and process.poll() is not None:
                break
            if output:
                print(output.strip())
        return process.poll()
    except Exception as e:
        print(f"âŒ An unexpected error occurred / WystÄ…piÅ‚ nieoczekiwany bÅ‚Ä…d: {e}")
        return 1


def load_config():
    """
    English: Loads config.yaml and returns a dictionary of available VMs.
    Polski:  Wczytuje config.yaml i zwraca sÅ‚ownik dostÄ™pnych maszyn wirtualnych.
    """
    if not os.path.exists(CONFIG_FILE):
        return None
    try:
        with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
            return yaml.safe_load(f)
    except (IOError, yaml.YAMLError):
        return None


def remove_from_config(vm_key_to_delete):
    """
    English: Removes a given key from the config.yaml file.
    Polski:  Usuwa dany klucz z pliku config.yaml.
    """
    config_data = load_config()
    if vm_key_to_delete in config_data:
        del config_data[vm_key_to_delete]
    with open(CONFIG_FILE, 'w', encoding='utf-8') as f:
        yaml.dump(config_data, f, default_flow_style=False, sort_keys=False)

    print("\n" + "*" * 60)
    print(f"âœ… Entry for '{vm_key_to_delete}' has been removed from {CONFIG_FILE}.")
    print(f"âœ… Wpis dla '{vm_key_to_delete}' zostaÅ‚ usuniÄ™ty z pliku {CONFIG_FILE}.")
    print("*" * 60)


# =====================================================================================
# === MAIN SCRIPT LOGIC (ZMODYFIKOWANA / MODIFIED) ===
# =====================================================================================

def main():
    """
    English: Main function of the VM destruction script.
    Polski:  GÅ‚Ã³wna funkcja skryptu do usuwania maszyn wirtualnych.
    """
    os.system("clear || cls")
    print("=" * 60)
    print("=== TERRAFORM VM DESTRUCTION WIZARD (v3.0) ===")
    print("=== KREATOR USUWANIA MASZYN WIRTUALNYCH TERRAFORM (v3.0) ===")
    print("=" * 60)

    all_config = load_config()
    if not all_config:
        print(f"\nâŒ Configuration file '{CONFIG_FILE}' does not exist or is empty.")
        print(f"âŒ Plik konfiguracyjny '{CONFIG_FILE}' nie istnieje lub jest pusty.")
        return

    # --- Krok 1: Wczytaj ustawienia ---
    global_settings = all_config.get('GLOBAL_SETTINGS', {})
    gcp_settings = global_settings.get('gcp', {})
    vm_settings = global_settings.get('vm', {})

    if not all([gcp_settings, vm_settings]):
        print("\nâŒ ERROR: Section 'GLOBAL_SETTINGS' in config.yaml is incomplete.")
        print("âŒ BÅÄ„D: Sekcja 'GLOBAL_SETTINGS' w config.yaml jest niekompletna.")
        return

    # --- Krok 2: Wybierz maszynÄ™ do usuniÄ™cia ---
    vms = {k: v for k, v in all_config.items() if isinstance(v, dict) and 'name' in v}
    if not vms:
        print(f"\nâŒ No machine configurations found in '{CONFIG_FILE}'.")
        print(f"âŒ Nie znaleziono konfiguracji maszyn w pliku '{CONFIG_FILE}'.")
        return

    print("\nAvailable machines for deletion:")
    print("DostÄ™pne maszyny do usuniÄ™cia:")
    for key, data in vms.items():
        print(f"  - {key}: {data['name']}")

    vm_key = input(
        "\nEnter the key of the machine to delete (e.g., VM1):\nPodaj klucz maszyny do usuniÄ™cia (np. VM1): ").strip().upper()
    if vm_key not in vms:
        print(f"\nâŒ ERROR: Key '{vm_key}' not found in the configuration file.")
        print(f"âŒ BÅÄ„D: Klucz '{vm_key}' nie zostaÅ‚ znaleziony w pliku konfiguracyjnym.")
        return

    vm_to_delete_data = vms[vm_key]
    vm_name = vm_to_delete_data['name']
    ssh_key = vm_to_delete_data.get('ssh_public_key', 'dummy-key-for-destroy')

    print("\n" + "!" * 60)
    print("!!! WARNING: This operation is irreversible and will permanently delete the VM. !!!")
    print("!!! OSTRZEÅ»ENIE: Ta operacja jest nieodwracalna i trwale usunie maszynÄ™ wirtualnÄ…. !!!")
    print("!" * 60)
    confirm = input(
        f"\nAre you sure you want to permanently delete machine '{vm_name}' ({vm_key})? [y/N]:\nCzy na pewno chcesz trwale usunÄ…Ä‡ maszynÄ™ '{vm_name}' ({vm_key})? [t/N]: ").strip().lower()
    if confirm not in ['y', 't']:
        print("\nOperation cancelled by user / Operacja anulowana przez uÅ¼ytkownika.")
        return

    # --- Krok 3: Uruchom Terraform Destroy z peÅ‚nym zestawem zmiennych ---
    print(f"\nğŸ”„ Switching to workspace '{vm_key}' for deletion...")
    print(f"ğŸ”„ PrzeÅ‚Ä…czanie na obszar roboczy '{vm_key}' w celu usuniÄ™cia...")
    run_command(['terraform', 'workspace', 'select', vm_key])

    print("\n--- Running Terraform Destroy ---")
    print("--- Uruchamianie Terraform Destroy ---")

    destroy_command = [
        'terraform', 'destroy', '-auto-approve',
        # Zmienne podstawowe
        f'-var=instance_name={vm_name}',
        f'-var=root_password=dummy-password',  # HasÅ‚o nie jest potrzebne do usuniÄ™cia
        f'-var=ssh_public_key={ssh_key}',
        # Zmienne z GLOBAL_SETTINGS - konieczne, aby Terraform poprawnie odczytaÅ‚ stan
        f'-var=gcp_project_id={gcp_settings.get("project_id")}',
        f'-var=gcp_region={gcp_settings.get("region")}',
        f'-var=gcp_zone={gcp_settings.get("zone")}',
        f'-var=vm_machine_type={vm_settings.get("machine_type")}',
        f'-var=vm_disk_image={vm_settings.get("disk_image")}',
        f'-var=vm_disk_size_gb={vm_settings.get("disk_size_gb")}',
        f'-var=vm_disk_type={vm_settings.get("disk_type")}',
        f'-var=vm_admin_user={vm_settings.get("admin_user")}',
    ]
    return_code = run_command(destroy_command)

    # --- Krok 4: PosprzÄ…taj po udanym usuniÄ™ciu ---
    if return_code == 0:
        print("\n--- âœ… Terraform Destroy completed successfully ---")
        print("--- âœ… Terraform Destroy zakoÅ„czone sukcesem ---")
        remove_from_config(vm_key)

        print("\nğŸ§¹ Cleaning up workspace...")
        print("ğŸ§¹ SprzÄ…tanie obszaru roboczego...")
        run_command(['terraform', 'workspace', 'select', 'default'])
        run_command(['terraform', 'workspace', 'delete', vm_key])

        print("\nâœ¨ Process completed successfully! âœ¨")
        print("âœ¨ Proces zakoÅ„czony pomyÅ›lnie! âœ¨")
    else:
        print(f"\n--- âŒ ERROR: Terraform Destroy failed with exit code: {return_code} ---")
        print(f"--- âŒ BÅÄ„D: Terraform Destroy zakoÅ„czone z kodem bÅ‚Ä™du: {return_code} ---")
        print("Check the errors above. The entry in config.yaml and the workspace were not removed.")
        print("SprawdÅº bÅ‚Ä™dy powyÅ¼ej. Wpis w config.yaml i obszar roboczy nie zostaÅ‚y usuniÄ™te.")


if __name__ == '__main__':
    main()
--- END FILE: destroy_vm.py ---

--- START FILE: gdown.py ---
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# =====================================================================================
# === REMOTE GDRIVE DOWNLOADER (v2.0 - Centralized Variables) ===
# === SKRYPT ZDALNEGO POBIERANIA Z GDRIVE (v2.0 - Zmienne Scentralizowane) ===
# =====================================================================================

import os
import subprocess
import yaml
import sys
import re

# --- Configuration ---
# --- Konfiguracja ---
CONFIG_FILE = 'config.yaml'

# =====================================================================================
# === HELPER FUNCTIONS (bez zmian) ===
# === FUNKCJE POMOCNICZE (no changes) ===
# =====================================================================================

def run_ssh_command(host_ip, user, command):
    """
    English: Runs a command on a remote machine using standard ssh.
    Polski:  Uruchamia polecenie na zdalnej maszynie uÅ¼ywajÄ…c standardowego ssh.
    """
    full_command = [
        'ssh',
        '-o', 'StrictHostKeyChecking=no',
        '-o', 'ConnectTimeout=10',
        f'{user}@{host_ip}',
        command
    ]
    print(f"\nğŸ”„ Executing remote command on '{host_ip}'...")
    print(f"ğŸ”„ Wykonywanie zdalnego polecenia na '{host_ip}'...")
    print(f"    COMMAND: {command}")

    try:
        process = subprocess.Popen(
            full_command,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            encoding='utf-8',
            bufsize=1
        )
        while True:
            output = process.stdout.readline()
            if output == '' and process.poll() is not None:
                break
            if output:
                print(f"    [{host_ip}] > {output.strip()}")

        returncode = process.poll()
        if returncode != 0:
            print(f"âŒ Error executing SSH command (exit code: {returncode}).")
            print(f"âŒ BÅ‚Ä…d wykonania polecenia SSH (kod wyjÅ›cia: {returncode}).")
        return returncode
    except FileNotFoundError:
        print("âŒ ERROR: Command 'ssh' not found.")
        print("âŒ BÅÄ„D: Polecenie 'ssh' nie zostaÅ‚o znalezione.")
        return 1
    except Exception as e:
        print(f"âŒ An unexpected error occurred during SSH: {e}")
        print(f"âŒ WystÄ…piÅ‚ nieoczekiwany bÅ‚Ä…d podczas SSH: {e}")
        return 1


def load_config():
    """
    English: Loads the main configuration file.
    Polski:  Wczytuje gÅ‚Ã³wny plik konfiguracyjny.
    """
    if not os.path.exists(CONFIG_FILE):
        print(f"âŒ Configuration file '{CONFIG_FILE}' not found.")
        print(f"âŒ Plik konfiguracyjny '{CONFIG_FILE}' nie zostaÅ‚ znaleziony.")
        return None
    try:
        with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
            return yaml.safe_load(f)
    except (IOError, yaml.YAMLError) as e:
        print(f"âŒ Error loading configuration file '{CONFIG_FILE}': {e}")
        print(f"âŒ BÅ‚Ä…d Å‚adowania pliku konfiguracyjnego '{CONFIG_FILE}': {e}")
        return None


# =====================================================================================
# === MAIN SCRIPT LOGIC (ZMODYFIKOWANA / MODIFIED) ===
# =====================================================================================

def main():
    os.system("clear || cls")
    print("=" * 60)
    print("=== GCP REMOTE FILE DOWNLOADER SCRIPT (v2.0) ===")
    print("=== SKRYPT ZDALNEGO POBIERANIA PLIKÃ“W NA MASZYNÄ˜ GCP (v2.0) ===")
    print("=" * 60)

    config = load_config()
    if not config:
        return

    # --- Krok 1: Wczytaj ustawienia globalne ---
    global_settings = config.get('GLOBAL_SETTINGS', {})
    tak_files = global_settings.get('tak_server_files', {})
    vm_settings = global_settings.get('vm', {})

    if not all([tak_files, vm_settings]):
        print("\nâŒ ERROR: Section 'GLOBAL_SETTINGS.tak_server_files' or 'GLOBAL_SETTINGS.vm' not found in config.yaml.")
        print("âŒ BÅÄ„D: Sekcja 'GLOBAL_SETTINGS.tak_server_files' lub 'GLOBAL_SETTINGS.vm' nie zostaÅ‚a znaleziona w pliku config.yaml.")
        return

    # UÅ¼yj zmiennych z konfiguracji
    TAK_SERVER_FOLDER_ID = tak_files.get('folder_id')
    TAK_ZIP_FILE_ID = tak_files.get('zip_id')
    TAK_ZIP_FILENAME = tak_files.get('zip_filename')
    TAK_SERVER_DIRNAME = "tak-server" # MoÅ¼na teÅ¼ przenieÅ›Ä‡ do configu, jeÅ›li potrzeba
    ADMIN_USER = vm_settings.get('admin_user', 'blox_tak_server_admin')

    # --- Krok 2: Wybierz serwer docelowy ---
    servers = {k: v for k, v in config.items() if isinstance(v, dict) and 'name' in v}
    if not servers:
        print(f"\nâŒ No server configurations found in '{CONFIG_FILE}'.")
        print(f"âŒ Nie znaleziono konfiguracji serwerÃ³w w pliku '{CONFIG_FILE}'.")
        return

    print("\nAvailable servers:")
    print("DostÄ™pne serwery:")
    for key, data in servers.items():
        print(f"  - {key}: {data['name']}")

    server_key = input(
        "\nSelect the server to download files to:\nWybierz serwer, na ktÃ³rym majÄ… byÄ‡ pobrane pliki:\n> ").strip().upper()
    if server_key not in servers:
        print(f"\nâŒ ERROR: Key '{server_key}' not found.")
        print(f"âŒ BÅÄ„D: Klucz '{server_key}' nie zostaÅ‚ znaleziony.")
        return

    server_data = servers[server_key]
    instance_name = server_data.get('name')
    ssh_host_ip = server_data.get('internal_ip')

    if not all([instance_name, ssh_host_ip]):
        print(f"\nâŒ ERROR: Configuration for '{server_key}' is incomplete. Missing 'name' or 'internal_ip'.")
        print(f"âŒ BÅÄ„D: Konfiguracja dla '{server_key}' jest niekompletna. Brakuje 'name' lub 'internal_ip'.")
        return

    # --- Krok 3: Wykonaj zdalne polecenia ---
    print(f"\nğŸš€ Preparing machine '{instance_name}' and downloading files...")
    print(f"ğŸš€ Przygotowywanie maszyny '{instance_name}' i pobieranie plikÃ³w...")

    remote_commands = [
        "sudo apt-get update -y",
        "sudo apt-get install -y python3-pip unzip",
        "sudo python3 -m pip install gdown",
        f"python3 -m gdown --folder {TAK_SERVER_FOLDER_ID}",
        f"python3 -m gdown --id {TAK_ZIP_FILE_ID} -O {TAK_ZIP_FILENAME}",
        f"mv {TAK_ZIP_FILENAME} {TAK_SERVER_DIRNAME}/",
        "echo '--- Folder contents / ZawartoÅ›Ä‡ folderu ---'",
        f"ls -l {TAK_SERVER_DIRNAME}"
    ]

    full_remote_command = " && ".join(remote_commands)
    return_code = run_ssh_command(ssh_host_ip, ADMIN_USER, full_remote_command)

    # --- Krok 4: PokaÅ¼ wynik ---
    print("\n" + "=" * 60)
    if return_code == 0:
        print("âœ¨ FINISHED SUCCESSFULLY!")
        print("âœ¨ ZAKOÅƒCZONO POMYÅšLNIE!")
        print(f"âœ… Files have been downloaded and prepared on machine '{instance_name}'.")
        print(f"âœ… Pliki zostaÅ‚y pobrane i przygotowane na maszynie '{instance_name}'.")
    else:
        print("âŒ OPERATION FAILED.")
        print("âŒ OPERACJA ZAKOÅƒCZONA BÅÄ˜DEM.")
        print("âŒ Check the messages above to diagnose the issue.")
        print("âŒ SprawdÅº powyÅ¼sze komunikaty, aby zdiagnozowaÄ‡ problem.")
    print("=" * 60)


if __name__ == '__main__':
    main()
--- END FILE: gdown.py ---

--- START FILE: install_docker.py ---
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# =====================================================================================
# === DOCKER INSTALLATION SCRIPT (v5.0 - Centralized Variables) ===
# === SKRYPT INSTALACJI DOCKERA (v5.0 - Zmienne Scentralizowane) ===
# =====================================================================================

import os
import subprocess
import yaml
import sys

# --- Configuration ---
# --- Konfiguracja ---
CONFIG_FILE = 'config.yaml'


# =====================================================================================
# === HELPER FUNCTIONS (bez zmian) ===
# === FUNKCJE POMOCNICZE (no changes) ===
# =====================================================================================

def load_config():
    """
    English: Loads the main configuration file.
    Polski:  Wczytuje gÅ‚Ã³wny plik konfiguracyjny.
    """
    if not os.path.exists(CONFIG_FILE):
        print(f"âŒ ERROR: Configuration file '{CONFIG_FILE}' not found.")
        print(f"âŒ BÅÄ„D: Plik konfiguracyjny '{CONFIG_FILE}' nie zostaÅ‚ znaleziony.")
        return None
    try:
        with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
            return yaml.safe_load(f)
    except (IOError, yaml.YAMLError) as e:
        print(f"âŒ ERROR: Error loading config file: {e}")
        print(f"âŒ BÅÄ„D: BÅ‚Ä…d Å‚adowania pliku konfiguracyjnego: {e}")
        return None


def run_ssh_command(host_ip, user, command):
    """
    English: Runs a command on a remote machine via SSH and streams the output.
    Polski:  Uruchamia polecenie na zdalnej maszynie przez SSH i strumieniuje wyjÅ›cie.
    """
    full_command = ['ssh', '-o', 'StrictHostKeyChecking=no', '-o', 'ConnectTimeout=10', f'{user}@{host_ip}', command]
    print(f"\nğŸ”„ Executing command on '{host_ip}'...")
    print(f"ğŸ”„ Wykonywanie polecenia na '{host_ip}'...")
    print("-" * 60)
    try:
        process = subprocess.Popen(
            full_command,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            encoding='utf-8',
            bufsize=1
        )
        while True:
            output = process.stdout.readline()
            if output == '' and process.poll() is not None:
                break
            if output:
                print(f"  [{host_ip}] > {output.strip()}")

        returncode = process.poll()
        if returncode != 0:
            print(f"âŒ SSH command failed with exit code: {returncode}.")
            print(f"âŒ Polecenie SSH zakoÅ„czone bÅ‚Ä™dem (kod: {returncode}).")
        return returncode
    except Exception as e:
        print(f"âŒ An unexpected error occurred during SSH: {e}")
        print(f"âŒ WystÄ…piÅ‚ nieoczekiwany bÅ‚Ä…d podczas SSH: {e}")
        return 1


# =====================================================================================
# === MAIN SCRIPT LOGIC (ZMODYFIKOWANA / MODIFIED) ===
# =====================================================================================

def main():
    os.system("clear || cls")
    print("=" * 60)
    print("=== DOCKER INSTALLATION SCRIPT (v5.0) ===")
    print("=== SKRYPT INSTALACJI DOCKERA (v5.0) ===")
    print("=" * 60)

    config = load_config()
    if not config: return

    # --- Krok 1: Wczytaj ustawienia ---
    global_settings = config.get('GLOBAL_SETTINGS', {})
    vm_settings = global_settings.get('vm', {})
    if not vm_settings:
        print("\nâŒ ERROR: Section 'GLOBAL_SETTINGS.vm' not found in config.yaml.")
        print("âŒ BÅÄ„D: Sekcja 'GLOBAL_SETTINGS.vm' nie zostaÅ‚a znaleziona w pliku config.yaml.")
        return

    ADMIN_USER = vm_settings.get('admin_user', 'blox_tak_server_admin')

    # --- Krok 2: Wybierz maszynÄ™ docelowÄ… ---
    vms = {k: v for k, v in config.items() if isinstance(v, dict) and 'name' in v}
    if not vms:
        print(f"\nâŒ ERROR: No VMs found in '{CONFIG_FILE}'.")
        print(f"âŒ BÅÄ„D: Nie znaleziono maszyn w '{CONFIG_FILE}'.")
        return

    print("\nAvailable VMs / DostÄ™pne maszyny wirtualne:")
    for key, data in vms.items():
        print(f"  - {key}: {data['name']}")

    server_key = input(
        "\nEnter the key of the VM to install Docker on:\nWprowadÅº klucz maszyny, na ktÃ³rej zainstalowaÄ‡ Dockera:\n> ").strip().upper()
    if server_key not in vms:
        print(f"\nâŒ ERROR: Key '{server_key}' not found.")
        print(f"âŒ BÅÄ„D: Klucz '{server_key}' nie zostaÅ‚ znaleziony.")
        return

    server_data = vms[server_key]
    ssh_host_ip = server_data.get('internal_ip')

    if not ssh_host_ip:
        print(f"\nâŒ ERROR: Missing 'internal_ip' for VM '{server_key}' in config.yaml.")
        print(f"   Run 'configure_peer.py' first to fetch and save the IP addresses.")
        print(f"\nâŒ BÅÄ„D: Brak 'internal_ip' dla maszyny '{server_key}' w pliku config.yaml.")
        print("   Uruchom najpierw skrypt `configure_peer.py`, aby pobraÄ‡ i zapisaÄ‡ adresy IP.")
        return

    print(f"\nâ„¹ï¸  Connecting to VM via internal IP / ÅÄ…czÄ™ z maszynÄ… przez wewnÄ™trzny adres IP: {ssh_host_ip}")

    # --- Krok 3: Przygotuj i uruchom skrypt instalacyjny ---
    docker_install_script = f"""
    set -e
    echo "--- Starting Docker installation ---"

    # 1. Update package index and install dependencies
    sudo apt-get update
    sudo apt-get install -y ca-certificates curl

    # 2. Add Docker's official GPG key
    sudo install -m 0755 -d /etc/apt/keyrings
    sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
    sudo chmod a+r /etc/apt/keyrings/docker.asc

    # 3. Set up the repository
    echo \\
      "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \\
      $(. /etc/os-release && echo $VERSION_CODENAME) stable" | \\
      sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

    # 4. Install Docker Engine
    sudo apt-get update
    sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

    # 5. Add user to the 'docker' group
    sudo usermod -aG docker {ADMIN_USER}

    echo "âœ… Docker installed successfully."
    """

    return_code = run_ssh_command(ssh_host_ip, ADMIN_USER, docker_install_script)

    print("\n" + "=" * 60)
    if return_code == 0:
        print("âœ¨ DOCKER INSTALLATION FINISHED SUCCESSFULLY! âœ¨")
        print("âœ¨ INSTALACJA DOCKERA ZAKOÅƒCZONA POMYÅšLNIE! âœ¨")
    else:
        print("âŒ DOCKER INSTALLATION FAILED. Check the output above.")
        print("âŒ INSTALACJA DOCKERA NIE POWIODÅA SIÄ˜. SprawdÅº powyÅ¼sze komunikaty.")
    print("=" * 60)


if __name__ == '__main__':
    main()
--- END FILE: install_docker.py ---

--- START FILE: install_wireguard.py ---
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# =====================================================================================
# === WIREGUARD INSTALLATION SCRIPT (v4.0 - Centralized Variables) ===
# === SKRYPT INSTALACJI WIREGUARD (v4.0 - Zmienne Scentralizowane) ===
# =====================================================================================

import os
import subprocess
import yaml
import sys
import re

# --- Configuration ---
# --- Konfiguracja ---
CONFIG_FILE = 'config.yaml'


# =====================================================================================
# === HELPER FUNCTIONS (bez zmian) ===
# === FUNKCJE POMOCNICZE (no changes) ===
# =====================================================================================

def run_command(command, capture_output=False, shell=False):
    """
    English: Runs system commands and handles their output.
    Polski:  Uruchamia polecenia systemowe i obsÅ‚uguje ich wyjÅ›cie.
    """
    try:
        process = subprocess.Popen(
            command, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
            text=True, encoding='utf-8', shell=shell
        )
        stdout, stderr = process.communicate()
        output_lines = []
        if stdout:
            lines = filter(None, stdout.strip().split('\n'))
            for line in lines:
                if capture_output:
                    output_lines.append(line)
                else:
                    print(line)
        if stderr and not capture_output:
            print(f"DEBUG/STDERR: {stderr.strip()}", file=sys.stderr)
        return process.returncode, output_lines
    except Exception as e:
        print(f"âŒ An unexpected error occurred: {e}")
        print(f"âŒ WystÄ…piÅ‚ nieoczekiwany bÅ‚Ä…d: {e}")
        return 1, []


def load_config():
    """
    English: Loads the entire config.yaml file.
    Polski:  Wczytuje caÅ‚y plik config.yaml.
    """
    if not os.path.exists(CONFIG_FILE):
        print(f"âŒ Config file '{CONFIG_FILE}' not found.")
        print(f"âŒ Plik konfiguracyjny '{CONFIG_FILE}' nie zostaÅ‚ znaleziony.")
        return None
    try:
        with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
            return yaml.safe_load(f)
    except (IOError, yaml.YAMLError) as e:
        print(f"âŒ Error loading config file '{CONFIG_FILE}': {e}")
        print(f"âŒ BÅ‚Ä…d Å‚adowania pliku konfiguracyjnego '{CONFIG_FILE}': {e}")
        return None


# =====================================================================================
# === MAIN SCRIPT LOGIC (ZMODYFIKOWANA / MODIFIED) ===
# =====================================================================================

def main():
    os.system("clear || cls")
    print("=" * 60)
    print("=== WIREGUARD INSTALLATION WIZARD (v4.0) ===")
    print("=== KREATOR INSTALACJI WIREGUARD (v4.0) ===")
    print("=" * 60)

    config = load_config()
    if not config: return

    # --- Krok 1: Wczytaj ustawienia globalne ---
    global_settings = config.get('GLOBAL_SETTINGS', {})
    vpn_settings = global_settings.get('vpn', {})
    gcp_settings = global_settings.get('gcp', {})
    vm_settings = global_settings.get('vm', {})

    if not all([vpn_settings, gcp_settings, vm_settings]):
        print("\nâŒ ERROR: 'GLOBAL_SETTINGS' section in config.yaml is incomplete.")
        print("âŒ BÅÄ„D: Sekcja 'GLOBAL_SETTINGS' w config.yaml jest niekompletna.")
        return

    ADMIN_USER = vm_settings.get('admin_user', 'blox_tak_server_admin')
    PROJECT_ID = gcp_settings.get('project_id')
    ZONE = gcp_settings.get('zone')

    # --- Krok 2: Wybierz maszynÄ™ docelowÄ… ---
    vms = {k: v for k, v in config.items() if isinstance(v, dict) and 'name' in v}
    if not vms:
        print(f"\nâŒ No server machine configurations found in '{CONFIG_FILE}'.")
        print(f"\nâŒ Nie znaleziono konfiguracji maszyn serwerowych w pliku '{CONFIG_FILE}'.")
        return

    print("\nAvailable server machines for WireGuard installation:")
    print("DostÄ™pne maszyny serwerowe do instalacji WireGuard:")
    for key, data in vms.items():
        print(f"  - {key}: {data['name']}")

    vm_key = input(
        "\nEnter the key of the machine to install WireGuard on:\nPodaj klucz maszyny, na ktÃ³rej zainstalowaÄ‡ WireGuard:\n> ").strip().upper()
    if vm_key not in vms:
        print(f"\nâŒ ERROR: Key '{vm_key}' not found in the list of available machines.")
        print(f"âŒ BÅÄ„D: Klucz '{vm_key}' nie zostaÅ‚ znaleziony na liÅ›cie dostÄ™pnych maszyn.")
        return

    vm_name = vms[vm_key]['name']

    # --- Krok 3: Przygotuj adresacjÄ™ IP z pliku konfiguracyjnego ---
    vm_number_match = re.search(r'\d+', vm_key)
    if not vm_number_match:
        print(f"âŒ ERROR: Cannot determine server number from key '{vm_key}'. Key must contain a number (e.g., VM1).")
        print(f"âŒ BÅÄ„D: Nie moÅ¼na ustaliÄ‡ numeru serwera z klucza '{vm_key}'. Klucz musi zawieraÄ‡ cyfrÄ™ (np. VM1).")
        return
    vm_number = vm_number_match.group(0)

    server_subnet_cidr = vpn_settings.get('server_subnet')  # np. '10.200.0.0/24'
    ip_prefix = '.'.join(server_subnet_cidr.split('.')[:3]) + '.'  # np. '10.200.0.'
    subnet_mask = server_subnet_cidr.split('/')[1]  # np. '24'

    server_vpn_ip = f"{ip_prefix}{vm_number}"  # np. '10.200.0.1'
    server_vpn_ip_with_mask = f"{server_vpn_ip}/{subnet_mask}"  # np. '10.200.0.1/24'

    print(f"\nğŸš€ Starting WireGuard installation on '{vm_name}'...")
    print(f"ğŸš€ Rozpoczynanie instalacji WireGuard na '{vm_name}'...")
    print(f"   Server VPN IP will be set to / Adres IP serwera VPN zostanie ustawiony na: {server_vpn_ip_with_mask}")

    # --- Krok 4: Uruchom skrypt instalacyjny na zdalnej maszynie ---
    install_script = f"""
        set -e
        echo "--- Installing WireGuard / Instalacja WireGuard ---"
        sudo apt-get update -y && sudo apt-get install -y wireguard

        echo "--- Generating server keys / Generowanie kluczy serwera ---"
        sudo wg genkey | sudo tee /etc/wireguard/server_private.key | sudo wg pubkey | sudo tee /etc/wireguard/server_public.key > /dev/null
        sudo chmod 600 /etc/wireguard/server_private.key /etc/wireguard/server_public.key

        echo "--- Creating server config with IP {server_vpn_ip_with_mask} ---"
        PRIVATE_KEY=$(sudo cat /etc/wireguard/server_private.key)
        echo "[Interface]
Address = {server_vpn_ip_with_mask}
ListenPort = 51820
PrivateKey = ${{PRIVATE_KEY}}
PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -t nat -A POSTROUTING -o ens4 -j MASQUERADE
PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -t nat -D POSTROUTING -o ens4 -j MASQUERADE" | sudo tee /etc/wireguard/wg0.conf > /dev/null

        echo "--- Enabling IP forwarding / WÅ‚Ä…czenie przekierowywania IP ---"
        sudo sysctl -w net.ipv4.ip_forward=1
        echo 'net.ipv4.ip_forward=1' | sudo tee -a /etc/sysctl.conf

        echo "--- Starting WireGuard service / Uruchomienie usÅ‚ugi WireGuard ---"
        sudo systemctl enable wg-quick@wg0
        sudo systemctl start wg-quick@wg0

        echo "âœ¨ WireGuard installation completed successfully! / Instalacja WireGuard zakoÅ„czona pomyÅ›lnie! âœ¨"
    """

    gcloud_ssh_command = [
        'gcloud', 'compute', 'ssh',
        f'{ADMIN_USER}@{vm_name}',
        f'--project={PROJECT_ID}',
        f'--zone={ZONE}',
        '--quiet',
        '--',
        install_script
    ]

    code, _ = run_command(gcloud_ssh_command)

    if code == 0:
        print(f"\nâœ… WireGuard installation on '{vm_name}' completed successfully!")
        print(f"âœ… Instalacja WireGuard na '{vm_name}' zakoÅ„czona pomyÅ›lnie!")
    else:
        print(f"\nâŒ ERROR: WireGuard installation on '{vm_name}' failed with exit code: {code}.")
        print(f"âŒ BÅÄ„D: Instalacja WireGuard na '{vm_name}' zakoÅ„czona bÅ‚Ä™dem. Kod bÅ‚Ä™du: {code}.")


if __name__ == '__main__':
    main()
--- END FILE: install_wireguard.py ---

--- START FILE: log_collector.py ---
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import subprocess
import yaml
import datetime
import glob
import tarfile
from pathlib import Path
from fpdf import FPDF
from fpdf.enums import XPos, YPos
from pypdf import PdfReader, PdfWriter

# --- CONFIGURATION & CONSTANTS ---
# --- KONFIGURACJA I STAÅE ---

CONFIG_FILE = 'config.yaml'
EVIDENCE_DIR = 'evidence'

FONTS = {
    'R': "UbuntuMono-Regular.ttf",
    'B': "UbuntuMono-Bold.ttf",
    'I': "UbuntuMono-Italic.ttf"
}

# --- TRANSLATIONS ---
# --- TÅUMACZENIA ---

TEXTS = {
    'EN': {
        'header': "APPENDIX A: LOG PACKAGE MANIFEST",
        'desc': "This document certifies the extraction of the following system and container logs.",
        'filename': "FILENAME",
        'size': "SIZE (Bytes)",
        'archive_info': "ARCHIVE METADATA",
        'arch_name': "Archive Name:",
        'arch_hash': "Integrity Check (MD5):",
        'legal_title': "LEGAL DISCLAIMER / DATA RETENTION POLICY",
        'legal_text': "The list above confirms the security of the forensic material. The full log package (.tar.gz) contains sensitive data and is stored in a secure offline repository. It may be released to appropriate authorities, institutions, or the client only in justified cases.",
        'footer': "Forensic Log Collector | Chain of Custody",
        'status_pub': "[ PUBLIC RELEASE: METADATA ONLY - CONTENT SECURED OFFLINE ]",
        'status_priv': "[ INTERNAL: FULL CHAIN OF CUSTODY ]"
    },
    'PL': {
        'header': "ZAÅÄ„CZNIK A: SPIS ZAWARTOÅšCI LOGÃ“W",
        'desc': "Niniejszy dokument potwierdza ekstrakcjÄ™ nastÄ™pujÄ…cych logÃ³w systemowych i kontenerÃ³w.",
        'filename': "NAZWA PLIKU",
        'size': "ROZMIAR (B)",
        'archive_info': "METADANE ARCHIWUM",
        'arch_name': "Nazwa Archiwum:",
        'arch_hash': "Suma Kontrolna (MD5):",
        'legal_title': "KLAUZULA PRAWNA / POLITYKA RETENCJI",
        'legal_text': "PowyÅ¼szy wykaz stanowi potwierdzenie zabezpieczenia materiaÅ‚u dowodowego. PeÅ‚ny pakiet logÃ³w (.tar.gz) zawiera dane wraÅ¼liwe i jest przechowywany w bezpiecznym depozycie offline. MoÅ¼e zostaÄ‡ udostÄ™pniony odpowiednim organom wyÅ‚Ä…cznie w uzasadnionych przypadkach.",
        'footer': "Kryminalistyka Cyfrowa | ÅaÅ„cuch Dowodowy",
        'status_pub': "[ WERSJA PUBLICZNA: TYLKO METADANE - TREÅšÄ† ZABEZPIECZONA ]",
        'status_priv': "[ WEWNÄ˜TRZNY: PEÅNY ÅAÅƒCUCH DOWODOWY ]"
    }
}

# --- HELPER FUNCTIONS ---
# --- FUNKCJE POMOCNICZE ---

def load_config():
    # Check if config file exists
    # SprawdÅº, czy plik konfiguracyjny istnieje
    if not os.path.exists(CONFIG_FILE): return None
    
    # Load and parse YAML file
    # Wczytaj i przetwÃ³rz plik YAML
    with open(CONFIG_FILE, 'r', encoding='utf-8') as f: return yaml.safe_load(f)

def run_local_command(command):
    try:
        # Execute shell command locally
        # Wykonaj komendÄ™ shell lokalnie
        subprocess.check_call(command, shell=True)
        return True
    except subprocess.CalledProcessError as e:
        print(f"âŒ Local execution failed: {e}")
        print(f"âŒ Lokalne wykonanie nie powiodÅ‚o siÄ™: {e}")
        return False

def get_file_hash(filepath):
    # Compute MD5 hash of a file
    # Oblicz hash MD5 pliku
    import hashlib
    hash_md5 = hashlib.md5()
    with open(filepath, "rb") as f:
        for chunk in iter(lambda: f.read(4096), b""):
            hash_md5.update(chunk)
    return hash_md5.hexdigest()

# --- PDF CLASS ---
# --- KLASA PDF ---

class EvidencePDF(FPDF):
    def __init__(self, vm_name, lang):
        super().__init__()
        self.vm_name = vm_name
        self.lang = lang
        self.t = TEXTS[lang]
        
        try:
            self.add_font('UbuntuMono', '', FONTS['R'])
            self.add_font('UbuntuMono', 'B', FONTS['B'])
            self.add_font('UbuntuMono', 'I', FONTS['I'])
            self.font_family = 'UbuntuMono'
        except:
            self.font_family = 'Courier'

    def header(self):
        self.set_font(self.font_family, 'B', 14)
        self.cell(0, 10, self.t['header'], new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='C')
        self.line(10, 20, 200, 20)
        self.ln(10)

    def footer(self):
        self.set_y(-15)
        self.set_font(self.font_family, 'I', 8)
        self.cell(0, 10, f"{self.t['footer']} | {datetime.datetime.now().strftime('%Y-%m-%d')}", align='C')

    def print_row_grid(self, col1_text, col2_text, w1, w2, fill=False):
        # Calculate row height for text wrapping
        # Oblicz wysokoÅ›Ä‡ wiersza dla zawijania tekstu
        font_size = self.font_size_pt / 72 * 25.4
        line_height = font_size * 1.5
        
        # Check how many lines the text will occupy
        # SprawdÅº ile linii zajmie tekst
        lines1 = self.multi_cell(w1, line_height, str(col1_text), dry_run=True, output="LINES")
        lines2 = self.multi_cell(w2, line_height, str(col2_text), dry_run=True, output="LINES")
        
        max_lines = max(len(lines1), len(lines2))
        row_height = max_lines * line_height

        # Check for page break
        # SprawdÅº podziaÅ‚ strony
        if self.get_y() + row_height > self.page_break_trigger:
            self.add_page()

        x_start, y_start = self.get_x(), self.get_y()

        if fill:
            self.set_fill_color(220, 220, 220)
            self.rect(x_start, y_start, w1 + w2, row_height, 'F')
        
        # Column 1 (File Name - Wrapped)
        # Kolumna 1 (Nazwa pliku - zawijana)
        self.set_xy(x_start, y_start)
        self.multi_cell(w1, line_height, str(col1_text), border=0, align='L')
        
        # Column 2 (Size)
        # Kolumna 2 (Rozmiar)
        self.set_xy(x_start + w1, y_start)
        self.multi_cell(w2, line_height, str(col2_text), border=0, align='L')

        # Draw borders on top
        # Rysuj obramowania na wierzchu
        self.rect(x_start, y_start, w1, row_height)
        self.rect(x_start + w1, y_start, w2, row_height)

        self.set_xy(x_start, y_start + row_height)

def create_manifest_pdf(vm_name, archive_path, file_list, lang, is_public, output_pdf):
    # Initialize PDF and fonts
    # Inicjalizuj PDF i czcionki
    pdf = EvidencePDF(vm_name, lang)
    t = TEXTS[lang]
    font = pdf.font_family

    pdf.add_page()
    pdf.set_font(font, '', 10)
    pdf.multi_cell(0, 5, t['desc'])
    pdf.ln(5)

    # Archive Metadata Section
    # Sekcja metadanych archiwum
    pdf.set_font(font, 'B', 11)
    pdf.cell(0, 6, t['archive_info'], new_x=XPos.LMARGIN, new_y=YPos.NEXT)
    pdf.set_font(font, '', 10)
    
    archive_name = os.path.basename(archive_path)
    archive_hash = get_file_hash(archive_path)
    
    pdf.cell(50, 6, t['arch_name'], border=0)
    pdf.cell(0, 6, archive_name, new_x=XPos.LMARGIN, new_y=YPos.NEXT)
    pdf.cell(50, 6, t['arch_hash'], border=0)
    pdf.cell(0, 6, archive_hash, new_x=XPos.LMARGIN, new_y=YPos.NEXT)
    pdf.ln(5)

    # --- FILE TABLE (ALWAYS VISIBLE) ---
    # --- TABELA PLIKÃ“W (ZAWSZE WIDOCZNA) ---
    w_name = 140
    w_size = 50
    
    pdf.set_font(font, 'B', 10)
    pdf.print_row_grid(t['filename'], t['size'], w_name, w_size, fill=True)
    
    pdf.set_font(font, '', 9)
    for fname, fsize in file_list:
        # Use full filename and grid for wrapping
        # UÅ¼yj peÅ‚nej nazwy i siatki do zawijania
        pdf.print_row_grid(fname, str(fsize), w_name, w_size, fill=False)

    pdf.ln(10)
    
    # --- STATUS & LEGAL DISCLAIMER ---
    # --- STATUS I KLAUZULA PRAWNA ---
    status_msg = t['status_pub'] if is_public else t['status_priv']
    
    pdf.set_font(font, 'B', 10)
    pdf.set_fill_color(240, 240, 240)
    pdf.cell(0, 10, status_msg, border=1, fill=True, align='C', new_x=XPos.LMARGIN, new_y=YPos.NEXT)
    
    pdf.ln(5)
    pdf.set_font(font, 'B', 11)
    pdf.cell(0, 8, t['legal_title'], new_x=XPos.LMARGIN, new_y=YPos.NEXT)
    
    pdf.set_font(font, 'I', 10)
    pdf.multi_cell(0, 5, t['legal_text'], border=1, align='L')

    pdf.output(output_pdf)
    return output_pdf

def merge_pdfs(original_report, appendix_pdf):
    # Merge original report with appendix
    # Scal oryginalny raport z zaÅ‚Ä…cznikiem
    writer = PdfWriter()
    try:
        reader_orig = PdfReader(original_report)
        for page in reader_orig.pages:
            writer.add_page(page)
        reader_app = PdfReader(appendix_pdf)
        for page in reader_app.pages:
            writer.add_page(page)

        with open(original_report, "wb") as f_out:
            writer.write(f_out)
        print(f"      ğŸ“ Merged logs manifest into: {os.path.basename(original_report)}")
        print(f"      ğŸ“ Scalono manifest logÃ³w do: {os.path.basename(original_report)}")
    except Exception as e:
        print(f"âŒ Error merging PDF: {e}")
        print(f"âŒ BÅ‚Ä…d scalania PDF: {e}")

def remote_harvest_script(timestamp):
    # Define remote bash script for log collection
    # Zdefiniuj zdalny skrypt bash do zbierania logÃ³w
    temp_dir = f"/tmp/harvest_{timestamp}"
    archive_name = f"/tmp/logs_{timestamp}.tar.gz"
    
    script = f"""
    mkdir -p {temp_dir}/system
    mkdir -p {temp_dir}/docker_std
    mkdir -p {temp_dir}/docker_internal
    sudo cp /var/log/syslog {temp_dir}/system/ 2>/dev/null
    sudo cp /var/log/auth.log {temp_dir}/system/ 2>/dev/null
    sudo dmesg > {temp_dir}/system/dmesg_boot.txt
    for container in $(sudo docker ps -a -q); do
        name=$(sudo docker inspect --format='{{{{.Name}}}}' $container | cut -c2-)
        sudo docker logs $container > {temp_dir}/docker_std/$name.log 2>&1
        if [[ "$name" == *"tak-server-tak"* ]]; then
             echo "   -> Detected TAK Server: $name. Extracting internal logs..."
             mkdir -p {temp_dir}/docker_internal/$name
             sudo docker cp $container:/opt/tak/logs/ {temp_dir}/docker_internal/$name/ 2>/dev/null
        fi
    done
    sudo tar -czf {archive_name} -C /tmp harvest_{timestamp}
    sudo chmod 644 {archive_name}
    sudo rm -rf {temp_dir}
    echo "READY:{archive_name}"
    """
    return script

# --- MAIN EXECUTION ---
# --- GÅÃ“WNE WYKONANIE ---

def main():
    # Clear terminal screen
    # WyczyÅ›Ä‡ ekran terminala
    os.system("clear || cls")
    
    print("=" * 60)
    print("=== LOG COLLECTOR v7.0 (NO CENSORSHIP) ===")
    print("=== ZBIERACZ LOGÃ“W v7.0 (BEZ CENZURY) ===")
    print("=" * 60)
    
    cfg = load_config()
    if not cfg: return

    vms = {k: v for k, v in cfg.items() if isinstance(v, dict) and 'name' in v and k != 'LOCAL_CONFIG'}
    
    print("\nSelect Target VM:")
    print("Wybierz DocelowÄ… VM:")
    for key, data in vms.items():
        print(f"  - {key}: {data['name']}")

    print("\n> ", end="")
    server_key = input().strip().upper()
    if server_key not in vms: return

    vm_data = vms[server_key]
    user = vm_data.get('user', 'blox_tak_server_admin')
    internal_ip = vm_data.get('internal_ip')
    vm_name = vm_data.get('name', server_key)

    if not internal_ip:
        print("âŒ Error: Internal IP missing.")
        print("âŒ BÅ‚Ä…d: Brak wewnÄ™trznego IP.")
        return

    ts = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
    local_evidence_path = Path(EVIDENCE_DIR) / vm_name / "logs"
    local_evidence_path.mkdir(parents=True, exist_ok=True)
    local_archive_name = local_evidence_path / f"logs_{ts}.tar.gz"

    # --- 1. HARVEST ---
    # --- 1. ZBIERANIE ---
    print(f"\n[1/4] Harvesting logs from {internal_ip} as {user}...")
    print(f"[1/4] Zbieranie logÃ³w z {internal_ip} jako {user}...")
    
    ssh_cmd = ['ssh', '-o', 'StrictHostKeyChecking=no', f'{user}@{internal_ip}', remote_harvest_script(ts)]
    
    try:
        result = subprocess.run(ssh_cmd, capture_output=True, text=True)
        if "READY:" not in result.stdout:
            print(f"âŒ Harvest failed: {result.stderr}")
            print(f"âŒ Zbieranie nieudane: {result.stderr}")
            return
        remote_file = result.stdout.split("READY:")[1].strip().split()[0]
    except Exception as e:
        print(f"âŒ Error: {e}")
        print(f"âŒ BÅ‚Ä…d: {e}")
        return

    # --- 2. DOWNLOAD ---
    # --- 2. POBIERANIE ---
    print(f"[2/4] Downloading archive...")
    print(f"[2/4] Pobieranie archiwum...")
    
    scp_cmd = f"scp -o StrictHostKeyChecking=no {user}@{internal_ip}:{remote_file} {local_archive_name}"
    if not run_local_command(scp_cmd): return
    subprocess.run(['ssh', '-o', 'StrictHostKeyChecking=no', f'{user}@{internal_ip}', f'sudo rm -f {remote_file}'])

    # --- 3. ANALYZE ---
    # --- 3. ANALIZA ---
    print(f"[3/4] Analyzing package contents...")
    print(f"[3/4] Analiza zawartoÅ›ci pakietu...")
    
    file_list = []
    try:
        with tarfile.open(local_archive_name, "r:gz") as tar:
            for member in tar.getmembers():
                if member.isfile():
                    file_list.append((member.name, member.size))
    except Exception as e:
        print(f"âŒ Failed to read archive: {e}")
        print(f"âŒ BÅ‚Ä…d odczytu archiwum: {e}")
        return

    # --- 4. UPDATE REPORTS (WSZYSTKIE WERSJE) ---
    # --- 4. AKTUALIZACJA RAPORTÃ“W (WSZYSTKIE WERSJE) ---
    print(f"[4/4] Updating existing PDF reports...")
    print(f"[4/4] Aktualizacja istniejÄ…cych raportÃ³w PDF...")
    
    reports = glob.glob(f"*PORT_{vm_name}_*.pdf")
    
    count = 0
    if not reports:
        print("âš ï¸  No reports found.")
        print("âš ï¸  Nie znaleziono raportÃ³w.")
    else:
        for report in reports:
            if "FINAL" in report: continue
            if "tmp" in report: continue
            
            is_public = "PUBLIC" in report
            lang = 'EN'
            if 'RAPORT' in report: lang = 'PL'
            elif 'REPORT' in report: lang = 'EN'
            
            vis = "ğŸ™ˆ PUBLIC" if is_public else "ğŸ”’ PRIVATE"
            print(f"   > Processing: {report} [{lang}] {vis}")
            print(f"   > Przetwarzanie: {report} [{lang}] {vis}")
            
            tmp = f"tmp_manifest_{lang}_{'pub' if is_public else 'priv'}.pdf"
            
            # Generate Manifest with FULL TABLE
            # Generuj Manifest z PEÅNÄ„ TABELÄ„
            create_manifest_pdf(vm_name, str(local_archive_name), file_list, lang, is_public, tmp)
            
            merge_pdfs(report, tmp)
            os.remove(tmp)
            count += 1

    print("\n" + "=" * 60)
    print(f"âœ… PROCESS COMPLETE. Updated {count} reports.")
    print(f"âœ… PROCES ZAKOÅƒCZONY. Zaktualizowano {count} raportÃ³w.")
    print(f"ğŸ“‚ Archive: {local_archive_name}")
    print(f"ğŸ“‚ Archiwum: {local_archive_name}")
    print("=" * 60)

if __name__ == "__main__":
    main()

--- END FILE: log_collector.py ---

--- START FILE: main.tf ---
# =====================================================================================
# === TERRAFORM CONFIGURATION FOR GOOGLE CLOUD VM (v2.0 - Centralized Variables) ===
# === KONFIGURACJA TERRAFORM DLA MASZYNY WIRTUALNEJ W GOOGLE CLOUD (v2.0 - Zmienne Scentralizowane) ===
# =====================================================================================

terraform {
  required_providers {
    google = {
      source  = "hashicorp/google"
      version = ">= 4.25.0"
    }
  }
}

# --- Zmienne wejÅ›ciowe / Input Variables ---
# Te zmienne sÄ… przekazywane przez skrypt deploy_vm.py z pliku config.yaml
# This variables are passed from the deploy_vm.py script from the config.yaml file

# Zmienne podstawowe
variable "instance_name" {
  description = "The name of the Compute Engine instance. / Nazwa instancji Compute Engine."
  type        = string
}
variable "root_password" {
  description = "The password for the admin user. / HasÅ‚o dla uÅ¼ytkownika."
  type        = string
  sensitive   = true
}
variable "ssh_public_key" {
  description = "Public SSH key for the admin user. / Publiczny klucz SSH dla uÅ¼ytkownika."
  type        = string
  sensitive   = true
}

# Zmienne z GLOBAL_SETTINGS.gcp
variable "gcp_project_id" {
  description = "Google Cloud Project ID. / ID projektu w Google Cloud."
  type        = string
}
variable "gcp_region" {
  description = "Google Cloud Region. / Region w Google Cloud."
  type        = string
}
variable "gcp_zone" {
  description = "Google Cloud Zone. / Strefa w Google Cloud."
  type        = string
}

# Zmienne z GLOBAL_SETTINGS.vm
variable "vm_machine_type" {
  description = "The machine type for the VM. / Typ maszyny dla VM."
  type        = string
}
variable "vm_disk_image" {
  description = "The boot disk image for the VM. / Obraz dysku startowego dla VM."
  type        = string
}
variable "vm_disk_size_gb" {
  description = "The boot disk size in GB. / Rozmiar dysku startowego w GB."
  type        = number
}
variable "vm_disk_type" {
  description = "The boot disk type. / Typ dysku startowego."
  type        = string
}
variable "vm_admin_user" {
  description = "The username for the admin user on the VM. / Nazwa uÅ¼ytkownika admina na VM."
  type        = string
}

# --- Konfiguracja dostawcy / Provider Configuration ---

provider "google" {
  project = var.gcp_project_id
  region  = var.gcp_region
}

# --- GÅ‚Ã³wny zasÃ³b maszyny wirtualnej / Main VM Resource ---

resource "google_compute_instance" "tak-server-vm" {
  name         = var.instance_name
  zone         = var.gcp_zone
  machine_type = var.vm_machine_type

  boot_disk {
    auto_delete = true
    device_name = var.instance_name
    initialize_params {
      image = var.vm_disk_image
      size  = var.vm_disk_size_gb
      type  = var.vm_disk_type
    }
    mode = "READ_WRITE"
  }

  metadata = {
    # Dodanie klucza SSH do autoryzowanych kluczy uÅ¼ytkownika
    ssh-keys = "${var.vm_admin_user}:${var.ssh_public_key}"

    # Konfiguracja poczÄ…tkowa maszyny za pomocÄ… cloud-init
    user-data = <<-EOT
      #cloud-config

      # StwÃ³rz nowego uÅ¼ytkownika z uprawnieniami sudo
      users:
        - name: ${var.vm_admin_user}
          sudo: ALL=(ALL) NOPASSWD:ALL
          groups: [adm, sudo]
          shell: /bin/bash

      # Ustaw hasÅ‚o dla nowego uÅ¼ytkownika
      chpasswd:
        list: |
          ${var.vm_admin_user}:${var.root_password}
        expire: False

      # Rekomendacja: WyÅ‚Ä…cz logowanie hasÅ‚em, skoro mamy klucze SSH
      runcmd:
        - [ sed, -i, -e, 's/^#?PasswordAuthentication .*/PasswordAuthentication no/g', /etc/ssh/sshd_config ]
        - [ systemctl, restart, sshd ]
    EOT
  }

  network_interface {
    subnetwork = "projects/${var.gcp_project_id}/regions/${var.gcp_region}/subnetworks/default"
    access_config {
      network_tier = "PREMIUM"
    }
  }

  scheduling {
    automatic_restart   = true
    on_host_maintenance = "MIGRATE"
    preemptible         = false
    provisioning_model  = "STANDARD"
  }

  shielded_instance_config {
    enable_integrity_monitoring = true
    enable_secure_boot          = true
    enable_vtpm                 = true
  }

  deletion_protection = true
  can_ip_forward      = false
  enable_display      = false
  hostname            = "takserver.local"
  tags                = ["tak-server"]

  labels = {
    goog-ec-src         = "vm_add-tf"
    goog-ops-agent-policy = "v2-x86-template-1-4-0"
  }
}
--- END FILE: main.tf ---

--- START FILE: report_finisher.py ---
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import datetime
import glob
import subprocess
import json
import yaml
import time
import zipfile
import hashlib
from fpdf import FPDF
from fpdf.enums import XPos, YPos
from pypdf import PdfReader, PdfWriter

# --- CONFIGURATION & CONSTANTS ---
# --- KONFIGURACJA I STAÅE ---

CONFIG_FILE = 'config.yaml'

FONTS = {
    'R': "UbuntuMono-Regular.ttf",
    'B': "UbuntuMono-Bold.ttf",
    'I': "UbuntuMono-Italic.ttf"
}

# --- DYNAMIC CONFIG LOADING ---
# --- DYNAMICZNE ÅADOWANIE KONFIGURACJI ---

def get_config_paths():
    # Defaults in case of missing config
    # WartoÅ›ci domyÅ›lne w przypadku braku konfiguracji
    default_pcap = []
    default_evidence = "evidence"
    
    if not os.path.exists(CONFIG_FILE):
        return default_pcap, default_evidence

    try:
        with open(CONFIG_FILE, 'r') as f:
            cfg = yaml.safe_load(f)
        
        paths = cfg.get('LOCAL_PATHS', {})
        
        # Load PCAP directories and expand user path (~)
        # Wczytaj katalogi PCAP i rozwiÅ„ Å›cieÅ¼kÄ™ uÅ¼ytkownika (~)
        raw_dirs = paths.get('pcap_directories', default_pcap)
        clean_dirs = [os.path.expanduser(p) for p in raw_dirs]
        
        # Load output directory
        # Wczytaj katalog wyjÅ›ciowy
        ev_dir = paths.get('evidence_output_dir', default_evidence)
        
        return clean_dirs, ev_dir
    except Exception as e:
        print(f"âš ï¸ Config Load Error: {e}")
        print(f"âš ï¸ BÅ‚Ä…d Å‚adowania konfiguracji: {e}")
        return default_pcap, default_evidence

# Load global variables dynamically from YAML
# ZaÅ‚aduj zmienne globalne dynamicznie z YAML
PCAP_PATHS, EVIDENCE_DIR = get_config_paths()

# --- TRANSLATIONS ---
# --- TÅUMACZENIA ---

TEXTS = {
    'EN': {
        'header': "APPENDIX B: INFRASTRUCTURE & NETWORK SECURITY",
        'snap_sec': "1. GOLDEN IMAGE CHECKPOINT (COLD STORAGE)",
        'snap_desc': "System stopped. Filesystem consistency guaranteed.",
        'snap_name': "Snapshot ID:",
        'snap_time': "Creation Time:",
        'snap_status': "Status:",
        'snap_size': "Storage / Disk:",
        'snap_link': "GOLDEN IMAGE SOURCE (URI):",
        'net_sec': "2. NETWORK TRAFFIC INTERCEPTION (PCAPNG)",
        'filename': "FILENAME",
        'size': "SIZE",
        'source': "SOURCE",
        'legal': "LEGAL WARNING (SIGINT/COMINT)",
        'legal_text': "PCAPNG files contain full network packet captures. These files are classified as HIGHLY SENSITIVE. They are stored in a separate air-gapped evidence locker and are NOT included in the standard report body (Metadata listing above serves as proof of capture).",
        'footer': "Final System Validation | Ready for Deployment"
    },
    'PL': {
        'header': "ZAÅÄ„CZNIK B: BEZPIECZEÅƒSTWO I SIECI",
        'snap_sec': "1. PUNKT PRZYWRACANIA (ZIMNA MIGAWKA)",
        'snap_desc': "System zatrzymany. Gwarantowana spÃ³jnoÅ›Ä‡ systemu plikÃ³w.",
        'snap_name': "ID Snapshotu:",
        'snap_time': "Data utworzenia:",
        'snap_status': "Status:",
        'snap_size': "Rozmiar (Snap/Dysk):",
        'snap_link': "Å¹RÃ“DÅO OBRAZU (URI - DISK_IMAGE):",
        'net_sec': "2. PRZECHWYCONY RUCH SIECIOWY (PCAPNG)",
        'filename': "NAZWA PLIKU",
        'size': "ROZMIAR",
        'source': "Å¹RÃ“DÅO",
        'legal': "OSTRZEÅ»ENIE PRAWNE (SIGINT/COMINT)",
        'legal_text': "Pliki PCAPNG zawierajÄ… peÅ‚ny zrzut pakietÃ³w sieciowych. Pliki te sÄ… sklasyfikowane jako WRAÅ»LIWE. Przechowywane sÄ… w odseparowanym depozycie i NIE sÄ… doÅ‚Ä…czane do treÅ›ci raportu (PowyÅ¼sza lista sÅ‚uÅ¼y jako dowÃ³d zabezpieczenia).",
        'footer': "Finalna Walidacja Systemu | GotowoÅ›Ä‡ Operacyjna"
    }
}

# --- HELPER FUNCTIONS ---
# --- FUNKCJE POMOCNICZE ---

def load_config():
    # Check if config file exists
    # SprawdÅº, czy plik konfiguracyjny istnieje
    if not os.path.exists(CONFIG_FILE): return None
    with open(CONFIG_FILE, 'r') as f: return yaml.safe_load(f)

def run_cmd(cmd):
    # Execute system command safely
    # Wykonaj polecenie systemowe bezpiecznie
    try:
        res = subprocess.run(cmd, capture_output=True, text=True)
        return res.returncode == 0, res.stdout, res.stderr
    except Exception as e:
        return False, "", str(e)

def calculate_hash(file_path):
    # Calculate SHA256 checksum
    # Oblicz sumÄ™ kontrolnÄ… SHA256
    sha256_hash = hashlib.sha256()
    with open(file_path, "rb") as f:
        for byte_block in iter(lambda: f.read(4096), b""):
            sha256_hash.update(byte_block)
    return sha256_hash.hexdigest()

# --- GCLOUD LOGIC ---
# --- LOGIKA GCLOUD ---

def manage_vm_lifecycle(vm_name, project_id, zone):
    # Initialize snapshot naming
    # Inicjalizuj nazewnictwo snapshotu
    ts = datetime.datetime.now().strftime('%Y%m%d-%H%M%S')
    snap_name = f"snap-tak-cold-{ts}" 
    desc = f"COLD SNAPSHOT from {vm_name}"
    
    print(f"\nğŸ›‘ Checking VM status: {vm_name}...")
    print(f"ğŸ›‘ Sprawdzanie statusu VM: {vm_name}...")
    
    ok, out, err = run_cmd(['gcloud', 'compute', 'instances', 'stop', vm_name, f'--project={project_id}', f'--zone={zone}', '--quiet'])
    if not ok and "is already stopped" not in err:
        print(f"âš ï¸ Warning during stop: {err}")
        print(f"âš ï¸ OstrzeÅ¼enie podczas zatrzymywania: {err}")
    else:
        print("   VM is stopped/stopping.")
        print("   VM jest zatrzymana/zatrzymuje siÄ™.")

    print(f"ğŸ“¸ CREATING COLD SNAPSHOT: {snap_name}...")
    print(f"ğŸ“¸ TWORZENIE ZIMNEJ MIGAWKI: {snap_name}...")
    
    cmd_snap = [
        'gcloud', 'compute', 'disks', 'snapshot', vm_name,
        f'--project={project_id}', f'--zone={zone}',
        f'--snapshot-names={snap_name}', f'--description={desc}', '--quiet'
    ]
    ok, out, err = run_cmd(cmd_snap)
    if not ok:
        print(f"âŒ Snapshot failed: {err}")
        print(f"âŒ Snapshot nieudany: {err}")
        run_cmd(['gcloud', 'compute', 'instances', 'start', vm_name, f'--project={project_id}', f'--zone={zone}', '--quiet'])
        return None

    print(f"ğŸš€ RESTARTING VM: {vm_name} (Back to business)...")
    print(f"ğŸš€ RESTART VM: {vm_name} (PowrÃ³t do dziaÅ‚ania)...")
    run_cmd(['gcloud', 'compute', 'instances', 'start', vm_name, f'--project={project_id}', f'--zone={zone}', '--quiet'])
    return snap_name

def get_snapshot_details(snap_name, project_id):
    print(f"ğŸ“¡ Fetching Snapshot URI & REAL SIZE...")
    print(f"ğŸ“¡ Pobieranie URI Snapshotu i ROZMIARU RZECZYWISTEGO...")
    
    # Wait for Google to calculate storage bytes
    # Poczekaj aÅ¼ Google przeliczy bajty
    time.sleep(5) 
    
    cmd = [
        'gcloud', 'compute', 'snapshots', 'describe', snap_name,
        f'--project={project_id}', '--format=json'
    ]
    ok, out, err = run_cmd(cmd)
    if not ok: return None
    snap = json.loads(out)
    
    raw_time = snap.get('creationTimestamp', '')
    try:
        dt_aware = datetime.datetime.fromisoformat(raw_time)
        dt_local = dt_aware.astimezone()
        fmt_time = dt_local.strftime('%Y-%m-%d %H:%M:%S (Local)')
    except Exception as e: 
        fmt_time = raw_time

    # --- SIZE LOGIC V6.3 ---
    # --- LOGIKA ROZMIARU V6.3 ---
    disk_size_gb = snap.get('diskSizeGb', '0')
    storage_bytes = int(snap.get('storageBytes', 0))
    
    if storage_bytes > 0:
        real_size_gb = storage_bytes / (1024**3) # Convert to GB
        # Format: "X.XX GB (Real) / Y GB (Disk)"
        size_str = f"{real_size_gb:.2f} GB (Real) / {disk_size_gb} GB (Disk)"
    else:
        size_str = f"Calculating... / {disk_size_gb} GB (Disk)"

    return {
        'name': snap.get('name', 'UNKNOWN'),
        'status': snap.get('status', 'UNKNOWN'),
        'size': size_str, # TWO VALUES
        'time': fmt_time, 
        'link': snap.get('selfLink', 'UNKNOWN')
    }

def get_pcap_full_paths():
    # Scan directories for PCAP files
    # Skanuj katalogi w poszukiwaniu plikÃ³w PCAP
    files = []
    
    if not PCAP_PATHS:
        print("âš ï¸ No PCAP directories configured in config.yaml (LOCAL_PATHS).")
        print("âš ï¸ Nie skonfigurowano katalogÃ³w PCAP w config.yaml (LOCAL_PATHS).")
        return []

    for path in PCAP_PATHS:
        if not os.path.exists(path): 
            print(f"âš ï¸ Path not found: {path}")
            print(f"âš ï¸ ÅšcieÅ¼ka nie znaleziona: {path}")
            continue
        
        found_count = 0
        for filepath in glob.glob(os.path.join(path, "*.pcapng")):
            files.append(filepath)
            found_count += 1
        
        if found_count == 0:
            print(f"   (No .pcapng files in: {path})")
            print(f"   (Brak plikÃ³w .pcapng w: {path})")

    return files

def get_pcap_list_for_pdf():
    # Prepare PCAP list for PDF table
    # Przygotuj listÄ™ PCAP dla tabeli PDF
    files = []
    for filepath in get_pcap_full_paths():
        size_mb = os.path.getsize(filepath) / (1024 * 1024)
        source = os.path.basename(os.path.dirname(filepath))
        name = os.path.basename(filepath)
        files.append((source, name, f"{size_mb:.2f} MB"))
    return files

# --- PACKAGING LOGIC ---
# --- LOGIKA PAKOWANIA ---

def create_master_bundle(reports, pcaps, snap_data, vm_key, vm_name):
    # Generate timestamp and zip name
    # Generuj znacznik czasu i nazwÄ™ zip
    ts = datetime.datetime.now().strftime('%Y%m%d_%H%M')
    clean_vm_name = vm_name.replace(" ", "_") 
    zip_name = f"EVIDENCE_{vm_key}_{clean_vm_name}_{ts}.zip"
    
    print(f"\nğŸ“¦ PACKAGING MASTER EVIDENCE: {zip_name}")
    print(f"ğŸ“¦ PAKOWANIE GÅÃ“WNEGO MATERIAÅU: {zip_name}")
    print(f"   Target: {vm_key} -> {vm_name}")
    
    with zipfile.ZipFile(zip_name, 'w', zipfile.ZIP_DEFLATED) as zf:
        # 1. Reports
        for report in reports:
            if os.path.exists(report):
                zf.write(report, arcname=f"REPORTS/{os.path.basename(report)}")
                print(f"   + PDF: {report}")

        # 2. PCAP
        for pcap_path in pcaps:
            if os.path.exists(pcap_path):
                src_folder = os.path.basename(os.path.dirname(pcap_path))
                fname = os.path.basename(pcap_path)
                zf.write(pcap_path, arcname=f"NETWORK_PCAP/{src_folder}/{fname}")
                print(f"   + PCAP: {src_folder}/{fname}")

        # 3. LOGS
        print("   ğŸ” Deep scanning for Logs...")
        print("   ğŸ” GÅ‚Ä™bokie skanowanie logÃ³w...")
        found_logs = False
        
        # Use EVIDENCE_DIR loaded from config
        if os.path.exists(EVIDENCE_DIR):
            for root, dirs, files in os.walk(EVIDENCE_DIR):
                for file in files:
                    if file.endswith(".tar.gz") or file.endswith(".zip"):
                        full_path = os.path.join(root, file)
                        zf.write(full_path, arcname=f"SYSTEM_LOGS/{file}")
                        print(f"   + LOGS: {file}")
                        found_logs = True
        else:
             print(f"âš ï¸ Evidence directory not found: {EVIDENCE_DIR}")
             print(f"âš ï¸ Nie znaleziono katalogu dowodÃ³w: {EVIDENCE_DIR}")
        
        if not found_logs:
            print("   âš ï¸ WARNING: No log archives found!")
            print("   âš ï¸ OSTRZEÅ»ENIE: Nie znaleziono archiwÃ³w logÃ³w!")

        # 4. Info (ORIGINAL V6.3 FORMAT)
        # 4. Info (ORYGINALNY FORMAT V6.3)
        info_content = f"""
============================================================
=== BLOX-TAK-SERVER | FORENSIC SNAPSHOT INFO ===
============================================================
Target Key:   {vm_key}
Target Name:  {vm_name}
Snapshot ID:  {snap_data['name']}
Created At:   {snap_data['time']}
Status:       {snap_data['status']}
STORAGE SIZE: {snap_data['size']}
------------------------------------------------------------
RECOVERY LINK (DISK_IMAGE):
{snap_data['link']}
============================================================
        """
        zf.writestr("SNAPSHOT_INFO.txt", info_content)
        print("   + INFO: SNAPSHOT_INFO.txt")

    checksum = calculate_hash(zip_name)
    hash_filename = f"{zip_name}.sha256"
    print(f"ğŸ”’ PACKAGE SHA-256: {checksum}")
    print(f"ğŸ”’ SUMA KONTROLNA PAKIETU: {checksum}")
    
    with open(hash_filename, "w") as f:
        f.write(f"{checksum}  {zip_name}")

# --- PDF GENERATION ---
# --- GENEROWANIE PDF ---

class FinisherPDF(FPDF):
    def __init__(self, lang, snap_data):
        super().__init__()
        self.lang = lang
        self.t = TEXTS[lang]
        self.snap = snap_data

    def header(self):
        self.set_font('UbuntuMono', 'B', 14)
        self.cell(0, 10, self.t['header'], new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='C')
        self.line(10, 20, 200, 20)
        self.ln(10)

    def footer(self):
        self.set_y(-15)
        self.set_font('UbuntuMono', 'I', 8)
        self.cell(0, 10, f"{self.t['footer']} | {datetime.datetime.now().strftime('%Y-%m-%d')}", align='C')

def create_appendix_b(lang, output_pdf, pcap_list_pdf, snap_data):
    # Initialize PDF object
    # Inicjalizuj obiekt PDF
    pdf = FinisherPDF(lang, snap_data)
    t = TEXTS[lang]
    try:
        pdf.add_font('UbuntuMono', '', FONTS['R'])
        pdf.add_font('UbuntuMono', 'B', FONTS['B'])
        pdf.add_font('UbuntuMono', 'I', FONTS['I'])
        font = 'UbuntuMono'
    except: font = 'Courier'

    pdf.add_page()
    
    # 1. SNAPSHOT (FULL VISIBILITY)
    # 1. SNAPSHOT (PEÅNA WIDOCZNOÅšÄ†)
    pdf.set_font(font, 'B', 12)
    pdf.cell(0, 8, t['snap_sec'], new_x=XPos.LMARGIN, new_y=YPos.NEXT)
    pdf.set_font(font, '', 10)
    pdf.cell(0, 5, t['snap_desc'], new_x=XPos.LMARGIN, new_y=YPos.NEXT)
    pdf.ln(3)
    
    if snap_data:
        pdf.set_fill_color(240, 248, 255)
        pdf.rect(10, pdf.get_y(), 190, 50, 'F') 
        pdf.set_xy(12, pdf.get_y() + 2)
        
        def add_row(label, value, color=(0,0,0)):
            pdf.set_x(12)
            pdf.set_font(font, 'B', 10)
            pdf.cell(40, 6, label, border=0)
            pdf.set_font(font, '', 10)
            pdf.set_text_color(*color)
            pdf.cell(0, 6, value, new_x=XPos.LMARGIN, new_y=YPos.NEXT)
            pdf.set_text_color(0,0,0)

        add_row(t['snap_name'], snap_data['name'])
        add_row(t['snap_time'], snap_data['time'])
        add_row(t['snap_size'], snap_data['size']) # RESTORED TWO VALUES
        
        status_color = (0, 100, 0) if snap_data['status'] in ['READY', 'UPLOADING'] else (200, 0, 0)
        add_row(t['snap_status'], snap_data['status'], status_color)
        
        pdf.ln(2)
        pdf.set_x(12)
        pdf.set_font(font, 'B', 10)
        pdf.cell(0, 6, t['snap_link'], new_x=XPos.LMARGIN, new_y=YPos.NEXT)
        pdf.set_x(12)
        
        # EXPLICIT LINK FOR EVERYONE
        # JAWNY LINK DLA WSZYSTKICH
        pdf.set_font(font, '', 8)
        pdf.set_text_color(0, 0, 150)
        pdf.multi_cell(185, 4, snap_data['link'])
        pdf.set_text_color(0,0,0)
    else:
        pdf.cell(0, 10, "SNAPSHOT ERROR", align='C')
    pdf.ln(10)

    # 2. NETWORK (FULL VISIBILITY)
    # 2. SIECI (PEÅNA WIDOCZNOÅšÄ†)
    pdf.set_font(font, 'B', 12)
    pdf.cell(0, 8, t['net_sec'], new_x=XPos.LMARGIN, new_y=YPos.NEXT)
    
    # FULL TABLE
    # PEÅNA TABELA
    pdf.set_font(font, 'B', 9)
    pdf.set_fill_color(230, 230, 230)
    pdf.cell(25, 7, t['source'], 1, 0, 'C', True)
    pdf.cell(135, 7, t['filename'], 1, 0, 'C', True)
    pdf.cell(30, 7, t['size'], 1, 1, 'C', True)
    pdf.set_font(font, '', 8)
    if pcap_list_pdf:
        for source, fname, fsize in pcap_list_pdf:
            pdf.cell(25, 6, source, 1, 0, 'C')
            pdf.cell(135, 6, fname, 1, 0, 'L')
            pdf.cell(30, 6, fsize, 1, 1, 'R')
    else:
        pdf.cell(190, 6, "NO PCAP FILES DETECTED", 1, 1, 'C')
    
    pdf.ln(10)
    
    # 3. LEGAL
    # 3. PRAWNE
    pdf.set_font(font, 'B', 11)
    pdf.set_text_color(150, 0, 0)
    pdf.cell(0, 8, t['legal'], new_x=XPos.LMARGIN, new_y=YPos.NEXT)
    pdf.set_font(font, 'I', 10)
    pdf.set_text_color(0, 0, 0)
    pdf.multi_cell(0, 5, t['legal_text'], border=1, align='L')
    pdf.output(output_pdf)

def update_pdf_inplace(original_report, appendix_pdf):
    # Merge PDFs and overwrite the original file
    # Scal PDFy i nadpisz oryginalny plik
    writer = PdfWriter()
    try:
        # Read Original
        # Czytaj OryginaÅ‚
        reader_orig = PdfReader(original_report)
        for page in reader_orig.pages:
            writer.add_page(page)
        
        # Read Appendix
        # Czytaj ZaÅ‚Ä…cznik
        reader_app = PdfReader(appendix_pdf)
        for page in reader_app.pages:
            writer.add_page(page)

        # Write to temp file first
        # Najpierw zapisz do pliku tymczasowego
        temp_merged_name = original_report + ".tmp_merged"
        with open(temp_merged_name, "wb") as f_out:
            writer.write(f_out)
        
        # Replace original with merged
        # ZastÄ…p oryginaÅ‚ scalonym
        os.replace(temp_merged_name, original_report)
        
        print(f"      ğŸ“ Updated (In-Place): {os.path.basename(original_report)}")
        print(f"      ğŸ“ Zaktualizowano (W miejscu): {os.path.basename(original_report)}")
    except Exception as e:
        print(f"âŒ Error merging PDF: {e}")
        print(f"âŒ BÅ‚Ä…d scalania PDF: {e}")

# --- MAIN EXECUTION ---
# --- GÅÃ“WNE WYKONANIE ---

def main():
    # Clear terminal
    # WyczyÅ›Ä‡ terminal
    os.system("clear || cls")
    
    print("="*60)
    print("=== REPORT FINISHER v12.3 (YAML CONFIG + IN-PLACE) ===")
    print("=== FINALIZATOR RAPORTÃ“W v12.3 (KONFIGURACJA YAML + NADPISYWANIE) ===")
    print("="*60)
    
    # Load configuration
    # Wczytaj konfiguracjÄ™
    config = load_config()
    if not config: 
        print("âŒ Config file not found!")
        print("âŒ Nie znaleziono pliku konfiguracyjnego!")
        return
    
    gcp_conf = config.get('GLOBAL_SETTINGS', {}).get('gcp', {})
    project_id = gcp_conf.get('project_id')
    zone = gcp_conf.get('zone')
    
    # --- LIST CANDIDATES ---
    # --- LISTA KANDYDATÃ“W ---
    candidates = []
    for key, val in config.items():
        if key in ['GLOBAL_SETTINGS', 'LOCAL_CONFIG', 'LOCAL_PATHS']: continue
        if isinstance(val, dict) and 'name' in val:
            candidates.append((key, val['name']))

    if not candidates:
        print("âŒ No VM found in config!")
        print("âŒ Nie znaleziono VM w konfiguracji!")
        return

    target_key = None
    target_vm_name = None

    print("\nğŸ” Targets detected. Select VM to Finalize:")
    print("ğŸ” Wykryto cele. Wybierz VM do finalizacji:")
    for idx, (k, n) in enumerate(candidates):
        print(f"   [{idx+1}] {k} -> {n}")
        
    try:
        print("\nğŸ‘‰ Enter number: ")
        print("ğŸ‘‰ Wpisz numer: ")
        choice = int(input("> "))
        if 1 <= choice <= len(candidates):
            target_key, target_vm_name = candidates[choice-1]
            print(f"âœ… Selected: {target_vm_name}")
            print(f"âœ… Wybrano: {target_vm_name}")
        else:
            print("âŒ Invalid selection."); return
    except ValueError:
        print("âŒ Invalid input."); return
            
    snap_name = manage_vm_lifecycle(target_vm_name, project_id, zone)
    if not snap_name: return

    snap_data = get_snapshot_details(snap_name, project_id)
    if snap_data:
        print(f"\nğŸ”— DISK_IMAGE URI:\n{snap_data['link']}")
        print(f"ğŸ•’ TIMESTAMP: {snap_data['time']}")
        # RESTORED LOGIC REQUESTED
        print(f"ğŸ’¾ DISK INFO: {snap_data['size']}\n")

    pcaps_full = get_pcap_full_paths()
    pcaps_pdf = get_pcap_list_for_pdf()
    print(f"ğŸ” Found {len(pcaps_full)} PCAP files.")
    print(f"ğŸ” Znaleziono {len(pcaps_full)} plikÃ³w PCAP.")

    # --- PROCESS ALL REPORT VARIANTS ---
    # --- PRZETWARZANIE WSZYSTKICH WARIANTÃ“W RAPORTÃ“W ---
    
    # Find base reports (Auditor output)
    reports = glob.glob("*PORT_*.pdf")
    # Filter out temp files just in case
    reports = [r for r in reports if "temp" not in r]
    
    if not reports:
        print("âŒ No base reports found! Run auditor_smart.py first.")
        print("âŒ Nie znaleziono raportÃ³w bazowych! Uruchom najpierw auditor_smart.py.")
        return

    # In-place update list
    final_reports = [] 

    for report in reports:
        lang = 'EN' if 'REPORT' in report else 'PL'
        print(f"\nProcessing {report} [{lang}]...")
        print(f"Przetwarzanie {report} [{lang}]...")
        
        temp = f"temp_appendix_{lang}.pdf"
        
        # GENERATE APPENDIX B (NO CENSORSHIP)
        # GENERUJ ZAÅÄ„CZNIK B (BEZ CENZURY)
        create_appendix_b(lang, temp, pcaps_pdf, snap_data)
        
        # MERGE AND OVERWRITE
        # SCAL I NADPISZ
        update_pdf_inplace(report, temp)
        
        final_reports.append(report)
        os.remove(temp)

    create_master_bundle(final_reports, pcaps_full, snap_data, target_key, target_vm_name)

    print("\n" + "="*60)
    print("ğŸ‰ REPORT COMPLETE")
    print("ğŸ‰ RAPORT UKOÅƒCZONY")
    print("="*60)

if __name__ == "__main__":
    main()

--- END FILE: report_finisher.py ---

--- START FILE: requirements.txt ---
PyYAML==6.0.1

--- END FILE: requirements.txt ---

--- START FILE: setup.py ---
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# =====================================================================================
# === TAK SERVER REMOTE INSTALLER (v3.1 - Dependency Fix) ===
# === ZDALNY INSTALATOR TAK SERVER (v3.1 - Poprawka ZaleÅ¼noÅ›ci) ===
# =====================================================================================

import os
import subprocess
import yaml
import sys

# --- Configuration ---
# --- Konfiguracja ---
CONFIG_FILE = 'config.yaml'
LOCAL_CERTS_BASE_PATH = 'gcp_tak_certs'


# =====================================================================================
# === HELPER FUNCTIONS ===
# =====================================================================================

def run_command_local(command):
    """
    English: Runs a command on the local machine.
    Polski:  Uruchamia polecenie na lokalnej maszynie.
    """
    print(f"\nğŸ”„ Executing local command / Wykonywanie polecenia lokalnego: {' '.join(command)}")
    try:
        process = subprocess.run(command, check=True, capture_output=True, text=True)
        print("âœ… Command executed successfully / Polecenie wykonane pomyÅ›lnie.")
        return True
    except subprocess.CalledProcessError as e:
        print(f"âŒ ERROR: Command failed / BÅÄ„D: Polecenie zakoÅ„czyÅ‚o siÄ™ bÅ‚Ä™dem.")
        print(f"   Stderr: {e.stderr.strip()}")
        return False


def load_config():
    """
    English: Loads the main configuration file.
    Polski:  Wczytuje gÅ‚Ã³wny plik konfiguracyjny.
    """
    if not os.path.exists(CONFIG_FILE):
        print(f"âŒ ERROR: Configuration file '{CONFIG_FILE}' not found.")
        print(f"âŒ BÅÄ„D: Plik konfiguracyjny '{CONFIG_FILE}' nie zostaÅ‚ znaleziony.")
        return None
    try:
        with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
            return yaml.safe_load(f)
    except (IOError, yaml.YAMLError) as e:
        print(f"âŒ ERROR: Could not load configuration file '{CONFIG_FILE}': {e}")
        print(f"âŒ BÅÄ„D: Nie moÅ¼na wczytaÄ‡ pliku konfiguracyjnego '{CONFIG_FILE}': {e}")
        return None


def run_ssh_command(host_ip, user, command):
    """
    English: Runs a command in a non-interactive SSH session.
    Polski:  Uruchamia polecenie w sesji SSH (nieinteraktywnie).
    """
    ssh_command = ['ssh', '-o', 'StrictHostKeyChecking=no', '-o', 'ConnectTimeout=10', f'{user}@{host_ip}', command]
    print(f"\nğŸ”„ Executing command on '{host_ip}': {command}")
    print(f"ğŸ”„ Wykonywanie polecenia na '{host_ip}': {command}")
    try:
        # Use Popen to stream output in real-time
        process = subprocess.Popen(ssh_command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True,
                                   encoding='utf-8')
        while True:
            output = process.stdout.readline()
            if output == '' and process.poll() is not None:
                break
            if output:
                print(f"  [{host_ip}] > {output.strip()}")
        return process.poll()
    except Exception as e:
        print(f"âŒ An unexpected error occurred during SSH: {e}")
        print(f"âŒ WystÄ…piÅ‚ nieoczekiwany bÅ‚Ä…d podczas SSH: {e}")
        return 1


def run_ssh_interactive(host_ip, user, command):
    """
    English: Runs a command in an interactive SSH session.
    Polski:  Uruchamia polecenie w interaktywnej sesji SSH.
    """
    ssh_command = ['ssh', '-t', '-o', 'StrictHostKeyChecking=no', '-o', 'ConnectTimeout=10', f'{user}@{host_ip}',
                   command]
    print(f"\nğŸ”„ Connecting to '{host_ip}' as '{user}' to run the installation script...")
    print(f"ğŸ”„ ÅÄ…czenie z '{host_ip}' jako '{user}' w celu uruchomienia skryptu instalacyjnego...")
    print(f"    COMMAND / POLECENIE: {command}")
    print("-" * 60)
    print(">>> Starting interactive SSH session. / Rozpoczynanie interaktywnej sesji SSH. <<<")
    print("-" * 60)
    try:
        process = subprocess.run(ssh_command, check=False)
        return process.returncode
    except Exception as e:
        print(f"\nâŒ An unexpected error occurred during SSH: {e}")
        print(f"âŒ WystÄ…piÅ‚ nieoczekiwany bÅ‚Ä…d podczas SSH: {e}")
        return 1


# =====================================================================================
# === MAIN SCRIPT LOGIC ===
# =====================================================================================

def main():
    os.system("clear || cls")
    print("=" * 60)
    print("=== TAK SERVER REMOTE INSTALLER (v3.1) ===")
    print("=== ZDALNY INSTALATOR TAK SERVER (v3.1) ===")
    print("=" * 60)

    config = load_config()
    if not config: return

    # --- Krok 1: Wczytaj ustawienia ---
    global_settings = config.get('GLOBAL_SETTINGS', {})
    vm_settings = global_settings.get('vm', {})
    if not vm_settings:
        print("\nâŒ ERROR: Section 'GLOBAL_SETTINGS.vm' not found in config.yaml.")
        print("âŒ BÅÄ„D: Sekcja 'GLOBAL_SETTINGS.vm' nie zostaÅ‚a znaleziona w pliku config.yaml.")
        return

    ADMIN_USER = vm_settings.get('admin_user', 'blox_tak_server_admin')
    REMOTE_PROJECT_PATH = f'/home/{ADMIN_USER}/tak-server'

    # --- Krok 2: Wybierz serwer docelowy ---
    servers = {k: v for k, v in config.items() if isinstance(v, dict) and 'name' in v}
    if not servers:
        print(f"\nâŒ No server configurations found in '{CONFIG_FILE}'.")
        print(f"âŒ Nie znaleziono konfiguracji serwerÃ³w w pliku '{CONFIG_FILE}'.")
        return

    print("\nAvailable servers for installation:")
    print("DostÄ™pne serwery do instalacji:")
    for key, data in servers.items():
        print(f"  - {key}: {data['name']}")

    server_key = input(
        "\nSelect the server to run setup.sh on:\nWybierz serwer, na ktÃ³rym chcesz uruchomiÄ‡ setup.sh:\n> ").strip().upper()
    if server_key not in servers:
        print(f"\nâŒ ERROR: Key '{server_key}' not found.")
        print(f"âŒ BÅÄ„D: Klucz '{server_key}' nie zostaÅ‚ znaleziony.")
        return

    server_data = servers[server_key]
    ssh_host_ip = server_data.get('internal_ip')
    if not ssh_host_ip:
        print(f"âŒ ERROR: Missing 'internal_ip' for VM '{server_key}'. A VPN connection is required.")
        print(f"âŒ BÅÄ„D: Brak 'internal_ip' dla maszyny '{server_key}'. PoÅ‚Ä…czenie przez VPN jest wymagane.")
        return

    # --- Krok 3: Instalacja zaleÅ¼noÅ›ci na zdalnej maszynie (PRZYWRÃ“CONY) ---
    print("\n--- Step 3: Installing dependencies on the remote machine ---")
    print("--- Krok 3: Instalacja zaleÅ¼noÅ›ci na zdalnej maszynie ---")
    install_deps_command = "sudo apt-get update && sudo apt-get install -y net-tools zip"
    if run_ssh_command(ssh_host_ip, ADMIN_USER, install_deps_command) != 0:
        print("\nâŒ Failed to install dependencies. Aborting.")
        print("âŒ Nie udaÅ‚o siÄ™ zainstalowaÄ‡ zaleÅ¼noÅ›ci. Prerywam dziaÅ‚anie.")
        return
    print("âœ… Dependencies installed successfully. / ZaleÅ¼noÅ›ci zainstalowane pomyÅ›lnie.")

    # --- Krok 4: Uruchomienie skryptu setup.sh ---
    print("\n--- Step 4: Running remote TAK Server installation ---")
    print("--- Krok 4: Uruchomienie zdalnej instalacji TAK Server ---")
    remote_command = (f"sudo bash -c 'cd {REMOTE_PROJECT_PATH} && "
                      f"find scripts/ -type f -name \"*.sh\" -exec chmod +x {{}} \\; && "
                      f"./scripts/setup.sh'")
    return_code = run_ssh_interactive(ssh_host_ip, ADMIN_USER, remote_command)

    # --- Krok 5: Kopiowanie certyfikatÃ³w po udanej instalacji ---
    if return_code == 0:
        print("\n--- Step 5: Copying certificates to the local machine ---")
        print("--- Krok 5: Kopiowanie certyfikatÃ³w na maszynÄ™ lokalnÄ… ---")
        local_cert_path = os.path.join(LOCAL_CERTS_BASE_PATH, server_key)
        print(f"Creating local directory / Tworzenie lokalnego katalogu: {local_cert_path}")
        os.makedirs(local_cert_path, exist_ok=True)
        remote_cert_path = f"{REMOTE_PROJECT_PATH}/tak/certs/files/"
        scp_command = ["scp", "-r", f"{ADMIN_USER}@{ssh_host_ip}:{remote_cert_path}*", f"{local_cert_path}/"]
        run_command_local(scp_command)
    else:
        print("\n--- Step 5 skipped due to installation error. ---")
        print("--- Krok 5 pominiÄ™ty z powodu bÅ‚Ä™du instalacji. ---")

    print("\n" + "=" * 60)
    if return_code == 0:
        print("âœ¨ PROCESS FINISHED SUCCESSFULLY (Installation and Copying)!")
        print("âœ¨ PROCES ZAKOÅƒCZONY POMYÅšLNIE (Instalacja i Kopiowanie)!")
    else:
        print(f"âŒ PROCESS FINISHED WITH AN ERROR (exit code: {return_code}).")
        print(f"âŒ PROCES ZAKOÅƒCZONY BÅÄ˜DEM (kod wyjÅ›cia: {return_code}).")
    print("=" * 60)


if __name__ == '__main__':
    main()
--- END FILE: setup.py ---

